### ðŸŒ³ Codebase File Tree (Excluding ignored directories)

â”œâ”€â”€ Engine/
â””â”€â”€ â””â”€â”€ TakoEngine/
â”œâ”€â”€ GameProject/
â””â”€â”€ â”œâ”€â”€ 3DActionProject.vcxproj
â””â”€â”€ â”œâ”€â”€ 3DActionProject.vcxproj.filters
â””â”€â”€ â”œâ”€â”€ BehaviorTree/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Composites/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTRandomSelector.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTRandomSelector.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTSelector.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTSelector.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTSequence.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ BTSequence.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ Core/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTBlackboard.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTComposite.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTComposite.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ BTNode.h
â””â”€â”€ â”œâ”€â”€ CameraAnimation/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimation.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimation.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraKeyframe.h
â””â”€â”€ â”œâ”€â”€ CameraSystem/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimationEditor/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimationCurveEditor.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimationCurveEditor.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimationEditor.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimationEditor.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimationHistory.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimationHistory.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraAnimationTimeline.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ CameraAnimationTimeline.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraConfig.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraDebugUI.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraDebugUI.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraManager.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ Controller/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ CameraAnimationController.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ CameraAnimationController.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ICameraController.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ThirdPersonController.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ThirdPersonController.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TopDownController.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ TopDownController.h
â””â”€â”€ â”œâ”€â”€ Collision/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossBulletCollider.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossBulletCollider.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossMeleeAttackCollider.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossMeleeAttackCollider.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionTypeIdDef.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MeleeAttackCollider.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MeleeAttackCollider.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayerBulletCollider.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ PlayerBulletCollider.h
â””â”€â”€ â”œâ”€â”€ Common/
â””â”€â”€ â””â”€â”€ â””â”€â”€ GameConst.h
â””â”€â”€ â”œâ”€â”€ Input/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ InputHandler.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ InputHandler.h
â””â”€â”€ â”œâ”€â”€ MyGame/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MyGame.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ MyGame.h
â””â”€â”€ â”œâ”€â”€ Object/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Boss/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Boss.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Boss.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossBehaviorTree/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Actions/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossApproach.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossApproach.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossDash.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossDash.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossIdle.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossIdle.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossMeleeAttack.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossMeleeAttack.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossRapidFire.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossRapidFire.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossRetreat.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossRetreat.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BTBossShoot.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ BTBossShoot.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossBehaviorTree.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossBehaviorTree.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossNodeFactory.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossNodeFactory.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Conditions/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTActionSelector.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTActionSelector.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTBossDistanceCondition.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTBossDistanceCondition.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTBossHPCondition.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTBossHPCondition.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BTBossPhaseCondition.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ BTBossPhaseCondition.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ BossNodeEditor/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BossNodeEditor.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ BossNodeEditor.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ State/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ AttackState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ AttackState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DashState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DashState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ IdleState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ IdleState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ MoveState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ MoveState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ParryState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ParryState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PlayerState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PlayerState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PlayerStateMachine.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PlayerStateMachine.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ShootState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ ShootState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ Projectile/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BossBullet.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BossBullet.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PlayerBullet.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PlayerBullet.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Projectile.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ Projectile.h
â””â”€â”€ â”œâ”€â”€ main.cpp
â””â”€â”€ â””â”€â”€ scene/
â””â”€â”€     â”œâ”€â”€ ClearScene.cpp
â””â”€â”€     â”œâ”€â”€ ClearScene.h
â””â”€â”€     â”œâ”€â”€ GameScene.cpp
â””â”€â”€     â”œâ”€â”€ GameScene.h
â””â”€â”€     â”œâ”€â”€ OverScene.cpp
â””â”€â”€     â”œâ”€â”€ OverScene.h
â””â”€â”€     â”œâ”€â”€ SampleScene.cpp
â””â”€â”€     â”œâ”€â”€ SampleScene.h
â””â”€â”€     â”œâ”€â”€ SceneFactory.cpp
â””â”€â”€     â”œâ”€â”€ SceneFactory.h
â””â”€â”€     â”œâ”€â”€ TitleScene.cpp
â””â”€â”€     â””â”€â”€ TitleScene.h
================================================================================


============================================================
File Path: GameProject/3DActionProject.vcxproj
============================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{19540cf1-6fc6-4a6e-8612-a1e088f1b26e}</ProjectGuid>
    <RootNamespace>My3DActionProject</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>01_3DActionProject</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)\Generated\outputs\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\Generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>$(WindowsSDK_IncludePath);$(ProjectDir);$(VC_IncludePath);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\Generated\outputs\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\Generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>$(WindowsSDK_IncludePath);$(ProjectDir);$(VC_IncludePath);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>$(ProjectDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll"
copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"
copy "$(SolutionDir)Engine\TakoEngine\project\externals\assimp\lib\Debug\assimp-vc143-mtd.pdb" "$(TargetDir)assimp-vc143-mtd.pdb"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <AdditionalIncludeDirectories>$(ProjectDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <Optimization>MinSpace</Optimization>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll"
copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="BehaviorTree\Composites\BTSelector.cpp" />
    <ClCompile Include="BehaviorTree\Composites\BTSequence.cpp" />
    <ClCompile Include="BehaviorTree\Composites\BTRandomSelector.cpp" />
    <ClCompile Include="BehaviorTree\Core\BTComposite.cpp" />
    <ClCompile Include="CameraAnimation\CameraAnimation.cpp" />
    <ClCompile Include="CameraSystem\Controller\CameraAnimationController.cpp" />
    <ClCompile Include="CameraSystem\CameraDebugUI.cpp" />
    <ClCompile Include="CameraSystem\CameraManager.cpp" />
    <ClCompile Include="CameraSystem\Controller\ThirdPersonController.cpp" />
    <ClCompile Include="CameraSystem\CameraAnimationEditor\CameraAnimationEditor.cpp" />
    <ClCompile Include="CameraSystem\CameraAnimationEditor\CameraAnimationTimeline.cpp" />
    <ClCompile Include="CameraSystem\CameraAnimationEditor\CameraAnimationCurveEditor.cpp" />
    <ClCompile Include="CameraSystem\CameraAnimationEditor\CameraAnimationHistory.cpp" />
    <ClCompile Include="CameraSystem\Controller\TopDownController.cpp" />
    <ClCompile Include="Collision\BossMeleeAttackCollider.cpp" />
    <ClCompile Include="Collision\PlayerBulletCollider.cpp" />
    <ClCompile Include="Input\InputHandler.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="MyGame\MyGame.cpp" />
    <ClCompile Include="Object\Boss\Boss.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossApproach.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossDash.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossIdle.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossMeleeAttack.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossRapidFire.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossRetreat.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossShoot.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\BossBehaviorTree.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Conditions\BTActionSelector.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Conditions\BTBossPhaseCondition.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Conditions\BTBossHPCondition.cpp" />
    <ClCompile Include="Object\Boss\BossBehaviorTree\Conditions\BTBossDistanceCondition.cpp" />
    <ClCompile Include="Object\Boss\BossNodeEditor\BossNodeEditor.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\BossNodeFactory.cpp" />
    <ClCompile Include="Collision\MeleeAttackCollider.cpp" />
    <ClCompile Include="Object\Player\Player.cpp" />
    <ClCompile Include="Object\Player\State\AttackState.cpp" />
    <ClCompile Include="Object\Player\State\DashState.cpp" />
    <ClCompile Include="Object\Player\State\IdleState.cpp" />
    <ClCompile Include="Object\Player\State\ParryState.cpp" />
    <ClCompile Include="Object\Player\State\PlayerState.cpp" />
    <ClCompile Include="Object\Player\State\PlayerStateMachine.cpp" />
    <ClCompile Include="Object\Player\State\ShootState.cpp" />
    <ClCompile Include="Object\Player\State\MoveState.cpp" />
    <ClCompile Include="Object\Projectile\BossBullet.cpp" />
    <ClCompile Include="Collision\BossBulletCollider.cpp" />
    <ClCompile Include="Object\Projectile\PlayerBullet.cpp" />
    <ClCompile Include="Object\Projectile\Projectile.cpp" />
    <ClCompile Include="scene\ClearScene.cpp" />
    <ClCompile Include="scene\GameScene.cpp" />
    <ClCompile Include="scene\OverScene.cpp" />
    <ClCompile Include="scene\SampleScene.cpp" />
    <ClCompile Include="scene\SceneFactory.cpp" />
    <ClCompile Include="scene\TitleScene.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Engine\TakoEngine\project\externals\DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj">
      <Project>{371b9fa9-4c90-4ac6-a123-aced756d6c77}</Project>
    </ProjectReference>
    <ProjectReference Include="..\Engine\TakoEngine\project\externals\imgui\imgui.vcxproj" Condition="'$(Configuration)'=='Debug'">
      <Project>{ffa51982-471d-4530-909e-c8fb8fe4f342}</Project>
    </ProjectReference>
    <ProjectReference Include="..\Engine\TakoEngine\project\TakoEngine.vcxproj">
      <Project>{5667d840-f080-4f39-b016-fd2c1b9375e7}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="BehaviorTree\Composites\BTSelector.h" />
    <ClInclude Include="BehaviorTree\Composites\BTSequence.h" />
    <ClInclude Include="BehaviorTree\Composites\BTRandomSelector.h" />
    <ClInclude Include="BehaviorTree\Core\BTBlackboard.h" />
    <ClInclude Include="BehaviorTree\Core\BTComposite.h" />
    <ClInclude Include="BehaviorTree\Core\BTNode.h" />
    <ClInclude Include="CameraAnimation\CameraAnimation.h" />
    <ClInclude Include="CameraAnimation\CameraKeyframe.h" />
    <ClInclude Include="CameraSystem\Controller\CameraAnimationController.h" />
    <ClInclude Include="CameraSystem\CameraConfig.h" />
    <ClInclude Include="CameraSystem\CameraDebugUI.h" />
    <ClInclude Include="CameraSystem\CameraManager.h" />
    <ClInclude Include="CameraSystem\Controller\ThirdPersonController.h" />
    <ClInclude Include="CameraSystem\CameraAnimationEditor\CameraAnimationEditor.h" />
    <ClInclude Include="CameraSystem\CameraAnimationEditor\CameraAnimationTimeline.h" />
    <ClInclude Include="CameraSystem\CameraAnimationEditor\CameraAnimationCurveEditor.h" />
    <ClInclude Include="CameraSystem\CameraAnimationEditor\CameraAnimationHistory.h" />
    <ClInclude Include="CameraSystem\Controller\ICameraController.h" />
    <ClInclude Include="CameraSystem\Controller\TopDownController.h" />
    <ClInclude Include="Collision\BossMeleeAttackCollider.h" />
    <ClInclude Include="Collision\CollisionTypeIdDef.h" />
    <ClInclude Include="Collision\PlayerBulletCollider.h" />
    <ClInclude Include="Common\GameConst.h" />
    <ClInclude Include="Input\InputHandler.h" />
    <ClInclude Include="MyGame\MyGame.h" />
    <ClInclude Include="Object\Boss\Boss.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossApproach.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossDash.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossIdle.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossMeleeAttack.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossRapidFire.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossRetreat.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossShoot.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\BossBehaviorTree.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Conditions\BTActionSelector.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Conditions\BTBossPhaseCondition.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Conditions\BTBossHPCondition.h" />
    <ClInclude Include="Object\Boss\BossBehaviorTree\Conditions\BTBossDistanceCondition.h" />
    <ClInclude Include="Object\Boss\BossNodeEditor\BossNodeEditor.h">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\BossNodeFactory.h" />
    <ClInclude Include="Collision\MeleeAttackCollider.h" />
    <ClInclude Include="Object\Player\Player.h" />
    <ClInclude Include="Object\Player\State\AttackState.h" />
    <ClInclude Include="Object\Player\State\DashState.h" />
    <ClInclude Include="Object\Player\State\IdleState.h" />
    <ClInclude Include="Object\Player\State\ParryState.h" />
    <ClInclude Include="Object\Player\State\PlayerState.h" />
    <ClInclude Include="Object\Player\State\PlayerStateMachine.h" />
    <ClInclude Include="Object\Player\State\ShootState.h" />
    <ClInclude Include="Object\Player\State\MoveState.h" />
    <ClInclude Include="Object\Projectile\BossBullet.h" />
    <ClInclude Include="Collision\BossBulletCollider.h" />
    <ClInclude Include="Object\Projectile\PlayerBullet.h" />
    <ClInclude Include="Object\Projectile\Projectile.h" />
    <ClInclude Include="scene\ClearScene.h" />
    <ClInclude Include="scene\GameScene.h" />
    <ClInclude Include="scene\OverScene.h" />
    <ClInclude Include="scene\SampleScene.h" />
    <ClInclude Include="scene\SceneFactory.h" />
    <ClInclude Include="scene\TitleScene.h" />
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="resources\shaders\2D.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\2D.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Bloom.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\BloomCombine.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\BloomFog.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\BWFilter.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\DepthBasedOutline.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Dissolve.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\EmitParticle.CS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Fog.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\FullScreen.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\GaussianBloom.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\GaussianBlur.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\GPUParticle.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\GPUParticle.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\GrayScale.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\HalfTone.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\InitParticle.CS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\LuminanceBasedOutline.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\NoEffect.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3D.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\RadialBlur.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\RGBSplit.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\ShadowMap.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Skinning.CS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\SkinningObject3d.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\SkyBox.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\SkyBox.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Sprite.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Sprite.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\ThresholdExtract.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\UpdateParticle.CS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Vignette.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\VignetteRedBloom.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\WhiteNoise.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="resources\shaders\FullScreen.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="resources\shaders\Object3d.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="resources\shaders\Particle.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="resources\shaders\Random.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="resources\shaders\SkyBox.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="resources\shaders\Sprite.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: GameProject/3DActionProject.vcxproj.filters
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="MyGame">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Collision">
      <UniqueIdentifier>{a8b2c4d5-9e7f-4b8c-9a5e-6f8d9c2e1b3a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object">
      <UniqueIdentifier>{c9c423bc-ae11-4ec8-9076-12ef0dc66417}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object\Player">
      <UniqueIdentifier>{96f89a17-9a2b-440d-a2aa-684b74ce08fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object\Player\State">
      <UniqueIdentifier>{4cb39fb4-efb0-4602-94cf-025f0769bf0e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Input">
      <UniqueIdentifier>{450f4fb5-36fd-4024-bcd2-b3db6b3d4f77}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object\Boss">
      <UniqueIdentifier>{2eb72ef7-09cc-4ffc-9df7-2ec9f26636ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="CameraSystem">
      <UniqueIdentifier>{0312f1a8-e010-49cd-8145-fa5b444de6dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="CameraSystem\CameraAnimationEditor">
      <UniqueIdentifier>{a1b2c3d4-e5f6-7890-abcd-ef1234567890}</UniqueIdentifier>
    </Filter>
    <Filter Include="CameraSystem\Controller">
      <UniqueIdentifier>{f57ae9da-7b8a-4870-ae5e-44402f6a7ed3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Scene">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Shader">
      <UniqueIdentifier>{d65b8000-b0cc-4fba-a0a9-615e83f5f731}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shader\PostEffect">
      <UniqueIdentifier>{6abeb51c-45a4-4685-8def-0171cfa5f67f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shader\Particle">
      <UniqueIdentifier>{1711c129-d43f-4320-a8ce-b78ef752b5d7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shader\ShadowMap">
      <UniqueIdentifier>{c8a61253-1e2e-400c-a4fb-e5a946d52b8e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shader\2D">
      <UniqueIdentifier>{426dcab9-3649-448f-9e02-c6783e00780f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shader\3D">
      <UniqueIdentifier>{3563bb5b-e7ce-4874-aa39-2e413a4572ee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object\Projectile">
      <UniqueIdentifier>{93d8772f-6abc-484f-8174-74dbb0339c46}</UniqueIdentifier>
    </Filter>
    <Filter Include="BehaviorTree">
      <UniqueIdentifier>{09a017ea-3980-4572-a8f0-95ab2716a08d}</UniqueIdentifier>
    </Filter>
    <Filter Include="BehaviorTree\Composite">
      <UniqueIdentifier>{54752936-db44-4750-ae6b-d9594579c3b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="BehaviorTree\Core">
      <UniqueIdentifier>{e36fa40f-3ecd-4b49-ab2a-3d9574a50ab8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object\Boss\BossBehaviorTree">
      <UniqueIdentifier>{8fadaa47-22cd-4bb9-8d8f-bdf710112485}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object\Boss\BossBehaviorTree\Actions">
      <UniqueIdentifier>{85eda742-c011-4c2b-9262-01840d23b173}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object\Boss\BossBehaviorTree\Conditions">
      <UniqueIdentifier>{4b1eb71d-c76e-4ef5-83ed-9bdace6a3b5c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Object\Boss\BossNodeEditor">
      <UniqueIdentifier>{25c158da-6b5c-4fac-9f5e-e540c569d30e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Common">
      <UniqueIdentifier>{2efc4229-8240-4c6f-8339-ac353fe07ab6}</UniqueIdentifier>
    </Filter>
    <Filter Include="CameraAnimation">
      <UniqueIdentifier>{91d85fa5-151f-4004-88ba-6c651e6f09b2}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="MyGame\MyGame.cpp">
      <Filter>MyGame</Filter>
    </ClCompile>
    <ClCompile Include="scene\GameScene.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="scene\SampleScene.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="scene\SceneFactory.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="scene\TitleScene.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="Object\Player\State\IdleState.cpp">
      <Filter>Object\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="Object\Player\State\PlayerState.cpp">
      <Filter>Object\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="Object\Player\State\PlayerStateMachine.cpp">
      <Filter>Object\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="Object\Player\State\MoveState.cpp">
      <Filter>Object\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="Object\Player\Player.cpp">
      <Filter>Object\Player</Filter>
    </ClCompile>
    <ClCompile Include="Object\Player\State\AttackState.cpp">
      <Filter>Object\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="Object\Player\State\DashState.cpp">
      <Filter>Object\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="Object\Player\State\ParryState.cpp">
      <Filter>Object\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="Object\Player\State\ShootState.cpp">
      <Filter>Object\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="Input\InputHandler.cpp">
      <Filter>Input</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\Boss.cpp">
      <Filter>Object\Boss</Filter>
    </ClCompile>
    <ClCompile Include="scene\ClearScene.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\CameraDebugUI.cpp">
      <Filter>CameraSystem</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\CameraAnimationEditor\CameraAnimationEditor.cpp">
      <Filter>CameraSystem\CameraAnimationEditor</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\CameraAnimationEditor\CameraAnimationTimeline.cpp">
      <Filter>CameraSystem\CameraAnimationEditor</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\CameraAnimationEditor\CameraAnimationCurveEditor.cpp">
      <Filter>CameraSystem\CameraAnimationEditor</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\CameraAnimationEditor\CameraAnimationHistory.cpp">
      <Filter>CameraSystem\CameraAnimationEditor</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\CameraManager.cpp">
      <Filter>CameraSystem</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\Controller\CameraAnimationController.cpp">
      <Filter>CameraSystem\Controller</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\Controller\ThirdPersonController.cpp">
      <Filter>CameraSystem\Controller</Filter>
    </ClCompile>
    <ClCompile Include="CameraSystem\Controller\TopDownController.cpp">
      <Filter>CameraSystem\Controller</Filter>
    </ClCompile>
    <ClCompile Include="Collision\MeleeAttackCollider.cpp">
      <Filter>Collision</Filter>
    </ClCompile>
    <ClCompile Include="Object\Projectile\BossBullet.cpp">
      <Filter>Object\Projectile</Filter>
    </ClCompile>
    <ClCompile Include="Object\Projectile\Projectile.cpp">
      <Filter>Object\Projectile</Filter>
    </ClCompile>
    <ClCompile Include="Collision\BossBulletCollider.cpp">
      <Filter>Collision</Filter>
    </ClCompile>
    <ClCompile Include="scene\OverScene.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="BehaviorTree\Composites\BTSelector.cpp">
      <Filter>BehaviorTree\Composite</Filter>
    </ClCompile>
    <ClCompile Include="BehaviorTree\Composites\BTSequence.cpp">
      <Filter>BehaviorTree\Composite</Filter>
    </ClCompile>
    <ClCompile Include="BehaviorTree\Composites\BTRandomSelector.cpp">
      <Filter>BehaviorTree\Composite</Filter>
    </ClCompile>
    <ClCompile Include="BehaviorTree\Core\BTComposite.cpp">
      <Filter>BehaviorTree\Core</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossDash.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossIdle.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossShoot.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Conditions\BTActionSelector.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Conditions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\BossBehaviorTree.cpp">
      <Filter>Object\Boss\BossBehaviorTree</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossNodeEditor\BossNodeEditor.cpp">
      <Filter>Object\Boss\BossNodeEditor</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossRapidFire.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Conditions\BTBossDistanceCondition.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Conditions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Conditions\BTBossHPCondition.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Conditions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Conditions\BTBossPhaseCondition.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Conditions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\BossNodeFactory.cpp">
      <Filter>Object\Boss\BossBehaviorTree</Filter>
    </ClCompile>
    <ClCompile Include="CameraAnimation\CameraAnimation.cpp">
      <Filter>CameraAnimation</Filter>
    </ClCompile>
    <ClCompile Include="Collision\PlayerBulletCollider.cpp">
      <Filter>Collision</Filter>
    </ClCompile>
    <ClCompile Include="Object\Projectile\PlayerBullet.cpp">
      <Filter>Object\Projectile</Filter>
    </ClCompile>
    <ClCompile Include="Collision\BossMeleeAttackCollider.cpp">
      <Filter>Collision</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossMeleeAttack.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossApproach.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClCompile>
    <ClCompile Include="Object\Boss\BossBehaviorTree\Actions\BTBossRetreat.cpp">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Collision\CollisionTypeIdDef.h">
      <Filter>Collision</Filter>
    </ClInclude>
    <ClInclude Include="MyGame\MyGame.h">
      <Filter>MyGame</Filter>
    </ClInclude>
    <ClInclude Include="scene\GameScene.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="scene\SampleScene.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="scene\SceneFactory.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="scene\TitleScene.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\State\IdleState.h">
      <Filter>Object\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\State\PlayerState.h">
      <Filter>Object\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\State\PlayerStateMachine.h">
      <Filter>Object\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\State\MoveState.h">
      <Filter>Object\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\Player.h">
      <Filter>Object\Player</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\State\AttackState.h">
      <Filter>Object\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\State\DashState.h">
      <Filter>Object\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\State\ParryState.h">
      <Filter>Object\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="Object\Player\State\ShootState.h">
      <Filter>Object\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="Input\InputHandler.h">
      <Filter>Input</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\Boss.h">
      <Filter>Object\Boss</Filter>
    </ClInclude>
    <ClInclude Include="scene\ClearScene.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\CameraConfig.h">
      <Filter>CameraSystem</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\CameraDebugUI.h">
      <Filter>CameraSystem</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\CameraAnimationEditor\CameraAnimationEditor.h">
      <Filter>CameraSystem\CameraAnimationEditor</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\CameraAnimationEditor\CameraAnimationTimeline.h">
      <Filter>CameraSystem\CameraAnimationEditor</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\CameraAnimationEditor\CameraAnimationCurveEditor.h">
      <Filter>CameraSystem\CameraAnimationEditor</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\CameraAnimationEditor\CameraAnimationHistory.h">
      <Filter>CameraSystem\CameraAnimationEditor</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\CameraManager.h">
      <Filter>CameraSystem</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\Controller\CameraAnimationController.h">
      <Filter>CameraSystem\Controller</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\Controller\ThirdPersonController.h">
      <Filter>CameraSystem\Controller</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\Controller\ICameraController.h">
      <Filter>CameraSystem\Controller</Filter>
    </ClInclude>
    <ClInclude Include="CameraSystem\Controller\TopDownController.h">
      <Filter>CameraSystem\Controller</Filter>
    </ClInclude>
    <ClInclude Include="Collision\MeleeAttackCollider.h">
      <Filter>Collision</Filter>
    </ClInclude>
    <ClInclude Include="Object\Projectile\BossBullet.h">
      <Filter>Object\Projectile</Filter>
    </ClInclude>
    <ClInclude Include="Object\Projectile\Projectile.h">
      <Filter>Object\Projectile</Filter>
    </ClInclude>
    <ClInclude Include="Collision\BossBulletCollider.h">
      <Filter>Collision</Filter>
    </ClInclude>
    <ClInclude Include="scene\OverScene.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="BehaviorTree\Composites\BTSelector.h">
      <Filter>BehaviorTree\Composite</Filter>
    </ClInclude>
    <ClInclude Include="BehaviorTree\Composites\BTSequence.h">
      <Filter>BehaviorTree\Composite</Filter>
    </ClInclude>
    <ClInclude Include="BehaviorTree\Composites\BTRandomSelector.h">
      <Filter>BehaviorTree\Composite</Filter>
    </ClInclude>
    <ClInclude Include="BehaviorTree\Core\BTBlackboard.h">
      <Filter>BehaviorTree\Core</Filter>
    </ClInclude>
    <ClInclude Include="BehaviorTree\Core\BTComposite.h">
      <Filter>BehaviorTree\Core</Filter>
    </ClInclude>
    <ClInclude Include="BehaviorTree\Core\BTNode.h">
      <Filter>BehaviorTree\Core</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossDash.h">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossIdle.h">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossShoot.h">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Conditions\BTActionSelector.h">
      <Filter>Object\Boss\BossBehaviorTree\Conditions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\BossBehaviorTree.h">
      <Filter>Object\Boss\BossBehaviorTree</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossNodeEditor\BossNodeEditor.h">
      <Filter>Object\Boss\BossNodeEditor</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossRapidFire.h">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Conditions\BTBossDistanceCondition.h">
      <Filter>Object\Boss\BossBehaviorTree\Conditions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Conditions\BTBossHPCondition.h">
      <Filter>Object\Boss\BossBehaviorTree\Conditions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Conditions\BTBossPhaseCondition.h">
      <Filter>Object\Boss\BossBehaviorTree\Conditions</Filter>
    </ClInclude>
    <ClInclude Include="Common\GameConst.h">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\BossNodeFactory.h">
      <Filter>Object\Boss\BossBehaviorTree</Filter>
    </ClInclude>
    <ClInclude Include="CameraAnimation\CameraAnimation.h">
      <Filter>CameraAnimation</Filter>
    </ClInclude>
    <ClInclude Include="CameraAnimation\CameraKeyframe.h">
      <Filter>CameraAnimation</Filter>
    </ClInclude>
    <ClInclude Include="Collision\PlayerBulletCollider.h">
      <Filter>Collision</Filter>
    </ClInclude>
    <ClInclude Include="Object\Projectile\PlayerBullet.h">
      <Filter>Object\Projectile</Filter>
    </ClInclude>
    <ClInclude Include="Collision\BossMeleeAttackCollider.h">
      <Filter>Collision</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossMeleeAttack.h">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossApproach.h">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClInclude>
    <ClInclude Include="Object\Boss\BossBehaviorTree\Actions\BTBossRetreat.h">
      <Filter>Object\Boss\BossBehaviorTree\Actions</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="resources\shaders\Object3d.PS.hlsl">
      <Filter>Shader\3D</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3D.VS.hlsl">
      <Filter>Shader\3D</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\2D.PS.hlsl">
      <Filter>Shader\2D</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\2D.VS.hlsl">
      <Filter>Shader\2D</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Bloom.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\BloomCombine.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\BloomFog.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\BWFilter.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\DepthBasedOutline.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Dissolve.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Fog.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\FullScreen.VS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\GaussianBloom.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\GaussianBlur.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\HalfTone.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\LuminanceBasedOutline.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\NoEffect.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\RadialBlur.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\RGBSplit.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\ThresholdExtract.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Vignette.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\VignetteRedBloom.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\WhiteNoise.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\EmitParticle.CS.hlsl">
      <Filter>Shader\Particle</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\GPUParticle.PS.hlsl">
      <Filter>Shader\Particle</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\GPUParticle.VS.hlsl">
      <Filter>Shader\Particle</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\InitParticle.CS.hlsl">
      <Filter>Shader\Particle</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\UpdateParticle.CS.hlsl">
      <Filter>Shader\Particle</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\GrayScale.PS.hlsl">
      <Filter>Shader\PostEffect</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\ShadowMap.VS.hlsl">
      <Filter>Shader\ShadowMap</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Skinning.CS.hlsl">
      <Filter>Shader\ShadowMap</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\SkinningObject3d.VS.hlsl">
      <Filter>Shader\3D</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Sprite.PS.hlsl">
      <Filter>Shader\2D</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Sprite.VS.hlsl">
      <Filter>Shader\2D</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\SkyBox.PS.hlsl">
      <Filter>Shader\3D</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\SkyBox.VS.hlsl">
      <Filter>Shader\3D</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="resources\shaders\Random.hlsli">
      <Filter>Shader</Filter>
    </None>
    <None Include="resources\shaders\Object3d.hlsli">
      <Filter>Shader\3D</Filter>
    </None>
    <None Include="resources\shaders\FullScreen.hlsli">
      <Filter>Shader\PostEffect</Filter>
    </None>
    <None Include="resources\shaders\Particle.hlsli">
      <Filter>Shader\Particle</Filter>
    </None>
    <None Include="resources\shaders\Sprite.hlsli">
      <Filter>Shader\2D</Filter>
    </None>
    <None Include="resources\shaders\SkyBox.hlsli">
      <Filter>Shader\3D</Filter>
    </None>
  </ItemGroup>
</Project>

============================================================
File Path: GameProject/BehaviorTree/Composites/BTRandomSelector.cpp
============================================================
#include "BTRandomSelector.h"
#include "RandomEngine.h"
#include <algorithm>

BTRandomSelector::BTRandomSelector() {
    name_ = "RandomSelector";
}

BTNodeStatus BTRandomSelector::Execute(BTBlackboard* blackboard) {
    if (children_.empty()) {
        return BTNodeStatus::Failure;
    }

    // æ–°ã—ã„é¸æŠžã‚µã‚¤ã‚¯ãƒ«ã®é–‹å§‹æ™‚ã®ã¿ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    if (needsShuffle_) {
        ShuffleIndices();
        needsShuffle_ = false;
        currentShuffledIdx_ = 0;
    }

    // ã‚·ãƒ£ãƒƒãƒ•ãƒ«é †ã§å®Ÿè¡Œï¼ˆå‰å›žã®Runningä½ç½®ã‹ã‚‰ç¶™ç¶šï¼‰
    for (size_t i = currentShuffledIdx_; i < shuffledIndices_.size(); ++i) {
        size_t idx = shuffledIndices_[i];
        BTNodeStatus childStatus = children_[idx]->Execute(blackboard);

        if (childStatus == BTNodeStatus::Success) {
            needsShuffle_ = true;  // æ¬¡å›žã¯ã‚·ãƒ£ãƒƒãƒ•ãƒ«
            status_ = BTNodeStatus::Success;
            return status_;
        }
        else if (childStatus == BTNodeStatus::Running) {
            currentShuffledIdx_ = i;  // ç¾åœ¨ä½ç½®ã‚’è¨˜æ†¶ï¼ˆã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ãªã„ï¼‰
            status_ = BTNodeStatus::Running;
            return status_;
        }
        // Failureã®å ´åˆã¯æ¬¡ã¸
    }

    // å…¨ã¦å¤±æ•—
    needsShuffle_ = true;  // æ¬¡å›žã¯ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    status_ = BTNodeStatus::Failure;
    return status_;
}

void BTRandomSelector::Reset() {
    BTNode::Reset();
    currentShuffledIdx_ = 0;
    needsShuffle_ = true;
}

void BTRandomSelector::ShuffleIndices() {
    shuffledIndices_.resize(children_.size());
    for (size_t i = 0; i < children_.size(); ++i) {
        shuffledIndices_[i] = i;
    }

    // Fisher-Yatesã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆRandomEngineä½¿ç”¨ï¼‰
    RandomEngine* rng = RandomEngine::GetInstance();
    for (size_t i = shuffledIndices_.size() - 1; i > 0; --i) {
        size_t j = static_cast<size_t>(rng->GetInt(0, static_cast<int>(i)));
        std::swap(shuffledIndices_[i], shuffledIndices_[j]);
    }
}


============================================================
File Path: GameProject/BehaviorTree/Composites/BTRandomSelector.h
============================================================
#pragma once
#include "../Core/BTComposite.h"
#include "../Core/BTBlackboard.h"
#include <vector>

/// <summary>
/// ãƒ©ãƒ³ãƒ€ãƒ ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ãƒŽãƒ¼ãƒ‰
/// å­ãƒŽãƒ¼ãƒ‰ã‚’ãƒ©ãƒ³ãƒ€ãƒ ãªé †åºã§å®Ÿè¡Œã—ã€æœ€åˆã«æˆåŠŸã—ãŸã¨ã“ã‚ã§åœæ­¢
/// </summary>
class BTRandomSelector : public BTComposite {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTRandomSelector();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTRandomSelector() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// çŠ¶æ…‹ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

private: // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ãƒ³ãƒãƒ¼é–¢æ•°
    /// <summary>
    /// å­ãƒŽãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    /// </summary>
    void ShuffleIndices();

private:
    // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    std::vector<size_t> shuffledIndices_;

    // ç¾åœ¨ã®ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ¸ˆã¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½ç½®ï¼ˆRunningçŠ¶æ…‹ã®ç¶™ç¶šç”¨ï¼‰
    size_t currentShuffledIdx_ = 0;

    // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ãŒå¿…è¦ã‹ã©ã†ã‹ï¼ˆæ–°ã—ã„é¸æŠžã‚µã‚¤ã‚¯ãƒ«é–‹å§‹æ™‚ã«trueï¼‰
    bool needsShuffle_ = true;


};


============================================================
File Path: GameProject/BehaviorTree/Composites/BTSelector.cpp
============================================================
#include "BTSelector.h"

BTSelector::BTSelector() {
    name_ = "Selector";
}

BTNodeStatus BTSelector::Execute(BTBlackboard* blackboard) {
    if (children_.empty()) {
        return BTNodeStatus::Failure;
    }

    // å‰å›žRunningã ã£ãŸå ´åˆã€ãã®å­ãƒŽãƒ¼ãƒ‰ã‹ã‚‰ç¶šè¡Œ
    for (size_t i = currentChildIndex_; i < children_.size(); ++i) {
        BTNodeStatus childStatus = children_[i]->Execute(blackboard);

        if (childStatus == BTNodeStatus::Success) {
            // æˆåŠŸã—ãŸã‚‰å³åº§ã«æˆåŠŸã‚’è¿”ã™
            currentChildIndex_ = 0;
            status_ = BTNodeStatus::Success;
            return status_;
        }
        else if (childStatus == BTNodeStatus::Running) {
            // å®Ÿè¡Œä¸­ãªã‚‰ç¾åœ¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨˜æ†¶
            currentChildIndex_ = i;
            status_ = BTNodeStatus::Running;
            return status_;
        }
        // Failureã®å ´åˆã¯æ¬¡ã®å­ãƒŽãƒ¼ãƒ‰ã¸
    }

    // å…¨ã¦ã®å­ãƒŽãƒ¼ãƒ‰ãŒå¤±æ•—
    currentChildIndex_ = 0;
    status_ = BTNodeStatus::Failure;
    return status_;
}

============================================================
File Path: GameProject/BehaviorTree/Composites/BTSelector.h
============================================================
#pragma once
#include "../Core/BTComposite.h"
#include "../Core/BTBlackboard.h"

/// <summary>
/// ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ãƒŽãƒ¼ãƒ‰ï¼ˆORãƒ­ã‚¸ãƒƒã‚¯ï¼‰
/// å­ãƒŽãƒ¼ãƒ‰ã‚’é †ã«å®Ÿè¡Œã—ã€æœ€åˆã«æˆåŠŸã—ãŸã¨ã“ã‚ã§åœæ­¢
/// </summary>
class BTSelector : public BTComposite {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTSelector();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTSelector() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;
};

============================================================
File Path: GameProject/BehaviorTree/Composites/BTSequence.cpp
============================================================
#include "BTSequence.h"

BTSequence::BTSequence() {
    name_ = "Sequence";
}

BTNodeStatus BTSequence::Execute(BTBlackboard* blackboard) {
    if (children_.empty()) {
        return BTNodeStatus::Success;
    }

    // å‰å›žRunningã ã£ãŸå ´åˆã€ãã®å­ãƒŽãƒ¼ãƒ‰ã‹ã‚‰ç¶šè¡Œ
    for (size_t i = currentChildIndex_; i < children_.size(); ++i) {
        BTNodeStatus childStatus = children_[i]->Execute(blackboard);

        if (childStatus == BTNodeStatus::Failure) {
            // å¤±æ•—ã—ãŸã‚‰å³åº§ã«å¤±æ•—ã‚’è¿”ã™
            currentChildIndex_ = 0;
            status_ = BTNodeStatus::Failure;
            return status_;
        }
        else if (childStatus == BTNodeStatus::Running) {
            // å®Ÿè¡Œä¸­ãªã‚‰ç¾åœ¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨˜æ†¶
            currentChildIndex_ = i;
            status_ = BTNodeStatus::Running;
            return status_;
        }
        // Successã®å ´åˆã¯æ¬¡ã®å­ãƒŽãƒ¼ãƒ‰ã¸
    }

    // å…¨ã¦ã®å­ãƒŽãƒ¼ãƒ‰ãŒæˆåŠŸ
    currentChildIndex_ = 0;
    status_ = BTNodeStatus::Success;
    return status_;
}

============================================================
File Path: GameProject/BehaviorTree/Composites/BTSequence.h
============================================================
#pragma once
#include "../Core/BTComposite.h"
#include "../Core/BTBlackboard.h"

/// <summary>
/// ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãƒŽãƒ¼ãƒ‰ï¼ˆANDãƒ­ã‚¸ãƒƒã‚¯ï¼‰
/// å…¨ã¦ã®å­ãƒŽãƒ¼ãƒ‰ãŒæˆåŠŸã™ã‚‹ã¾ã§é †ã«å®Ÿè¡Œ
/// </summary>
class BTSequence : public BTComposite {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTSequence();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTSequence() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;
};

============================================================
File Path: GameProject/BehaviorTree/Core/BTBlackboard.h
============================================================
#pragma once
#include <unordered_map>
#include <any>
#include <string>
#include <optional>
#include "Vector3.h"

class Boss;
class Player;

/// <summary>
/// ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã®ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰
/// ãƒŽãƒ¼ãƒ‰é–“ã§ãƒ‡ãƒ¼ã‚¿ã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿
/// </summary>
class BTBlackboard {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBlackboard() = default;

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~BTBlackboard() = default;

    /// <summary>
    /// ãƒœã‚¹ã®è¨­å®š
    /// </summary>
    /// <param name="boss">ãƒœã‚¹ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetBoss(Boss* boss) { boss_ = boss; }

    /// <summary>
    /// ãƒœã‚¹ã®å–å¾—
    /// </summary>
    /// <returns>ãƒœã‚¹ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    Boss* GetBoss() const { return boss_; }

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¨­å®š
    /// </summary>
    /// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetPlayer(Player* player) { player_ = player; }

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å–å¾—
    /// </summary>
    /// <returns>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    Player* GetPlayer() const { return player_; }

    /// <summary>
    /// ãƒ•ãƒ¬ãƒ¼ãƒ ã®çµŒéŽæ™‚é–“ã‚’è¨­å®š
    /// </summary>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void SetDeltaTime(float deltaTime) { deltaTime_ = deltaTime; }

    /// <summary>
    /// ãƒ•ãƒ¬ãƒ¼ãƒ ã®çµŒéŽæ™‚é–“ã‚’å–å¾—
    /// </summary>
    /// <returns>çµŒéŽæ™‚é–“</returns>
    float GetDeltaTime() const { return deltaTime_; }

    /// <summary>
    /// æ±Žç”¨ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
    /// </summary>
    /// <template name="T">ãƒ‡ãƒ¼ã‚¿åž‹</template>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <param name="value">å€¤</param>
    template<typename T>
    void SetValue(const std::string& key, const T& value) {
        data_[key] = value;
    }

    /// <summary>
    /// æ±Žç”¨ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
    /// </summary>
    /// <template name="T">ãƒ‡ãƒ¼ã‚¿åž‹</template>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <returns>å€¤ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯nulloptï¼‰</returns>
    template<typename T>
    std::optional<T> GetValue(const std::string& key) const {
        auto it = data_.find(key);
        if (it != data_.end()) {
            try {
                return std::any_cast<T>(it->second);
            }
            catch (const std::bad_any_cast&) {
                return std::nullopt;
            }
        }
        return std::nullopt;
    }

    /// <summary>
    /// æ•´æ•°å€¤ã®è¨­å®š
    /// </summary>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <param name="value">å€¤</param>
    void SetInt(const std::string& key, int value) {
        data_[key] = value;
    }

    /// <summary>
    /// æ•´æ•°å€¤ã®å–å¾—
    /// </summary>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <param name="defaultValue">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤</param>
    /// <returns>å€¤</returns>
    int GetInt(const std::string& key, int defaultValue = 0) const {
        auto value = GetValue<int>(key);
        return value.value_or(defaultValue);
    }

    /// <summary>
    /// æµ®å‹•å°æ•°ç‚¹å€¤ã®è¨­å®š
    /// </summary>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <param name="value">å€¤</param>
    void SetFloat(const std::string& key, float value) {
        data_[key] = value;
    }

    /// <summary>
    /// æµ®å‹•å°æ•°ç‚¹å€¤ã®å–å¾—
    /// </summary>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <param name="defaultValue">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤</param>
    /// <returns>å€¤</returns>
    float GetFloat(const std::string& key, float defaultValue = 0.0f) const {
        auto value = GetValue<float>(key);
        return value.value_or(defaultValue);
    }

    /// <summary>
    /// ãƒ™ã‚¯ãƒˆãƒ«å€¤ã®è¨­å®š
    /// </summary>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <param name="value">å€¤</param>
    void SetVector3(const std::string& key, const Vector3& value) {
        data_[key] = value;
    }

    /// <summary>
    /// ãƒ™ã‚¯ãƒˆãƒ«å€¤ã®å–å¾—
    /// </summary>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <param name="defaultValue">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤</param>
    /// <returns>å€¤</returns>
    Vector3 GetVector3(const std::string& key, const Vector3& defaultValue = Vector3()) const {
        auto value = GetValue<Vector3>(key);
        return value.value_or(defaultValue);
    }

    /// <summary>
    /// ã‚­ãƒ¼ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    /// </summary>
    /// <param name="key">ã‚­ãƒ¼</param>
    /// <returns>å­˜åœ¨ã™ã‚‹å ´åˆtrue</returns>
    bool HasKey(const std::string& key) const {
        return data_.find(key) != data_.end();
    }

    /// <summary>
    /// ã‚­ãƒ¼ã®å‰Šé™¤
    /// </summary>
    /// <param name="key">ã‚­ãƒ¼</param>
    void RemoveKey(const std::string& key) {
        data_.erase(key);
    }

    /// <summary>
    /// å…¨ãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªã‚¢
    /// </summary>
    void Clear() {
        data_.clear();
    }

private:
    // ãƒœã‚¹ã®ãƒã‚¤ãƒ³ã‚¿
    Boss* boss_ = nullptr;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿
    Player* player_ = nullptr;

    // ãƒ•ãƒ¬ãƒ¼ãƒ ã®çµŒéŽæ™‚é–“
    float deltaTime_ = 0.0f;

    // æ±Žç”¨ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
    std::unordered_map<std::string, std::any> data_;
};

============================================================
File Path: GameProject/BehaviorTree/Core/BTComposite.cpp
============================================================
#include "BTComposite.h"
#include <algorithm>

void BTComposite::AddChild(BTNodePtr child) {
    if (child) {
        children_.push_back(child);
    }
}

void BTComposite::RemoveChild(BTNodePtr child) {
    children_.erase(
        std::remove(children_.begin(), children_.end(), child),
        children_.end()
    );
}

void BTComposite::ClearChildren() {
    children_.clear();
}

void BTComposite::Reset() {
    BTNode::Reset();
    currentChildIndex_ = 0;
    for (auto& child : children_) {
        child->Reset();
    }
}

============================================================
File Path: GameProject/BehaviorTree/Core/BTComposite.h
============================================================
#pragma once
#include "BTNode.h"
#include <vector>

/// <summary>
/// ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// è¤‡æ•°ã®å­ãƒŽãƒ¼ãƒ‰ã‚’æŒã¤ãƒŽãƒ¼ãƒ‰
/// </summary>
class BTComposite : public BTNode {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTComposite() = default;

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTComposite() = default;

    /// <summary>
    /// å­ãƒŽãƒ¼ãƒ‰ã®è¿½åŠ 
    /// </summary>
    /// <param name="child">è¿½åŠ ã™ã‚‹å­ãƒŽãƒ¼ãƒ‰</param>
    void AddChild(BTNodePtr child);

    /// <summary>
    /// å­ãƒŽãƒ¼ãƒ‰ã®å‰Šé™¤
    /// </summary>
    /// <param name="child">å‰Šé™¤ã™ã‚‹å­ãƒŽãƒ¼ãƒ‰</param>
    void RemoveChild(BTNodePtr child);

    /// <summary>
    /// å­ãƒŽãƒ¼ãƒ‰ã®ã‚¯ãƒªã‚¢
    /// </summary>
    void ClearChildren();

    /// <summary>
    /// å­ãƒŽãƒ¼ãƒ‰ã®å–å¾—
    /// </summary>
    /// <returns>å­ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆ</returns>
    const std::vector<BTNodePtr>& GetChildren() const { return children_; }

    /// <summary>
    /// å­ãƒŽãƒ¼ãƒ‰ã®æ•°ã‚’å–å¾—
    /// </summary>
    /// <returns>å­ãƒŽãƒ¼ãƒ‰ã®æ•°</returns>
    size_t GetChildCount() const { return children_.size(); }

    /// <summary>
    /// ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã‹ã©ã†ã‹
    /// </summary>
    /// <returns>å¸¸ã«true</returns>
    bool IsComposite() const override { return true; }

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

protected:
    // å­ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆ
    std::vector<BTNodePtr> children_;

    // ç¾åœ¨å®Ÿè¡Œä¸­ã®å­ãƒŽãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    size_t currentChildIndex_ = 0;
};

============================================================
File Path: GameProject/BehaviorTree/Core/BTNode.h
============================================================
#pragma once
#include <memory>
#include <vector>
#include <string>
#include <json.hpp>

class BTBlackboard;

/// <summary>
/// ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã®ãƒŽãƒ¼ãƒ‰çŠ¶æ…‹
/// </summary>
enum class BTNodeStatus {
    /// <summary>
    /// æˆåŠŸ
    /// </summary>
    Success,

    /// <summary>
    /// å¤±æ•—
    /// </summary>
    Failure,

    /// <summary>
    /// å®Ÿè¡Œä¸­
    /// </summary>
    Running
};

/// <summary>
/// ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ãƒŽãƒ¼ãƒ‰ã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class BTNode {
public:
    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTNode() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    virtual BTNodeStatus Execute(BTBlackboard* blackboard) = 0;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    virtual void Reset() {
        status_ = BTNodeStatus::Failure;
    }

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰åã®å–å¾—
    /// </summary>
    /// <returns>ãƒŽãƒ¼ãƒ‰å</returns>
    const std::string& GetName() const { return name_; }

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰åã®è¨­å®š
    /// </summary>
    /// <param name="name">ãƒŽãƒ¼ãƒ‰å</param>
    void SetName(const std::string& name) { name_ = name; }

    /// <summary>
    /// ç¾åœ¨ã®çŠ¶æ…‹ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®çŠ¶æ…‹</returns>
    BTNodeStatus GetStatus() const { return status_; }

    /// <summary>
    /// å®Ÿè¡Œä¸­ã‹ã©ã†ã‹
    /// </summary>
    /// <returns>å®Ÿè¡Œä¸­ã®å ´åˆtrue</returns>
    bool IsRunning() const { return status_ == BTNodeStatus::Running; }

    /// <summary>
    /// ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ï¼ˆå­ãƒŽãƒ¼ãƒ‰ã‚’æŒã¦ã‚‹ï¼‰ã‹ã©ã†ã‹
    /// </summary>
    /// <returns>ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã®å ´åˆtrue</returns>
    virtual bool IsComposite() const { return false; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    virtual void ApplyParameters(const nlohmann::json& params) {
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒãŸãªã„ãƒŽãƒ¼ãƒ‰ç”¨ï¼‰
        (void)params;
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡ºï¼ˆä¿å­˜ç”¨ï¼‰
    /// </summary>
    /// <returns>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</returns>
    virtual nlohmann::json ExtractParameters() const {
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç©ºã®JSONã‚’è¿”ã™ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒãŸãªã„ãƒŽãƒ¼ãƒ‰ç”¨ï¼‰
        return {};
    }

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    /// <returns>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´ãŒã‚ã‚Œã°true</returns>
    virtual bool DrawImGui() { return false; }
#endif

protected:
    // ç¾åœ¨ã®çŠ¶æ…‹
    BTNodeStatus status_ = BTNodeStatus::Failure;

    // ãƒŽãƒ¼ãƒ‰å
    std::string name_ = "BTNode";
};

/// <summary>
/// ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ãƒŽãƒ¼ãƒ‰ã®ã‚¹ãƒžãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿åž‹å®šç¾©
/// </summary>
using BTNodePtr = std::shared_ptr<BTNode>;

============================================================
File Path: GameProject/CameraAnimation/CameraAnimation.cpp
============================================================
#include "CameraAnimation.h"
#include "Vec3Func.h"
#include "QuatFunc.h"
#include "CameraSystem/CameraConfig.h"

#include <algorithm>
#include <fstream>
#include <filesystem>
#include <cmath>
#include <numbers>
#include <DirectXMath.h>

#ifdef _DEBUG
#include "ImGuiManager.h"
#include "DebugUIManager.h"
#endif

/// <summary>
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
/// </summary>
CameraAnimation::CameraAnimation() {
    keyframes_.reserve(CameraConfig::Animation::KEYFRAME_RESERVE_COUNT); // äºˆã‚é ˜åŸŸã‚’ç¢ºä¿

    // FOVå¾©å…ƒç”¨å¤‰æ•°ã®åˆæœŸåŒ–
    originalFov_ = kDefaultFov;
    hasOriginalFov_ = false;
}

/// <summary>
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
/// </summary>
CameraAnimation::~CameraAnimation() {
    // ç‰¹ã«å‡¦ç†ãªã—
}

/// <summary>
/// æ›´æ–°å‡¦ç†
/// </summary>
void CameraAnimation::Update(float deltaTime) {
    // ã‚«ãƒ¡ãƒ©ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (!camera_) {
        return;
    }

    // å†ç”Ÿä¸­ã§ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (playState_ != PlayState::PLAYING) {
        return;
    }

    // ãƒ–ãƒ¬ãƒ³ãƒ‰ä¸­ã®å‡¦ç†
    if (isBlending_) {
        blendProgress_ += deltaTime / blendDuration_;

        if (blendProgress_ >= 1.0f) {
            // ãƒ–ãƒ¬ãƒ³ãƒ‰å®Œäº†
            blendProgress_ = 1.0f;
            isBlending_ = false;
        }

        // æœ€åˆã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã¾ã§è£œé–“
        if (!keyframes_.empty()) {
            const CameraKeyframe& firstKf = keyframes_[0];
            float t = ApplyEasing(blendProgress_, CameraKeyframe::InterpolationType::EASE_IN_OUT);

            // ä½ç½®ã®è£œé–“ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆç›¸å¯¾ã®å ´åˆã‚‚è€ƒæ…®ï¼‰
            Vector3 targetPosition = firstKf.position;
            if (firstKf.coordinateType == CameraKeyframe::CoordinateType::TARGET_RELATIVE && targetTransform_) {
                targetPosition = Vec3::Add(targetTransform_->translate, firstKf.position);
            }
            Vector3 position = Vec3::Lerp(blendStartPosition_, targetPosition, t);

            // å›žè»¢ã®è£œé–“ï¼ˆã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã§Slerpï¼‰
            Quaternion q1 = EulerToQuaternion(blendStartRotation_);
            Quaternion q2 = EulerToQuaternion(firstKf.rotation);
            Quaternion qResult = Quat::Slerp(q1, q2, t);
            Vector3 rotation = QuaternionToEuler(qResult);

            // FOVã®è£œé–“
            float fov = Vec3::Lerp(blendStartFov_, firstKf.fov, t);

            // ã‚«ãƒ¡ãƒ©ã«é©ç”¨
            camera_->SetTranslate(position);
            camera_->SetRotate(rotation);
            camera_->SetFovY(fov);
        }

        // ãƒ–ãƒ¬ãƒ³ãƒ‰ä¸­ã¯é€šå¸¸ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
        return;
    }

    // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒ2ã¤ä»¥ä¸Šãªã„å ´åˆã¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸å¯
    if (keyframes_.size() < 2) {
        return;
    }

    // æ™‚é–“ã‚’é€²ã‚ã‚‹
    currentTime_ += deltaTime * playSpeed_;

    // ãƒ«ãƒ¼ãƒ—å‡¦ç†ã¾ãŸã¯åœæ­¢
    if (currentTime_ >= duration_) {
        if (isLooping_) {
            // ãƒ«ãƒ¼ãƒ—å†ç”Ÿ
            currentTime_ = fmodf(currentTime_, duration_);
        } else {
            // ãƒ¯ãƒ³ã‚·ãƒ§ãƒƒãƒˆå†ç”Ÿã®çµ‚äº†
            currentTime_ = duration_;
            playState_ = PlayState::STOPPED;

            // FOVã‚’å¾©å…ƒ
            if (hasOriginalFov_ && camera_) {
                camera_->SetFovY(CameraConfig::STANDARD_FOV);
                hasOriginalFov_ = false;
            }
        }
    }

    // è² ã®æ™‚é–“ã®å‡¦ç†ï¼ˆé€†å†ç”Ÿå¯¾å¿œï¼‰
    if (currentTime_ < 0.0f) {
        if (isLooping_) {
            currentTime_ = duration_ + fmodf(currentTime_, duration_);
        } else {
            currentTime_ = 0.0f;
            playState_ = PlayState::STOPPED;

            // FOVã‚’å¾©å…ƒ
            if (hasOriginalFov_ && camera_) {
                camera_->SetFovY(CameraConfig::STANDARD_FOV);
                hasOriginalFov_ = false;
            }
        }
    }

    // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®è£œé–“ã‚’å®Ÿè¡Œ
    size_t prevIndex = 0, nextIndex = 0;
    if (FindKeyframeIndices(currentTime_, prevIndex, nextIndex)) {
        const CameraKeyframe& prev = keyframes_[prevIndex];
        const CameraKeyframe& next = keyframes_[nextIndex];

        // è£œé–“ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆ0.0ï½ž1.0ï¼‰
        float timeDiff = next.time - prev.time;
        float t = 0.0f;
        if (timeDiff > 0.0f) {
            t = (currentTime_ - prev.time) / timeDiff;
            t = std::clamp(t, 0.0f, 1.0f);

            // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã‚’é©ç”¨
            t = ApplyEasing(t, prev.interpolation);
        }

        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã‚’è£œé–“ã—ã¦ã‚«ãƒ¡ãƒ©ã«é©ç”¨
        InterpolateKeyframes(prev, next, t);
    }
}

/// <summary>
/// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®è¿½åŠ 
/// </summary>
void CameraAnimation::AddKeyframe(const CameraKeyframe& keyframe) {
    keyframes_.push_back(keyframe);

    // è‡ªå‹•ã‚½ãƒ¼ãƒˆãŒæœ‰åŠ¹ãªå ´åˆ
#ifdef _DEBUG
    if (autoSortKeyframes_) {
#endif
        SortKeyframes();
#ifdef _DEBUG
    }
#endif

    UpdateDuration();
}

/// <summary>
/// ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©çŠ¶æ…‹ã‹ã‚‰ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿½åŠ 
/// </summary>
void CameraAnimation::AddKeyframeFromCurrentCamera(float time,
    CameraKeyframe::InterpolationType interpolation) {

    if (!camera_) {
        return;
    }

    CameraKeyframe keyframe;
    keyframe.time = time;
    keyframe.position = camera_->GetTranslate();
    keyframe.rotation = camera_->GetRotate();
    keyframe.fov = camera_->GetFovY();
    keyframe.interpolation = interpolation;

    AddKeyframe(keyframe);
}

/// <summary>
/// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‰Šé™¤
/// </summary>
void CameraAnimation::RemoveKeyframe(size_t index) {
    if (index >= keyframes_.size()) {
        return;
    }

    keyframes_.erase(keyframes_.begin() + index);
    UpdateDuration();
}

/// <summary>
/// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ç·¨é›†
/// </summary>
void CameraAnimation::EditKeyframe(size_t index, const CameraKeyframe& keyframe) {
    if (index >= keyframes_.size()) {
        return;
    }

    keyframes_[index] = keyframe;

#ifdef _DEBUG
    if (autoSortKeyframes_) {
#endif
        SortKeyframes();
#ifdef _DEBUG
    }
#endif

    UpdateDuration();
}

/// <summary>
/// ã™ã¹ã¦ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
/// </summary>
void CameraAnimation::ClearKeyframes() {
    keyframes_.clear();
    duration_ = 0.0f;
    currentTime_ = 0.0f;
    playState_ = PlayState::STOPPED;
}

/// <summary>
/// å†ç”Ÿé–‹å§‹
/// </summary>
void CameraAnimation::Play() {
    if (keyframes_.empty() || !camera_) {
        return; // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒä¸è¶³ã¾ãŸã¯ã‚«ãƒ¡ãƒ©æœªè¨­å®š
    }

    playState_ = PlayState::PLAYING;

    // å…ƒã®FOVã‚’ä¿å­˜
    originalFov_ = camera_->GetFovY();
    hasOriginalFov_ = true;

    // å†ç”Ÿé–‹å§‹æ™‚ã«é¸æŠžçŠ¶æ…‹ã‚’è§£é™¤ï¼ˆã‚«ãƒ¡ãƒ©ã‚’å…ƒã«æˆ»ã™ï¼‰
    ClearDeselectState();

    // é–‹å§‹ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ãŸå‡¦ç†
    if (startMode_ == StartMode::JUMP_CUT) {
        // å³åº§ã«æœ€åˆã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã«ç§»å‹•
        currentTime_ = 0.0f;
        isBlending_ = false;

        // æœ€åˆã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å³åº§ã«é©ç”¨ï¼ˆ1ã¤ã—ã‹ãªã„å ´åˆã‚‚å¯¾å¿œï¼‰
        if (!keyframes_.empty()) {
            ApplyKeyframeDirectly(keyframes_[0]);
        }
    } else {
        // SMOOTH_BLEND: ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©çŠ¶æ…‹ã‚’ä¿å­˜ã—ã¦ãƒ–ãƒ¬ãƒ³ãƒ‰é–‹å§‹
        blendStartPosition_ = camera_->GetTranslate();
        blendStartRotation_ = camera_->GetRotate();
        blendStartFov_ = camera_->GetFovY();
        blendProgress_ = 0.0f;
        isBlending_ = true;
        currentTime_ = 0.0f;
    }
}

/// <summary>
/// ä¸€æ™‚åœæ­¢
/// </summary>
void CameraAnimation::Pause() {
    if (playState_ == PlayState::PLAYING) {
        playState_ = PlayState::PAUSED;
    }
}

/// <summary>
/// åœæ­¢ï¼ˆæ™‚é–“ã‚’0ã«ãƒªã‚»ãƒƒãƒˆï¼‰
/// </summary>
void CameraAnimation::Stop() {
    playState_ = PlayState::STOPPED;
    currentTime_ = 0.0f;

    // FOVã‚’å¾©å…ƒ
    if (hasOriginalFov_ && camera_) {
        camera_->SetFovY(originalFov_);
        hasOriginalFov_ = false;
    }

    // åœæ­¢æ™‚ã«é¸æŠžçŠ¶æ…‹ã‚’è§£é™¤ï¼ˆã‚«ãƒ¡ãƒ©ã‚’å…ƒã«æˆ»ã™ï¼‰
    ClearDeselectState();
}

/// <summary>
/// FOVå¾©å…ƒãªã—ã§åœæ­¢ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ç”¨ï¼‰
/// </summary>
void CameraAnimation::StopWithoutRestore() {
    playState_ = PlayState::STOPPED;
    currentTime_ = 0.0f;

    // FOVå¾©å…ƒã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆãƒ•ãƒ©ã‚°ã®ã¿ãƒªã‚»ãƒƒãƒˆï¼‰
    hasOriginalFov_ = false;

    // åœæ­¢æ™‚ã«é¸æŠžçŠ¶æ…‹ã‚’è§£é™¤ï¼ˆã‚«ãƒ¡ãƒ©ã‚’å…ƒã«æˆ»ã™ï¼‰
    ClearDeselectState();
}

/// <summary>
/// ç¾åœ¨æ™‚åˆ»ã‚’ãƒªã‚»ãƒƒãƒˆ
/// </summary>
void CameraAnimation::Reset() {
    currentTime_ = 0.0f;
}

/// <summary>
/// ç¾åœ¨æ™‚åˆ»ã®è¨­å®šï¼ˆã‚·ãƒ¼ã‚¯ï¼‰
/// </summary>
void CameraAnimation::SetCurrentTime(float time) {
    currentTime_ = std::clamp(time, 0.0f, duration_);

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼/ã‚¹ã‚¯ãƒ©ãƒ–æ™‚ã‚‚è£œé–“ã‚’å®Ÿè¡Œï¼ˆå†ç”ŸçŠ¶æ…‹ã«é–¢ä¿‚ãªãï¼‰
    if (!camera_ || keyframes_.size() < 2) {
        return;
    }

    // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®è£œé–“ã‚’å®Ÿè¡Œ
    size_t prevIndex = 0, nextIndex = 0;
    if (FindKeyframeIndices(currentTime_, prevIndex, nextIndex)) {
        const CameraKeyframe& prev = keyframes_[prevIndex];
        const CameraKeyframe& next = keyframes_[nextIndex];

        // è£œé–“ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆ0.0ï½ž1.0ï¼‰
        float timeDiff = next.time - prev.time;
        float t = 0.0f;
        if (timeDiff > 0.0f) {
            t = (currentTime_ - prev.time) / timeDiff;
            t = std::clamp(t, 0.0f, 1.0f);

            // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã‚’é©ç”¨
            t = ApplyEasing(t, prev.interpolation);
        }

        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã‚’è£œé–“ã—ã¦ã‚«ãƒ¡ãƒ©ã«é©ç”¨
        InterpolateKeyframes(prev, next, t);
    }
}

/// <summary>
/// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ™‚é–“ã§ã‚½ãƒ¼ãƒˆ
/// </summary>
void CameraAnimation::SortKeyframes() {
    std::sort(keyframes_.begin(), keyframes_.end(),
        [](const CameraKeyframe& a, const CameraKeyframe& b) {
            return a.time < b.time;
        });
}

/// <summary>
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ç·æ™‚é–“ã‚’æ›´æ–°
/// </summary>
void CameraAnimation::UpdateDuration() {
    if (keyframes_.empty()) {
        duration_ = 0.0f;
        return;
    }

    // æœ€å¾Œã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚åˆ»ãŒç·æ™‚é–“
    duration_ = keyframes_.back().time;
}

/// <summary>
/// ç¾åœ¨æ™‚åˆ»ã«å¯¾å¿œã™ã‚‹2ã¤ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ¤œç´¢
/// </summary>
bool CameraAnimation::FindKeyframeIndices(float time, size_t& prevIndex, size_t& nextIndex) const {
    if (keyframes_.size() < 2) {
        return false;
    }

    // æ™‚åˆ»ä»¥ä¸‹ã®æœ€å¤§ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æŽ¢ã™
    prevIndex = 0;
    for (size_t i = 0; i < keyframes_.size(); ++i) {
        if (keyframes_[i].time <= time) {
            prevIndex = i;
        } else {
            break;
        }
    }

    // æ¬¡ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¨­å®š
    nextIndex = prevIndex + 1;
    if (nextIndex >= keyframes_.size()) {
        // æœ€å¾Œã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¶…ãˆãŸå ´åˆ
        if (isLooping_ && keyframes_.size() > 1) {
            // ãƒ«ãƒ¼ãƒ—æ™‚ã¯æœ€åˆã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã«æˆ»ã‚‹
            nextIndex = 0;
        } else {
            // ãƒ«ãƒ¼ãƒ—ã—ãªã„å ´åˆã¯æœ€å¾Œã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç¶­æŒ
            nextIndex = prevIndex;
        }
    }

    return true;
}

/// <summary>
/// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®è£œé–“
/// </summary>
void CameraAnimation::InterpolateKeyframes(const CameraKeyframe& prev, const CameraKeyframe& next, float t) {
    if (!camera_) {
        return;
    }

    // ä½ç½®ã®è£œé–“
    Vector3 position = Vec3::Lerp(prev.position, next.position, t);

    // åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—ã‚’è€ƒæ…®ï¼ˆä¸¡æ–¹ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒåŒã˜åº§æ¨™ç³»ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰
    // ç•°ãªã‚‹å ´åˆã¯å‰ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®åº§æ¨™ç³»ã‚’å„ªå…ˆ
    CameraKeyframe::CoordinateType coordinateType = prev.coordinateType;

    // TARGET_RELATIVEãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’åŠ ç®—
    if (coordinateType == CameraKeyframe::CoordinateType::TARGET_RELATIVE && targetTransform_) {
        // positionã¯ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ã—ã¦æ‰±ã†
        position = Vec3::Add(targetTransform_->translate, position);
    }
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã¨ã—ã¦æ‰±ã†

    // å›žè»¢ã®è£œé–“ï¼ˆã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã§Slerpï¼‰
    Quaternion q1 = EulerToQuaternion(prev.rotation);
    Quaternion q2 = EulerToQuaternion(next.rotation);
    Quaternion qResult = Quat::Slerp(q1, q2, t);
    Vector3 rotation = QuaternionToEuler(qResult);

    // FOVã®è£œé–“ï¼ˆç·šå½¢è£œé–“ï¼‰
    float fov = Vec3::Lerp(prev.fov, next.fov, t);

    // ã‚«ãƒ¡ãƒ©ã«é©ç”¨
    camera_->SetTranslate(position);
    camera_->SetRotate(rotation);
    camera_->SetFovY(fov);
}

/// <summary>
/// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã®é©ç”¨
/// </summary>
float CameraAnimation::ApplyEasing(float t, CameraKeyframe::InterpolationType type) const {
    switch (type) {
        case CameraKeyframe::InterpolationType::LINEAR:
            return t;

        case CameraKeyframe::InterpolationType::EASE_IN:
            // äºŒæ¬¡é–¢æ•°ã§ã‚†ã£ãã‚Šé–‹å§‹
            return t * t;

        case CameraKeyframe::InterpolationType::EASE_OUT:
            // äºŒæ¬¡é–¢æ•°ã§ã‚†ã£ãã‚Šçµ‚äº†
            return 1.0f - (1.0f - t) * (1.0f - t);

        case CameraKeyframe::InterpolationType::EASE_IN_OUT:
            // ä¸¡ç«¯ã§ã‚†ã£ãã‚Šï¼ˆä¸‰æ¬¡é–¢æ•°ï¼‰
            if (t < 0.5f) {
                return 2.0f * t * t;
            } else {
                return 1.0f - 2.0f * (1.0f - t) * (1.0f - t);
            }

        case CameraKeyframe::InterpolationType::CUBIC_BEZIER:
            // TODO: ã‚«ã‚¹ã‚¿ãƒ ãƒ™ã‚¸ã‚§ã‚«ãƒ¼ãƒ–ã®å®Ÿè£…
            // ç¾åœ¨ã¯ç·šå½¢è£œé–“ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return t;

        default:
            return t;
    }
}

/// <summary>
/// ã‚ªã‚¤ãƒ©ãƒ¼è§’ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã«å¤‰æ›
/// </summary>
Quaternion CameraAnimation::EulerToQuaternion(const Vector3& euler) const {
    // å„è»¸å‘¨ã‚Šã®å›žè»¢ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã§ä½œæˆ
    Quaternion qx = Quat::MakeRotateAxisAngle(Vector3(1.0f, 0.0f, 0.0f), euler.x);
    Quaternion qy = Quat::MakeRotateAxisAngle(Vector3(0.0f, 1.0f, 0.0f), euler.y);
    Quaternion qz = Quat::MakeRotateAxisAngle(Vector3(0.0f, 0.0f, 1.0f), euler.z);

    // å›žè»¢é †åº: Y * X * Z
    Quaternion result = Quat::Multiply(qy, qx);
    result = Quat::Multiply(result, qz);

    return result;
}

/// <summary>
/// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’ã‚ªã‚¤ãƒ©ãƒ¼è§’ã«å¤‰æ›
/// </summary>
Vector3 CameraAnimation::QuaternionToEuler(const Quaternion& q) const {
    Vector3 euler;

    // ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‹ã‚‰å›žè»¢è¡Œåˆ—ã®è¦ç´ ã‚’è¨ˆç®—
    float sinr_cosp = 2.0f * (q.w * q.x + q.y * q.z);
    float cosr_cosp = 1.0f - 2.0f * (q.x * q.x + q.y * q.y);
    euler.x = std::atan2f(sinr_cosp, cosr_cosp);

    // Pitch (Yè»¸å›žè»¢)
    float sinp = 2.0f * (q.w * q.y - q.z * q.x);
    if (std::abs(sinp) >= 1.0f) {
        euler.y = std::copysignf(std::numbers::pi_v<float> / 2.0f, sinp); // ã‚¸ãƒ³ãƒãƒ«ãƒ­ãƒƒã‚¯æ™‚
    } else {
        euler.y = std::asinf(sinp);
    }

    // Yaw (Zè»¸å›žè»¢)
    float siny_cosp = 2.0f * (q.w * q.z + q.x * q.y);
    float cosy_cosp = 1.0f - 2.0f * (q.y * q.y + q.z * q.z);
    euler.z = std::atan2f(siny_cosp, cosy_cosp);

    return euler;
}

/// <summary>
/// ç¾åœ¨ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç·¨é›†ä¸­ã‹åˆ¤å®š
/// </summary>
bool CameraAnimation::IsEditingKeyframe() const {
#ifdef _DEBUG
    return selectedKeyframeIndex_ >= 0 && selectedKeyframeIndex_ < static_cast<int>(keyframes_.size());
#else
    return false;
#endif
}

/// <summary>
/// é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
/// </summary>
int CameraAnimation::GetSelectedKeyframeIndex() const {
#ifdef _DEBUG
    return selectedKeyframeIndex_;
#else
    return -1;
#endif
}

/// <summary>
/// æŒ‡å®šã—ãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚«ãƒ¡ãƒ©ã«é©ç”¨
/// </summary>
void CameraAnimation::ApplyKeyframeToCamera(int index) {
    if (!camera_) {
        return;
    }

#ifdef _DEBUG
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½¿ç”¨
    if (index < 0) {
        index = selectedKeyframeIndex_;
    }

    // ç·¨é›†ä¸­ã®å ´åˆã¯ç·¨é›†ä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆtempKeyframe_ï¼‰ã‚’ä½¿ç”¨
    if (index == selectedKeyframeIndex_ && index >= 0) {
        camera_->SetTranslate(tempKeyframe_.position);
        camera_->SetRotate(tempKeyframe_.rotation);
        camera_->SetFovY(tempKeyframe_.fov);
        return;
    }
#endif

    // æœ‰åŠ¹ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ãƒã‚§ãƒƒã‚¯
    if (index >= 0 && index < static_cast<int>(keyframes_.size())) {
        const CameraKeyframe& keyframe = keyframes_[index];
        camera_->SetTranslate(keyframe.position);
        camera_->SetRotate(keyframe.rotation);
        camera_->SetFovY(keyframe.fov);
    }
}

/// <summary>
/// é¸æŠžè§£é™¤æ™‚ã®å‡¦ç†ï¼ˆã‚«ãƒ¡ãƒ©ã‚’å…ƒã®å€¤ã«æˆ»ã™ï¼‰
/// </summary>
void CameraAnimation::ClearDeselectState() {
#ifdef _DEBUG
    if (selectedKeyframeIndex_ >= 0 && selectedKeyframeIndex_ < static_cast<int>(keyframes_.size())) {
        // å…ƒã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®å€¤ã«æˆ»ã™
        const CameraKeyframe& original = keyframes_[selectedKeyframeIndex_];
        if (camera_) {
            camera_->SetTranslate(original.position);
            camera_->SetRotate(original.rotation);
            camera_->SetFovY(original.fov);
        }
    }
    selectedKeyframeIndex_ = -1;
#endif
}

/// <summary>
/// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚«ãƒ¡ãƒ©ã«ç›´æŽ¥é©ç”¨ï¼ˆå†…éƒ¨ç”¨ï¼‰
/// </summary>
void CameraAnimation::ApplyKeyframeDirectly(const CameraKeyframe& kf) {
    if (!camera_) {
        return;
    }

    // åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ä½ç½®ã‚’è¨­å®š
    Vector3 position = kf.position;
    if (kf.coordinateType == CameraKeyframe::CoordinateType::TARGET_RELATIVE && targetTransform_) {
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç›¸å¯¾åº§æ¨™ã®å ´åˆã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’åŠ ç®—
        position = Vec3::Add(targetTransform_->translate, kf.position);
    }

    // ã‚«ãƒ¡ãƒ©ã«é©ç”¨
    camera_->SetTranslate(position);
    camera_->SetRotate(kf.rotation);
    camera_->SetFovY(kf.fov);
}

/// <summary>
/// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
/// </summary>
bool CameraAnimation::LoadFromJson(const std::string& filepath) {
    try {
        // JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ§‹ç¯‰
        std::filesystem::path jsonPath = "resources/Json/CameraAnimations/" + filepath;
        if (!jsonPath.has_extension()) {
            jsonPath += ".json";
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
        std::ifstream file(jsonPath);
        if (!file.is_open()) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸ
            return false;
        }

        // JSONãƒ‘ãƒ¼ã‚¹
        nlohmann::json json;
        file >> json;
        file.close();

        // ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        animationName_ = json.value("animation_name", "Untitled");
        isLooping_ = json.value("loop", false);
        playSpeed_ = json.value("play_speed", 1.0f);

        // é–‹å§‹ãƒ¢ãƒ¼ãƒ‰è¨­å®šã‚’èª­ã¿è¾¼ã¿ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®šï¼‰
        int startModeInt = json.value("start_mode", static_cast<int>(StartMode::JUMP_CUT));
        startMode_ = static_cast<StartMode>(startModeInt);
        blendDuration_ = json.value("blend_duration", 0.5f);

        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
        keyframes_.clear();

        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é…åˆ—ã‚’èª­ã¿è¾¼ã¿
        if (json.contains("keyframes")) {
            for (const auto& kf : json["keyframes"]) {
                CameraKeyframe keyframe = kf.get<CameraKeyframe>();
                keyframes_.push_back(keyframe);
            }
        }

        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚½ãƒ¼ãƒˆã—ã¦ç·æ™‚é–“ã‚’æ›´æ–°
        SortKeyframes();
        UpdateDuration();

#ifdef _DEBUG
        DebugUIManager::GetInstance()->AddLog(
            " CameraAnimation: Loaded animation" + animationName_ + " from " + jsonPath.string(),
            DebugUIManager::LogType::Info);
#endif

        // èª­ã¿è¾¼ã¿æˆåŠŸ
        return true;

    } catch (const std::exception& e) {
        // ã‚¨ãƒ©ãƒ¼å‡¦ç†
        (void)e; // è­¦å‘Šå›žé¿
        return false;
    }
}

/// <summary>
/// JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
/// </summary>
bool CameraAnimation::SaveToJson(const std::string& filepath) const {
    try {
        // ä¿å­˜ç”¨JSONä½œæˆ
        nlohmann::json json;
        json["animation_name"] = animationName_;
        json["duration"] = duration_;
        json["loop"] = isLooping_;
        json["play_speed"] = playSpeed_;

        // é–‹å§‹ãƒ¢ãƒ¼ãƒ‰è¨­å®šã‚’ä¿å­˜
        json["start_mode"] = static_cast<int>(startMode_);
        json["blend_duration"] = blendDuration_;

        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é…åˆ—ã‚’ä¿å­˜
        json["keyframes"] = nlohmann::json::array();
        for (const auto& kf : keyframes_) {
            json["keyframes"].push_back(kf);
        }

        // ä¿å­˜å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ç¢ºèªãƒ»ä½œæˆ
        std::filesystem::path dirPath = "resources/Json/CameraAnimations";
        if (!std::filesystem::exists(dirPath)) {
            std::filesystem::create_directories(dirPath);
        }

        // JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ§‹ç¯‰
        std::filesystem::path jsonPath = dirPath / filepath;
        if (!jsonPath.has_extension()) {
            jsonPath += ".json";
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
        std::ofstream file(jsonPath);
        if (!file.is_open()) {
            return false;
        }

        // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆä»˜ãã§æ›¸ãè¾¼ã¿
        file << json.dump(4);
        file.close();

#ifdef _DEBUG
        // Debugãƒ­ã‚°å‡ºåŠ›
        DebugUIManager::GetInstance()->AddLog(
            " CameraAnimation: Saved animation " + animationName_ + " to " + jsonPath.string(),
            DebugUIManager::LogType::Info);
#endif

        // ä¿å­˜æˆåŠŸ
        return true;

    } catch (const std::exception& e) {
        // ã‚¨ãƒ©ãƒ¼å‡¦ç†
        (void)e; // è­¦å‘Šå›žé¿
        return false;
    }
}

#ifdef _DEBUG
/// <summary>
/// ImGuiã§ã®ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º
/// </summary>
void CameraAnimation::DrawImGui() {
  ImGui::Separator();

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±
    ImGui::Text("Animation: %s", animationName_.c_str());
    ImGui::Text("Duration: %.2f seconds", duration_);
    ImGui::Text("Current Time: %.2f", currentTime_);
    ImGui::Text("Keyframes: %zu", keyframes_.size());

    ImGui::Separator();

    // å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    ImGui::Text("Playback Controls");

    // å†ç”ŸçŠ¶æ…‹ã®è¡¨ç¤º
    const char* stateStr = "STOPPED";
    if (playState_ == PlayState::PLAYING) stateStr = "PLAYING";
    else if (playState_ == PlayState::PAUSED) stateStr = "PAUSED";
    ImGui::Text("State: %s", stateStr);

    // ãƒœã‚¿ãƒ³
    if (ImGui::Button("Play")) {
        Play();
    }
    ImGui::SameLine();
    if (ImGui::Button("Pause")) {
        Pause();
    }
    ImGui::SameLine();
    if (ImGui::Button("Stop")) {
        Stop();
    }
    ImGui::SameLine();
    if (ImGui::Button("Reset")) {
        Reset();
    }

    // å†ç”Ÿè¨­å®š
    ImGui::Checkbox("Loop", &isLooping_);
    ImGui::SliderFloat("Play Speed", &playSpeed_, -2.0f, 2.0f, "%.2f");

    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
    float tempTime = currentTime_;
    if (ImGui::SliderFloat("Timeline", &tempTime, 0.0f, duration_, "%.2f")) {
        //SetCurrentTime(tempTime);
    }

    ImGui::Separator();

    // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†
    if (ImGui::CollapsingHeader("Keyframe Management")) {
        // Escã‚­ãƒ¼ã§é¸æŠžè§£é™¤
        if (ImGui::IsKeyPressed(ImGuiKey_Escape)) {
            ClearDeselectState();
        }

        // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©çŠ¶æ…‹ã‚’è¿½åŠ 
        if (camera_) {
            if (ImGui::Button("Add Keyframe from Current Camera")) {
                AddKeyframeFromCurrentCamera(currentTime_);
            }

            // æ‰‹å‹•ã§ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ 
            static float newKeyTime = 0.0f;
            static int interpType = 0;
            static int coordType = 0;
            ImGui::DragFloat("New Keyframe Time", &newKeyTime, 0.1f, 0.0f, FLT_MAX);
            ImGui::Combo("Interpolation", &interpType,
                "LINEAR\0EASE_IN\0EASE_OUT\0EASE_IN_OUT\0");
            ImGui::Combo("Coordinate Type", &coordType,
                "WORLD\0TARGET_RELATIVE\0");

            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®šçŠ¶æ…‹ã®è¡¨ç¤º
            if (targetTransform_) {
                ImGui::TextColored(ImVec4(0.2f, 0.8f, 0.2f, 1.0f), "Target: Set");
                if (coordType == 1) { // TARGET_RELATIVE
                    ImGui::TextColored(ImVec4(0.8f, 0.8f, 0.2f, 1.0f),
                        "Position will be offset from target");
                }
            } else {
                ImGui::TextColored(ImVec4(0.8f, 0.2f, 0.2f, 1.0f), "Target: Not Set");
                if (coordType == 1) { // TARGET_RELATIVE
                    ImGui::TextColored(ImVec4(0.8f, 0.8f, 0.2f, 1.0f),
                        "Warning: Target not set, will use world coordinates");
                }
            }

            if (ImGui::Button("Add Custom Keyframe")) {
                CameraKeyframe kf;
                kf.time = newKeyTime;
                // TARGET_RELATIVEãƒ¢ãƒ¼ãƒ‰ã‹ã¤ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ç¾åœ¨ä½ç½®ã‹ã‚‰ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
                if (coordType == 1 && targetTransform_) {
                    kf.position = Vec3::Subtract(camera_->GetTranslate(), targetTransform_->translate);
                } else {
                    kf.position = camera_->GetTranslate();
                }
                kf.rotation = camera_->GetRotate();
                kf.fov = camera_->GetFovY();
                kf.interpolation = static_cast<CameraKeyframe::InterpolationType>(interpType);
                kf.coordinateType = static_cast<CameraKeyframe::CoordinateType>(coordType);
                AddKeyframe(kf);
            }
        }

        ImGui::Checkbox("Auto Sort Keyframes", &autoSortKeyframes_);

        if (ImGui::Button("Sort Keyframes")) {
            SortKeyframes();
        }
        ImGui::SameLine();
        if (ImGui::Button("Clear All Keyframes")) {
            ClearKeyframes();
        }

        ImGui::Separator();

        // é¸æŠžä¸­ã®è¡¨ç¤ºã¨è§£é™¤ãƒœã‚¿ãƒ³
        if (selectedKeyframeIndex_ >= 0) {
            ImGui::Text("Selected: Keyframe %d", selectedKeyframeIndex_);
            ImGui::SameLine();
            if (ImGui::Button("Deselect")) {
                ClearDeselectState();
            }
            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Press ESC to deselect");
        } else {
            ImGui::Text("No keyframe selected");
        }

        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒªã‚¹ãƒˆ
        if (ImGui::BeginChild("Keyframe List", ImVec2(0, 200), true)) {
            for (size_t i = 0; i < keyframes_.size(); ++i) {
                ImGui::PushID(static_cast<int>(i));

                bool isSelected = (selectedKeyframeIndex_ == static_cast<int>(i));
                char label[64];
                const char* coordTypeStr = (keyframes_[i].coordinateType == CameraKeyframe::CoordinateType::TARGET_RELATIVE)
                    ? "[REL]" : "[WLD]";
                snprintf(label, sizeof(label), "%s KF %zu: %.2fs", coordTypeStr, i, keyframes_[i].time);

                // Selectableã®ã‚µã‚¤ã‚ºã‚’åˆ¶é™ã—ã¦å‰Šé™¤ãƒœã‚¿ãƒ³ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç¢ºä¿
                float availWidth = ImGui::GetContentRegionAvail().x;
                if (ImGui::Selectable(label, isSelected, 0, ImVec2(availWidth - 30, 0))) {
                    selectedKeyframeIndex_ = static_cast<int>(i);
                    tempKeyframe_ = keyframes_[i];
                    // é¸æŠžã—ãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å³åº§ã«ã‚«ãƒ¡ãƒ©ã«é©ç”¨
                    ApplyKeyframeToCamera(selectedKeyframeIndex_);
                }

                // å‰Šé™¤ãƒœã‚¿ãƒ³
                ImGui::SameLine();
                if (ImGui::SmallButton("X")) {
                    ImGui::PopID();  // breakã™ã‚‹å‰ã«PopIDã‚’å‘¼ã¶
                    RemoveKeyframe(i);
                    if (selectedKeyframeIndex_ == static_cast<int>(i)) {
                        selectedKeyframeIndex_ = -1;
                    } else if (selectedKeyframeIndex_ > static_cast<int>(i)) {
                        selectedKeyframeIndex_--;
                    }
                    break; // ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ï¼ˆå‰Šé™¤å¾Œã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãšã‚Œã‚’é˜²ãï¼‰
                }

                ImGui::PopID();
            }
        }
        ImGui::EndChild();

        // é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç·¨é›†
        if (selectedKeyframeIndex_ >= 0 && selectedKeyframeIndex_ < static_cast<int>(keyframes_.size())) {
            ImGui::Separator();
            ImGui::Text("Edit Keyframe %d", selectedKeyframeIndex_);

            // æ™‚é–“
            if (ImGui::DragFloat("Time", &tempKeyframe_.time, 0.1f, 0.0f, duration_)) {
                ApplyKeyframeToCamera(selectedKeyframeIndex_);
            }

            // ä½ç½®
            if (ImGui::DragFloat3("Position", &tempKeyframe_.position.x, 0.1f)) {
                ApplyKeyframeToCamera(selectedKeyframeIndex_);
            }

            // å›žè»¢ï¼ˆåº¦å˜ä½ã§è¡¨ç¤ºï¼‰
            Vector3 rotationDegrees = {
                DirectX::XMConvertToDegrees(tempKeyframe_.rotation.x),
                DirectX::XMConvertToDegrees(tempKeyframe_.rotation.y),
                DirectX::XMConvertToDegrees(tempKeyframe_.rotation.z)
            };
            if (ImGui::DragFloat3("Rotation (deg)", &rotationDegrees.x, 1.0f)) {
                tempKeyframe_.rotation = {
                    DirectX::XMConvertToRadians(rotationDegrees.x),
                    DirectX::XMConvertToRadians(rotationDegrees.y),
                    DirectX::XMConvertToRadians(rotationDegrees.z)
                };
                ApplyKeyframeToCamera(selectedKeyframeIndex_);
            }

            // FOVï¼ˆåº¦å˜ä½ã§è¡¨ç¤ºï¼‰
            float fovDegrees = DirectX::XMConvertToDegrees(tempKeyframe_.fov);
            if (ImGui::DragFloat("FOV (deg)", &fovDegrees, 0.5f, 10.0f, 120.0f)) {
                tempKeyframe_.fov = DirectX::XMConvertToRadians(fovDegrees);
                ApplyKeyframeToCamera(selectedKeyframeIndex_);
            }

            // åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—
            int coordType = static_cast<int>(tempKeyframe_.coordinateType);
            if (ImGui::Combo("Coordinate Type", &coordType,
                "WORLD\0TARGET_RELATIVE\0")) {
                tempKeyframe_.coordinateType = static_cast<CameraKeyframe::CoordinateType>(coordType);
                ApplyKeyframeToCamera(selectedKeyframeIndex_);
            }

            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç›¸å¯¾ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã®èª¬æ˜Ž
            if (tempKeyframe_.coordinateType == CameraKeyframe::CoordinateType::TARGET_RELATIVE) {
                ImGui::TextWrapped("Position is relative offset from target");
                if (!targetTransform_) {
                    ImGui::TextColored(ImVec4(0.8f, 0.2f, 0.2f, 1.0f),
                        "Warning: No target set, will use world coordinates");
                }
            }

            int interpType = static_cast<int>(tempKeyframe_.interpolation);
            if (ImGui::Combo("Interpolation Type", &interpType,
                "LINEAR\0EASE_IN\0EASE_OUT\0EASE_IN_OUT\0")) {
                tempKeyframe_.interpolation = static_cast<CameraKeyframe::InterpolationType>(interpType);
            }

            if (ImGui::Button("Apply Changes")) {
                EditKeyframe(selectedKeyframeIndex_, tempKeyframe_);
                ApplyKeyframeToCamera(selectedKeyframeIndex_);
            }
            ImGui::SameLine();
            if (ImGui::Button("Cancel")) {
                tempKeyframe_ = keyframes_[selectedKeyframeIndex_];
                ApplyKeyframeToCamera(selectedKeyframeIndex_);
            }
        }
    }

    ImGui::Separator();

    // ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
    if (ImGui::CollapsingHeader("File Operations")) {
        static char filename[128] = "";
        ImGui::InputText("Filename", filename, sizeof(filename));

        if (ImGui::Button("Save to JSON")) {
            if (strlen(filename) > 0) {
                if (SaveToJson(filename)) {
                    ImGui::Text("Saved successfully!");
                } else {
                    ImGui::Text("Save failed!");
                }
            }
        }
        ImGui::SameLine();
        if (ImGui::Button("Load from JSON")) {
            if (strlen(filename) > 0) {
                if (LoadFromJson(filename)) {
                    ImGui::Text("Loaded successfully!");
                } else {
                    ImGui::Text("Load failed!");
                }
            }
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åã®ç·¨é›†
        static char animName[128] = "";
        if (ImGui::InputText("Animation Name", animName, sizeof(animName),
            ImGuiInputTextFlags_EnterReturnsTrue)) {
            animationName_ = animName;
        }
    }
}
#endif

============================================================
File Path: GameProject/CameraAnimation/CameraAnimation.h
============================================================
#pragma once
#include "CameraKeyframe.h"
#include "Camera.h"
#include "Quaternion.h"
#include "Transform.h"
#include <vector>
#include <string>
#include <memory>

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹
/// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®è£œé–“ã«ã‚ˆã£ã¦æ»‘ã‚‰ã‹ãªã‚«ãƒ¡ãƒ©å‹•ä½œã‚’å®Ÿç¾
/// </summary>
class CameraAnimation {
    // å®šæ•°
private:
    static constexpr float kDefaultFov = 45.0f;    ///< ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆFOVå€¤

public:
    /// <summary>
    /// å†ç”ŸçŠ¶æ…‹
    /// </summary>
    enum class PlayState {
        STOPPED,    ///< åœæ­¢ä¸­
        PLAYING,    ///< å†ç”Ÿä¸­
        PAUSED      ///< ä¸€æ™‚åœæ­¢ä¸­
    };

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ãƒ¢ãƒ¼ãƒ‰
    /// </summary>
    enum class StartMode {
        JUMP_CUT,        ///< å³åº§ã«æœ€åˆã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã‚¸ãƒ£ãƒ³ãƒ—
        SMOOTH_BLEND     ///< ç¾åœ¨ä½ç½®ã‹ã‚‰æœ€åˆã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã¾ã§è£œé–“
    };

    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    CameraAnimation();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~CameraAnimation();

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã®ã‚»ãƒƒãƒˆ
    /// </summary>
    /// <param name="camera">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨ã™ã‚‹ã‚«ãƒ¡ãƒ©</param>
    void SetCamera(Camera* camera) { camera_ = camera; }

    /// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ã‚»ãƒƒãƒˆ
    /// </summary>
    /// <param name="target">ç›¸å¯¾åº§æ¨™ã®åŸºæº–ã¨ãªã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆnullptrã§è§£é™¤ï¼‰</param>
    void SetTarget(const Transform* target) { targetTransform_ = target; }

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“ï¼ˆç§’ï¼‰</param>
    void Update(float deltaTime);

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®è¿½åŠ 
    /// </summary>
    /// <param name="keyframe">è¿½åŠ ã™ã‚‹ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ </param>
    void AddKeyframe(const CameraKeyframe& keyframe);

    /// <summary>
    /// ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©çŠ¶æ…‹ã‹ã‚‰ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿½åŠ 
    /// </summary>
    /// <param name="time">ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚åˆ»</param>
    /// <param name="interpolation">è£œé–“ã‚¿ã‚¤ãƒ—</param>
    void AddKeyframeFromCurrentCamera(float time,
        CameraKeyframe::InterpolationType interpolation = CameraKeyframe::InterpolationType::LINEAR);

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‰Šé™¤
    /// </summary>
    /// <param name="index">å‰Šé™¤ã™ã‚‹ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    void RemoveKeyframe(size_t index);

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ç·¨é›†
    /// </summary>
    /// <param name="index">ç·¨é›†ã™ã‚‹ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    /// <param name="keyframe">æ–°ã—ã„ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿</param>
    void EditKeyframe(size_t index, const CameraKeyframe& keyframe);

    /// <summary>
    /// ã™ã¹ã¦ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
    /// </summary>
    void ClearKeyframes();

    /// <summary>
    /// å†ç”Ÿé–‹å§‹
    /// </summary>
    void Play();

    /// <summary>
    /// ä¸€æ™‚åœæ­¢
    /// </summary>
    void Pause();

    /// <summary>
    /// åœæ­¢ï¼ˆæ™‚é–“ã‚’0ã«ãƒªã‚»ãƒƒãƒˆï¼‰
    /// </summary>
    void Stop();

    /// <summary>
    /// FOVå¾©å…ƒãªã—ã§åœæ­¢ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ç”¨ï¼‰
    /// </summary>
    void StopWithoutRestore();

    /// <summary>
    /// ç¾åœ¨æ™‚åˆ»ã‚’ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset();

    /// <summary>
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
    /// </summary>
    /// <param name="filepath">JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    bool LoadFromJson(const std::string& filepath);

    /// <summary>
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    /// </summary>
    /// <param name="filepath">ä¿å­˜å…ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    bool SaveToJson(const std::string& filepath) const;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ã®ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º
    /// </summary>
    void DrawImGui();
#endif

    //-----------------------------------------Getter-----------------------------------------//

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] size_t GetKeyframeCount() const { return keyframes_.size(); }

    /// <summary>
    /// æŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] const CameraKeyframe& GetKeyframe(size_t index) const { return keyframes_[index]; }

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ç·æ™‚é–“ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] float GetDuration() const { return duration_; }

    /// <summary>
    /// ç¾åœ¨ã®å†ç”Ÿæ™‚é–“ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] float GetPlaybackTime() const { return currentTime_; }

    /// <summary>
    /// å†ç”ŸçŠ¶æ…‹ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] PlayState GetPlayState() const { return playState_; }

    /// <summary>
    /// ãƒ«ãƒ¼ãƒ—è¨­å®šã‚’å–å¾—
    /// </summary>
    [[nodiscard]] bool IsLooping() const { return isLooping_; }

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åã‚’å–å¾—
    /// </summary>
    [[nodiscard]] const std::string& GetAnimationName() const { return animationName_; }

    /// <summary>
    /// ç¾åœ¨ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç·¨é›†ä¸­ã‹åˆ¤å®š
    /// </summary>
    [[nodiscard]] bool IsEditingKeyframe() const;

    /// <summary>
    /// é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] int GetSelectedKeyframeIndex() const;

    /// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] const Transform* GetTarget() const { return targetTransform_; }

    /// <summary>
    /// é–‹å§‹ãƒ¢ãƒ¼ãƒ‰ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] StartMode GetStartMode() const { return startMode_; }

    /// <summary>
    /// ãƒ–ãƒ¬ãƒ³ãƒ‰æ™‚é–“ã‚’å–å¾—
    /// </summary>
    [[nodiscard]] float GetBlendDuration() const { return blendDuration_; }

    /// <summary>
    /// ãƒ–ãƒ¬ãƒ³ãƒ‰ä¸­ã‹ã‚’åˆ¤å®š
    /// </summary>
    [[nodiscard]] bool IsBlending() const { return isBlending_; }

    /// <summary>
    /// ãƒ–ãƒ¬ãƒ³ãƒ‰é€²è¡Œåº¦ã‚’å–å¾—ï¼ˆ0.0ï½ž1.0ï¼‰
    /// </summary>
    [[nodiscard]] float GetBlendProgress() const { return blendProgress_; }

    //-----------------------------------------Setter-----------------------------------------//

    /// <summary>
    /// ãƒ«ãƒ¼ãƒ—è¨­å®š
    /// </summary>
    void SetLooping(bool loop) { isLooping_ = loop; }

    /// <summary>
    /// å†ç”Ÿé€Ÿåº¦ã®è¨­å®š
    /// </summary>
    void SetPlaySpeed(float speed) { playSpeed_ = speed; }

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åã®è¨­å®š
    /// </summary>
    void SetAnimationName(const std::string& name) { animationName_ = name; }

    /// <summary>
    /// ç¾åœ¨æ™‚åˆ»ã®è¨­å®šï¼ˆã‚·ãƒ¼ã‚¯ï¼‰
    /// </summary>
    void SetCurrentTime(float time);

    /// <summary>
    /// æŒ‡å®šã—ãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚«ãƒ¡ãƒ©ã«é©ç”¨
    /// </summary>
    /// <param name="index">é©ç”¨ã™ã‚‹ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆçœç•¥æ™‚ã¯é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰</param>
    void ApplyKeyframeToCamera(int index = -1);

    /// <summary>
    /// é–‹å§‹ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
    /// </summary>
    /// <param name="mode">é–‹å§‹ãƒ¢ãƒ¼ãƒ‰</param>
    void SetStartMode(StartMode mode) { startMode_ = mode; }

    /// <summary>
    /// ãƒ–ãƒ¬ãƒ³ãƒ‰æ™‚é–“ã®è¨­å®š
    /// </summary>
    /// <param name="duration">ãƒ–ãƒ¬ãƒ³ãƒ‰æ™‚é–“ï¼ˆç§’ï¼‰</param>
    void SetBlendDuration(float duration) { blendDuration_ = duration; }

private:
    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ™‚é–“ã§ã‚½ãƒ¼ãƒˆ
    /// </summary>
    void SortKeyframes();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ç·æ™‚é–“ã‚’æ›´æ–°
    /// </summary>
    void UpdateDuration();

    /// <summary>
    /// ç¾åœ¨æ™‚åˆ»ã«å¯¾å¿œã™ã‚‹2ã¤ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ¤œç´¢
    /// </summary>
    /// <param name="time">æ¤œç´¢æ™‚åˆ»</param>
    /// <param name="prevIndex">å‰ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆå‡ºåŠ›ï¼‰</param>
    /// <param name="nextIndex">æ¬¡ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆå‡ºåŠ›ï¼‰</param>
    /// <returns>ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã£ãŸã‹</returns>
    bool FindKeyframeIndices(float time, size_t& prevIndex, size_t& nextIndex) const;

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®è£œé–“
    /// </summary>
    /// <param name="prev">å‰ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ </param>
    /// <param name="next">æ¬¡ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ </param>
    /// <param name="t">è£œé–“ä¿‚æ•°ï¼ˆ0.0ï½ž1.0ï¼‰</param>
    void InterpolateKeyframes(const CameraKeyframe& prev, const CameraKeyframe& next, float t);

    /// <summary>
    /// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã®é©ç”¨
    /// </summary>
    /// <param name="t">å…ƒã®è£œé–“ä¿‚æ•°</param>
    /// <param name="type">è£œé–“ã‚¿ã‚¤ãƒ—</param>
    /// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨å¾Œã®è£œé–“ä¿‚æ•°</returns>
    float ApplyEasing(float t, CameraKeyframe::InterpolationType type) const;

    /// <summary>
    /// ã‚ªã‚¤ãƒ©ãƒ¼è§’ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã«å¤‰æ›
    /// </summary>
    /// <param name="euler">ã‚ªã‚¤ãƒ©ãƒ¼è§’ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</param>
    /// <returns>ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³</returns>
    Quaternion EulerToQuaternion(const Vector3& euler) const;

    /// <summary>
    /// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’ã‚ªã‚¤ãƒ©ãƒ¼è§’ã«å¤‰æ›
    /// </summary>
    /// <param name="q">ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³</param>
    /// <returns>ã‚ªã‚¤ãƒ©ãƒ¼è§’ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</returns>
    Vector3 QuaternionToEuler(const Quaternion& q) const;

    /// <summary>
    /// é¸æŠžè§£é™¤æ™‚ã®å‡¦ç†ï¼ˆã‚«ãƒ¡ãƒ©ã‚’å…ƒã®å€¤ã«æˆ»ã™ï¼‰
    /// </summary>
    void ClearDeselectState();

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚«ãƒ¡ãƒ©ã«ç›´æŽ¥é©ç”¨ï¼ˆå†…éƒ¨ç”¨ï¼‰
    /// </summary>
    void ApplyKeyframeDirectly(const CameraKeyframe& kf);

private:
    std::string animationName_ = "Untitled";  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å

    std::vector<CameraKeyframe> keyframes_;  ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é…åˆ—

    Camera* camera_ = nullptr;  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©

    const Transform* targetTransform_ = nullptr;  ///< ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ï¼ˆç›¸å¯¾åº§æ¨™ã®åŸºæº–ï¼‰

    float currentTime_ = 0.0f;  ///< ç¾åœ¨ã®å†ç”Ÿæ™‚é–“ï¼ˆç§’ï¼‰

    float duration_ = 0.0f;  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ç·æ™‚é–“ï¼ˆç§’ï¼‰

    float playSpeed_ = 1.0f;  ///< å†ç”Ÿé€Ÿåº¦ï¼ˆ1.0ãŒæ¨™æº–ï¼‰

    PlayState playState_ = PlayState::STOPPED;  ///< å†ç”ŸçŠ¶æ…‹

    bool isLooping_ = false;  ///< ãƒ«ãƒ¼ãƒ—å†ç”Ÿãƒ•ãƒ©ã‚°

    StartMode startMode_ = StartMode::JUMP_CUT;  ///< é–‹å§‹ãƒ¢ãƒ¼ãƒ‰
    float blendDuration_ = 0.5f;                 ///< ãƒ–ãƒ¬ãƒ³ãƒ‰æ™‚é–“ï¼ˆç§’ï¼‰
    float blendProgress_ = 0.0f;                 ///< ãƒ–ãƒ¬ãƒ³ãƒ‰é€²è¡Œåº¦ï¼ˆ0.0ï½ž1.0ï¼‰
    bool isBlending_ = false;                    ///< ãƒ–ãƒ¬ãƒ³ãƒ‰ä¸­ãƒ•ãƒ©ã‚°

    // ãƒ–ãƒ¬ãƒ³ãƒ‰é–‹å§‹æ™‚ã®ã‚«ãƒ¡ãƒ©çŠ¶æ…‹
    Vector3 blendStartPosition_;  ///< ãƒ–ãƒ¬ãƒ³ãƒ‰é–‹å§‹æ™‚ã®ä½ç½®
    Vector3 blendStartRotation_;  ///< ãƒ–ãƒ¬ãƒ³ãƒ‰é–‹å§‹æ™‚ã®å›žè»¢
    float blendStartFov_;         ///< ãƒ–ãƒ¬ãƒ³ãƒ‰é–‹å§‹æ™‚ã®FOV

    // FOVå¾©å…ƒç”¨
    float originalFov_;           ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹å‰ã®å…ƒã®FOVå€¤
    bool hasOriginalFov_;         ///< å…ƒã®FOVãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã‹ã®ãƒ•ãƒ©ã‚°

#ifdef _DEBUG
    int selectedKeyframeIndex_ = -1;  ///< ImGuiç”¨ï¼šé¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    bool showTimeline_ = true;  ///< ImGuiç”¨ï¼šã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¡¨ç¤ºãƒ•ãƒ©ã‚°
    bool autoSortKeyframes_ = true;  ///< ImGuiç”¨ï¼šã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è‡ªå‹•ã‚½ãƒ¼ãƒˆãƒ•ãƒ©ã‚°
    CameraKeyframe tempKeyframe_;  ///< ç·¨é›†ç”¨ã®ä¸€æ™‚ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 
#endif
};

============================================================
File Path: GameProject/CameraAnimation/CameraKeyframe.h
============================================================
#pragma once
#include "Vector3.h"
#include <json.hpp>

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æ§‹é€ ä½“
/// æ™‚é–“è»¸ä¸Šã®ç‰¹å®šãƒã‚¤ãƒ³ãƒˆã§ã®ã‚«ãƒ¡ãƒ©çŠ¶æ…‹ã‚’ä¿æŒ
/// </summary>
struct CameraKeyframe {
    /// <summary>
    /// è£œé–“ã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class InterpolationType {
        LINEAR,         ///< ç·šå½¢è£œé–“
        EASE_IN,        ///< ç·©ã‚„ã‹ã«é–‹å§‹
        EASE_OUT,       ///< ç·©ã‚„ã‹ã«çµ‚äº†
        EASE_IN_OUT,    ///< ä¸¡ç«¯ã§ç·©ã‚„ã‹
        CUBIC_BEZIER    ///< ã‚«ã‚¹ã‚¿ãƒ ãƒ™ã‚¸ã‚§ã‚«ãƒ¼ãƒ–ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
    };

    /// <summary>
    /// åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class CoordinateType {
        WORLD,          ///< ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ï¼ˆå¾“æ¥ã®å‹•ä½œï¼‰
        TARGET_RELATIVE ///< ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç›¸å¯¾åº§æ¨™ç³»ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
    };

    float time = 0.0f;                                             ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚åˆ»ï¼ˆç§’ï¼‰

    Vector3 position = { 0.0f, 0.0f, 0.0f };                      ///< ã‚«ãƒ¡ãƒ©ä½ç½®ï¼ˆWORLDãƒ¢ãƒ¼ãƒ‰ï¼‰ã¾ãŸã¯ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆTARGET_RELATIVEãƒ¢ãƒ¼ãƒ‰ï¼‰

    Vector3 rotation = { 0.0f, 0.0f, 0.0f };                      ///< ã‚«ãƒ¡ãƒ©å›žè»¢ï¼ˆã‚ªã‚¤ãƒ©ãƒ¼è§’ã€ãƒ©ã‚¸ã‚¢ãƒ³ï¼‰

    float fov = 0.45f;                                             ///< è¦–é‡Žè§’ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰

    InterpolationType interpolation = InterpolationType::LINEAR;   ///< ã“ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰æ¬¡ã¸ã®è£œé–“æ–¹æ³•

    CoordinateType coordinateType = CoordinateType::WORLD;         ///< åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰

    /// <summary>
    /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    CameraKeyframe() = default;

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æŒ‡å®šã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    CameraKeyframe(float t, const Vector3& pos, const Vector3& rot, float f,
                   InterpolationType interp = InterpolationType::LINEAR,
                   CoordinateType coordType = CoordinateType::WORLD)
        : time(t), position(pos), rotation(rot), fov(f), interpolation(interp), coordinateType(coordType) {}
};

/// <summary>
/// JSONå¤‰æ›ç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
/// </summary>
namespace nlohmann {
    template <>
    struct adl_serializer<CameraKeyframe::CoordinateType> {
        static void to_json(json& j, const CameraKeyframe::CoordinateType& type) {
            switch (type) {
                case CameraKeyframe::CoordinateType::WORLD:
                    j = "WORLD";
                    break;
                case CameraKeyframe::CoordinateType::TARGET_RELATIVE:
                    j = "TARGET_RELATIVE";
                    break;
            }
        }

        static void from_json(const json& j, CameraKeyframe::CoordinateType& type) {
            std::string str = j.get<std::string>();
            if (str == "WORLD") {
                type = CameraKeyframe::CoordinateType::WORLD;
            } else if (str == "TARGET_RELATIVE") {
                type = CameraKeyframe::CoordinateType::TARGET_RELATIVE;
            } else {
                type = CameraKeyframe::CoordinateType::WORLD; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            }
        }
    };

    template <>
    struct adl_serializer<CameraKeyframe::InterpolationType> {
        static void to_json(json& j, const CameraKeyframe::InterpolationType& type) {
            switch (type) {
                case CameraKeyframe::InterpolationType::LINEAR:
                    j = "LINEAR";
                    break;
                case CameraKeyframe::InterpolationType::EASE_IN:
                    j = "EASE_IN";
                    break;
                case CameraKeyframe::InterpolationType::EASE_OUT:
                    j = "EASE_OUT";
                    break;
                case CameraKeyframe::InterpolationType::EASE_IN_OUT:
                    j = "EASE_IN_OUT";
                    break;
                case CameraKeyframe::InterpolationType::CUBIC_BEZIER:
                    j = "CUBIC_BEZIER";
                    break;
            }
        }

        static void from_json(const json& j, CameraKeyframe::InterpolationType& type) {
            std::string str = j.get<std::string>();
            if (str == "LINEAR") {
                type = CameraKeyframe::InterpolationType::LINEAR;
            } else if (str == "EASE_IN") {
                type = CameraKeyframe::InterpolationType::EASE_IN;
            } else if (str == "EASE_OUT") {
                type = CameraKeyframe::InterpolationType::EASE_OUT;
            } else if (str == "EASE_IN_OUT") {
                type = CameraKeyframe::InterpolationType::EASE_IN_OUT;
            } else if (str == "CUBIC_BEZIER") {
                type = CameraKeyframe::InterpolationType::CUBIC_BEZIER;
            } else {
                type = CameraKeyframe::InterpolationType::LINEAR; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            }
        }
    };

    template <>
    struct adl_serializer<CameraKeyframe> {
        static void to_json(json& j, const CameraKeyframe& keyframe) {
            j = json{
                {"time", keyframe.time},
                {"position", {keyframe.position.x, keyframe.position.y, keyframe.position.z}},
                {"rotation", {keyframe.rotation.x, keyframe.rotation.y, keyframe.rotation.z}},
                {"fov", keyframe.fov},
                {"interpolation", keyframe.interpolation},
                {"coordinateType", keyframe.coordinateType}
            };
        }

        static void from_json(const json& j, CameraKeyframe& keyframe) {
            keyframe.time = j.at("time").get<float>();

            auto pos = j.at("position");
            keyframe.position.x = pos[0].get<float>();
            keyframe.position.y = pos[1].get<float>();
            keyframe.position.z = pos[2].get<float>();

            auto rot = j.at("rotation");
            keyframe.rotation.x = rot[0].get<float>();
            keyframe.rotation.y = rot[1].get<float>();
            keyframe.rotation.z = rot[2].get<float>();

            keyframe.fov = j.at("fov").get<float>();
            keyframe.interpolation = j.at("interpolation").get<CameraKeyframe::InterpolationType>();

            // å¾Œæ–¹äº’æ›æ€§: coordinateTypeãŒå­˜åœ¨ã—ãªã„å ´åˆã¯WORLDã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹
            if (j.contains("coordinateType")) {
                keyframe.coordinateType = j.at("coordinateType").get<CameraKeyframe::CoordinateType>();
            } else {
                keyframe.coordinateType = CameraKeyframe::CoordinateType::WORLD;
            }
        }
    };
}

============================================================
File Path: GameProject/CameraSystem/CameraAnimationEditor/CameraAnimationCurveEditor.cpp
============================================================
#ifdef _DEBUG

#include "CameraAnimationCurveEditor.h"
#include <algorithm>
#include <cmath>

CameraAnimationCurveEditor::CameraAnimationCurveEditor() {
    // ã‚«ãƒ¼ãƒ–è‰²ã®åˆæœŸåŒ–
    curveColors_[static_cast<int>(CurveType::POSITION_X)] = IM_COL32(255, 100, 100, 255);
    curveColors_[static_cast<int>(CurveType::POSITION_Y)] = IM_COL32(100, 255, 100, 255);
    curveColors_[static_cast<int>(CurveType::POSITION_Z)] = IM_COL32(100, 100, 255, 255);
    curveColors_[static_cast<int>(CurveType::ROTATION_X)] = IM_COL32(255, 200, 100, 255);
    curveColors_[static_cast<int>(CurveType::ROTATION_Y)] = IM_COL32(200, 255, 100, 255);
    curveColors_[static_cast<int>(CurveType::ROTATION_Z)] = IM_COL32(100, 200, 255, 255);
    curveColors_[static_cast<int>(CurveType::FOV)] = IM_COL32(255, 255, 100, 255);

    // åˆæœŸçŠ¶æ…‹ã§ã¯POSITION_Xã®ã¿è¡¨ç¤ºï¼ˆã‚¿ãƒ–é¸æŠžã§åˆ‡ã‚Šæ›¿ã‚ã‚‹ï¼‰
    for (int i = 0; i < static_cast<int>(CurveType::COUNT); ++i) {
        curveVisible_[i] = (i == 0);  // POSITION_Xã®ã¿
    }
}

CameraAnimationCurveEditor::~CameraAnimationCurveEditor() {
}

void CameraAnimationCurveEditor::Initialize(CameraAnimation* animation) {
    animation_ = animation;
    tangents_.clear();
    selectedKeyPoint_ = -1;
}

void CameraAnimationCurveEditor::Draw(const std::vector<int>& selectedKeyframes) {
    if (!animation_) return;

    ImGui::Text("Curve Editor");
    ImGui::Separator();

    // ã‚«ãƒ¼ãƒ–é¸æŠžã‚¿ãƒ–
    const char* curveNames[] = { "Pos X", "Pos Y", "Pos Z", "Rot X", "Rot Y", "Rot Z", "FOV" };
    static int selectedTab = 0;
    if (ImGui::BeginTabBar("CurveTypes")) {
        for (int i = 0; i < static_cast<int>(CurveType::COUNT); ++i) {
            if (ImGui::BeginTabItem(curveNames[i])) {
                selectedTab = i;
                activeCurve_ = static_cast<CurveType>(i);
                // é¸æŠžã•ã‚ŒãŸã‚«ãƒ¼ãƒ–ã®ã¿å¯è¦–ã«è¨­å®š
                for (int j = 0; j < static_cast<int>(CurveType::COUNT); ++j) {
                    curveVisible_[j] = (j == i);
                }
                ImGui::EndTabItem();
            }
        }
        ImGui::EndTabBar();
    }

    // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ãƒ—ãƒªã‚»ãƒƒãƒˆ
    DrawEasingPresets();

    // ã‚°ãƒ©ãƒ•ã‚¨ãƒªã‚¢
    DrawGraphArea();

    // ã‚«ãƒ¼ãƒ–ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
    DrawCurveProperties();
}

void CameraAnimationCurveEditor::DrawGraphArea() {
    ImVec2 canvasSize = ImGui::GetContentRegionAvail();
    if (canvasSize.x < 100 || canvasSize.y < 100) {
        canvasSize = ImVec2(600, 300);
    }
    graphSize_ = ImVec2(canvasSize.x - 20, std::min<float>(300.0f, canvasSize.y - 100.0f));

    ImGui::BeginChild("GraphArea", graphSize_, true, ImGuiWindowFlags_NoScrollbar);

    ImDrawList* drawList = ImGui::GetWindowDrawList();
    graphPos_ = ImGui::GetCursorScreenPos();
    ImVec2 graphMax = ImVec2(graphPos_.x + graphSize_.x, graphPos_.y + graphSize_.y);

    // èƒŒæ™¯
    drawList->AddRectFilled(graphPos_, graphMax, IM_COL32(30, 30, 30, 255));

    // ã‚°ãƒªãƒƒãƒ‰æç”»
    if (showGrid_) {
        DrawGrid();
    }

    // è»¸æç”»
    if (showAxes_) {
        DrawAxes();
    }

    // ã‚«ãƒ¼ãƒ–æç”»
    for (int i = 0; i < static_cast<int>(CurveType::COUNT); ++i) {
        if (curveVisible_[i]) {
            DrawCurve(static_cast<CurveType>(i));
        }
    }

    // ãƒžã‚¦ã‚¹å…¥åŠ›å‡¦ç†
    HandleMouseInput();

    ImGui::EndChild();
}

void CameraAnimationCurveEditor::DrawGrid() {
    ImDrawList* drawList = ImGui::GetWindowDrawList();

    // æ™‚é–“ã‚°ãƒªãƒƒãƒ‰ï¼ˆåž‚ç›´ç·šï¼‰
    float timeStep = 1.0f;  // 1ç§’ã”ã¨
    for (float t = 0; t <= timeRange_; t += timeStep) {
        ImVec2 p = ValueToGraph(t, 0);
        if (p.x >= graphPos_.x && p.x <= graphPos_.x + graphSize_.x) {
            drawList->AddLine(
                ImVec2(p.x, graphPos_.y),
                ImVec2(p.x, graphPos_.y + graphSize_.y),
                IM_COL32(60, 60, 60, 255));
        }
    }

    // å€¤ã‚°ãƒªãƒƒãƒ‰ï¼ˆæ°´å¹³ç·šï¼‰
    float valueStep = (valueRangeMax_ - valueRangeMin_) / 10.0f;
    for (float v = valueRangeMin_; v <= valueRangeMax_; v += valueStep) {
        ImVec2 p = ValueToGraph(0, v);
        if (p.y >= graphPos_.y && p.y <= graphPos_.y + graphSize_.y) {
            drawList->AddLine(
                ImVec2(graphPos_.x, p.y),
                ImVec2(graphPos_.x + graphSize_.x, p.y),
                IM_COL32(60, 60, 60, 255));
        }
    }
}

void CameraAnimationCurveEditor::DrawAxes() {
    ImDrawList* drawList = ImGui::GetWindowDrawList();

    // Xè»¸ï¼ˆæ™‚é–“ï¼‰
    ImVec2 xAxisStart = ValueToGraph(0, 0);
    ImVec2 xAxisEnd = ValueToGraph(timeRange_, 0);
    if (xAxisStart.y >= graphPos_.y && xAxisStart.y <= graphPos_.y + graphSize_.y) {
        drawList->AddLine(xAxisStart, xAxisEnd, IM_COL32(100, 100, 100, 255), 2.0f);
    }

    // Yè»¸ï¼ˆå€¤ï¼‰
    ImVec2 yAxisStart = ValueToGraph(0, valueRangeMin_);
    ImVec2 yAxisEnd = ValueToGraph(0, valueRangeMax_);
    if (yAxisStart.x >= graphPos_.x && yAxisStart.x <= graphPos_.x + graphSize_.x) {
        drawList->AddLine(yAxisStart, yAxisEnd, IM_COL32(100, 100, 100, 255), 2.0f);
    }
}

void CameraAnimationCurveEditor::DrawCurve(CurveType curveType) {
    if (!animation_ || animation_->GetKeyframeCount() < 2) return;

    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImU32 color = curveColors_[static_cast<int>(curveType)];

    // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®è£œé–“ã‚«ãƒ¼ãƒ–ã‚’æç”»
    std::vector<ImVec2> points;

    for (size_t i = 0; i < animation_->GetKeyframeCount() - 1; ++i) {
        const CameraKeyframe& kf1 = animation_->GetKeyframe(i);
        const CameraKeyframe& kf2 = animation_->GetKeyframe(i + 1);

        float v1 = GetCurveValue(kf1, curveType);
        float v2 = GetCurveValue(kf2, curveType);

        // è£œé–“æ›²ç·šã‚’æç”»ï¼ˆè§£åƒåº¦åˆ†ã®ãƒã‚¤ãƒ³ãƒˆã‚’ç”Ÿæˆï¼‰
        for (int j = 0; j <= curveResolution_; ++j) {
            float t = static_cast<float>(j) / curveResolution_;
            float time = kf1.time + (kf2.time - kf1.time) * t;

            // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨
            float easedT = ApplyEasing(t, kf1.interpolation);
            float value = v1 + (v2 - v1) * easedT;

            ImVec2 p = ValueToGraph(time, value);
            if (p.x >= graphPos_.x && p.x <= graphPos_.x + graphSize_.x &&
                p.y >= graphPos_.y && p.y <= graphPos_.y + graphSize_.y) {
                points.push_back(p);
            }
        }
    }

    // ã‚«ãƒ¼ãƒ–ã‚’æç”»
    if (points.size() > 1) {
        for (size_t i = 0; i < points.size() - 1; ++i) {
            drawList->AddLine(points[i], points[i + 1], color, 2.0f);
        }
    }

    // ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’æç”»
    for (size_t i = 0; i < animation_->GetKeyframeCount(); ++i) {
        const CameraKeyframe& kf = animation_->GetKeyframe(i);
        float value = GetCurveValue(kf, curveType);
        ImVec2 p = ValueToGraph(kf.time, value);

        if (p.x >= graphPos_.x - 5 && p.x <= graphPos_.x + graphSize_.x + 5 &&
            p.y >= graphPos_.y - 5 && p.y <= graphPos_.y + graphSize_.y + 5) {

            bool isSelected = (selectedKeyPoint_ == static_cast<int>(i) &&
                             activeCurve_ == curveType);
            DrawKeyPoint(static_cast<int>(i), p.x, p.y, isSelected);
        }
    }
}

void CameraAnimationCurveEditor::DrawKeyPoint(int index, float x, float y, bool isSelected) {
    ImDrawList* drawList = ImGui::GetWindowDrawList();

    float radius = isSelected ? 6.0f : 4.0f;
    ImU32 fillColor = isSelected ? IM_COL32(255, 200, 100, 255) : IM_COL32(255, 255, 255, 255);
    ImU32 borderColor = IM_COL32(0, 0, 0, 255);

    drawList->AddCircleFilled(ImVec2(x, y), radius, fillColor);
    drawList->AddCircle(ImVec2(x, y), radius, borderColor, 0, 2.0f);

    // å€¤è¡¨ç¤º
    if (showValues_ && isSelected) {
        char label[64];
        const CameraKeyframe& kf = animation_->GetKeyframe(index);
        float value = GetCurveValue(kf, activeCurve_);
        snprintf(label, sizeof(label), "%.2f", value);
        drawList->AddText(ImVec2(x + 10, y - 10), IM_COL32(255, 255, 255, 255), label);
    }
}

void CameraAnimationCurveEditor::DrawEasingPresets() {
    ImGui::Text("Easing Presets:");
    ImGui::SameLine();

    const char* easingNames[] = { "Linear", "Ease In", "Ease Out", "Ease In-Out" };

    // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆé¸æŠžã®ã¿ã€é©ç”¨ã¯ãƒœã‚¿ãƒ³ã§è¡Œã†ï¼‰
    ImGui::PushItemWidth(120.0f);
    ImGui::Combo("##EasingPreset", &selectedEasingIndex_, easingNames, 4);
    ImGui::PopItemWidth();

    // é©ç”¨ãƒœã‚¿ãƒ³
    ImGui::SameLine();
    if (ImGui::Button("Apply")) {
        if (selectedKeyPoint_ >= 0 && selectedKeyPoint_ < static_cast<int>(animation_->GetKeyframeCount())) {
            CameraKeyframe kf = animation_->GetKeyframe(selectedKeyPoint_);
            kf.interpolation = static_cast<CameraKeyframe::InterpolationType>(selectedEasingIndex_);
            animation_->EditKeyframe(selectedKeyPoint_, kf);
        }
    }
}

void CameraAnimationCurveEditor::DrawCurveProperties() {
    ImGui::Separator();
    ImGui::Text("Curve Properties");

    // è¡¨ç¤ºè¨­å®š
    ImGui::Checkbox("Show Grid", &showGrid_);
    ImGui::SameLine();
    ImGui::Checkbox("Show Axes", &showAxes_);
    ImGui::SameLine();
    ImGui::Checkbox("Show Values", &showValues_);

    // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³
    ImGui::DragFloat("Zoom X", &zoomX_, 0.01f, 0.1f, 10.0f);
    ImGui::DragFloat("Zoom Y", &zoomY_, 0.01f, 0.1f, 10.0f);

    // ç¯„å›²è¨­å®š
    ImGui::DragFloat("Time Range", &timeRange_, 0.1f, 1.0f, 60.0f);
    ImGui::DragFloat2("Value Range", &valueRangeMin_, 0.1f);
}

void CameraAnimationCurveEditor::HandleMouseInput() {
    ImVec2 mousePos = ImGui::GetMousePos();

    // ã‚°ãƒ©ãƒ•ã‚¨ãƒªã‚¢å†…ã‹ãƒã‚§ãƒƒã‚¯
    if (mousePos.x < graphPos_.x || mousePos.x > graphPos_.x + graphSize_.x ||
        mousePos.y < graphPos_.y || mousePos.y > graphPos_.y + graphSize_.y) {
        return;
    }

    // ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
        // ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
        selectedKeyPoint_ = -1;
        for (size_t i = 0; i < animation_->GetKeyframeCount(); ++i) {
            const CameraKeyframe& kf = animation_->GetKeyframe(i);
            float value = GetCurveValue(kf, activeCurve_);
            ImVec2 p = ValueToGraph(kf.time, value);

            float dist = std::sqrt(
                (mousePos.x - p.x) * (mousePos.x - p.x) +
                (mousePos.y - p.y) * (mousePos.y - p.y));

            if (dist <= 6.0f) {
                selectedKeyPoint_ = static_cast<int>(i);
                isDragging_ = true;
                dragStartPos_ = mousePos;
                dragStartTime_ = kf.time;
                dragStartValue_ = value;
                break;
            }
        }
    }

    // ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†
    if (isDragging_ && ImGui::IsMouseDragging(ImGuiMouseButton_Left)) {
        if (selectedKeyPoint_ >= 0 && selectedKeyPoint_ < static_cast<int>(animation_->GetKeyframeCount())) {
            float time, value;
            GraphToValue(mousePos, time, value);

            // ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
            if (enableGridSnap_) {
                SnapToGrid(time, value);
            }

            // æ™‚é–“ã¨å€¤ã®åˆ¶é™
            time = std::max<float>(0.0f, std::min<float>(time, animation_->GetDuration()));
            value = std::max<float>(valueRangeMin_, std::min<float>(value, valueRangeMax_));

            // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ›´æ–°
            CameraKeyframe kf = animation_->GetKeyframe(selectedKeyPoint_);
            kf.time = time;
            SetCurveValue(kf, activeCurve_, value);
            animation_->EditKeyframe(selectedKeyPoint_, kf);
        }
    }

    // ãƒªãƒªãƒ¼ã‚¹å‡¦ç†
    if (ImGui::IsMouseReleased(ImGuiMouseButton_Left)) {
        isDragging_ = false;
    }

    // ãƒ›ã‚¤ãƒ¼ãƒ«ï¼ˆã‚ºãƒ¼ãƒ ï¼‰
    if (ImGui::GetIO().MouseWheel != 0) {
        float zoomDelta = ImGui::GetIO().MouseWheel * 0.1f;
        zoomX_ = std::max<float>(0.1f, std::min<float>(10.0f, zoomX_ + zoomDelta));
        zoomY_ = std::max<float>(0.1f, std::min<float>(10.0f, zoomY_ + zoomDelta));
    }
}

ImVec2 CameraAnimationCurveEditor::ValueToGraph(float time, float value) const {
    float x = graphPos_.x + (time / timeRange_) * graphSize_.x * zoomX_ + panX_;
    float y = graphPos_.y + graphSize_.y -
              ((value - valueRangeMin_) / (valueRangeMax_ - valueRangeMin_)) * graphSize_.y * zoomY_ - panY_;
    return ImVec2(x, y);
}

void CameraAnimationCurveEditor::GraphToValue(const ImVec2& pos, float& time, float& value) const {
    time = ((pos.x - graphPos_.x - panX_) / (graphSize_.x * zoomX_)) * timeRange_;
    value = valueRangeMin_ +
            (1.0f - (pos.y - graphPos_.y + panY_) / (graphSize_.y * zoomY_)) *
            (valueRangeMax_ - valueRangeMin_);
}

float CameraAnimationCurveEditor::GetCurveValue(const CameraKeyframe& kf, CurveType type) const {
    switch (type) {
        case CurveType::POSITION_X: return kf.position.x;
        case CurveType::POSITION_Y: return kf.position.y;
        case CurveType::POSITION_Z: return kf.position.z;
        case CurveType::ROTATION_X: return kf.rotation.x;
        case CurveType::ROTATION_Y: return kf.rotation.y;
        case CurveType::ROTATION_Z: return kf.rotation.z;
        case CurveType::FOV: return kf.fov;
        default: return 0.0f;
    }
}

void CameraAnimationCurveEditor::SetCurveValue(CameraKeyframe& kf, CurveType type, float value) {
    switch (type) {
        case CurveType::POSITION_X: kf.position.x = value; break;
        case CurveType::POSITION_Y: kf.position.y = value; break;
        case CurveType::POSITION_Z: kf.position.z = value; break;
        case CurveType::ROTATION_X: kf.rotation.x = value; break;
        case CurveType::ROTATION_Y: kf.rotation.y = value; break;
        case CurveType::ROTATION_Z: kf.rotation.z = value; break;
        case CurveType::FOV: kf.fov = value; break;
    }
}

float CameraAnimationCurveEditor::ApplyEasing(float t, CameraKeyframe::InterpolationType type) const {
    switch (type) {
        case CameraKeyframe::InterpolationType::LINEAR:
            return t;

        case CameraKeyframe::InterpolationType::EASE_IN:
            return t * t;

        case CameraKeyframe::InterpolationType::EASE_OUT:
            return 1.0f - (1.0f - t) * (1.0f - t);

        case CameraKeyframe::InterpolationType::EASE_IN_OUT:
            if (t < 0.5f) {
                return 2.0f * t * t;
            } else {
                return 1.0f - 2.0f * (1.0f - t) * (1.0f - t);
            }

        default:
            return t;
    }
}

void CameraAnimationCurveEditor::SnapToGrid(float& time, float& value) const {
    time = std::round(time / gridSnapIntervalX_) * gridSnapIntervalX_;
    value = std::round(value / gridSnapIntervalY_) * gridSnapIntervalY_;
}

void CameraAnimationCurveEditor::SetCurveVisible(CurveType type, bool visible) {
    int index = static_cast<int>(type);
    if (index >= 0 && index < static_cast<int>(CurveType::COUNT)) {
        curveVisible_[index] = visible;
    }
}

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraAnimationEditor/CameraAnimationCurveEditor.h
============================================================
#pragma once

#ifdef _DEBUG

#include "CameraAnimation/CameraAnimation.h"
#include "CameraAnimation/CameraKeyframe.h"
#include <vector>
#include "ImGuiManager.h"

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ãƒ¼ãƒ–ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
/// è£œé–“ã‚«ãƒ¼ãƒ–ã®è¦–è¦šçš„ç·¨é›†æ©Ÿèƒ½ã‚’æä¾›
/// </summary>
class CameraAnimationCurveEditor {
public:
    /// <summary>
    /// ã‚«ãƒ¼ãƒ–ã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class CurveType {
        POSITION_X,     ///< Xä½ç½®ã‚«ãƒ¼ãƒ–
        POSITION_Y,     ///< Yä½ç½®ã‚«ãƒ¼ãƒ–
        POSITION_Z,     ///< Zä½ç½®ã‚«ãƒ¼ãƒ–
        ROTATION_X,     ///< Xå›žè»¢ã‚«ãƒ¼ãƒ–
        ROTATION_Y,     ///< Yå›žè»¢ã‚«ãƒ¼ãƒ–
        ROTATION_Z,     ///< Zå›žè»¢ã‚«ãƒ¼ãƒ–
        FOV,            ///< FOVã‚«ãƒ¼ãƒ–
        COUNT
    };

    /// <summary>
    /// ãƒãƒ³ãƒ‰ãƒ«ã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class HandleType {
        NONE,           ///< ãªã—
        LEFT,           ///< å·¦ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆ
        RIGHT,          ///< å³ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆ
        BOTH            ///< ä¸¡æ–¹
    };

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    CameraAnimationCurveEditor();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~CameraAnimationCurveEditor();

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    /// <param name="animation">å¯¾è±¡ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</param>
    void Initialize(CameraAnimation* animation);

    /// <summary>
    /// ã‚«ãƒ¼ãƒ–ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®æç”»
    /// </summary>
    /// <param name="selectedKeyframes">é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ </param>
    void Draw(const std::vector<int>& selectedKeyframes);

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¼ãƒ–ã®è¨­å®š
    /// </summary>
    void SetActiveCurve(CurveType type) { activeCurve_ = type; }

    /// <summary>
    /// ã‚«ãƒ¼ãƒ–ã®å¯è¦–æ€§è¨­å®š
    /// </summary>
    void SetCurveVisible(CurveType type, bool visible);

    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—ã®æœ‰åŠ¹åŒ–
    /// </summary>
    void SetGridSnapEnabled(bool enable) { enableGridSnap_ = enable; }

private:
    /// <summary>
    /// ã‚°ãƒ©ãƒ•ã‚¨ãƒªã‚¢ã®æç”»
    /// </summary>
    void DrawGraphArea();

    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ã®æç”»
    /// </summary>
    void DrawGrid();

    /// <summary>
    /// è»¸ã®æç”»
    /// </summary>
    void DrawAxes();

    /// <summary>
    /// ã‚«ãƒ¼ãƒ–ã®æç”»
    /// </summary>
    /// <param name="curveType">ã‚«ãƒ¼ãƒ–ã‚¿ã‚¤ãƒ—</param>
    void DrawCurve(CurveType curveType);

    /// <summary>
    /// ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆã®æç”»
    /// </summary>
    /// <param name="index">ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    /// <param name="x">Xåº§æ¨™</param>
    /// <param name="y">Yåº§æ¨™</param>
    /// <param name="isSelected">é¸æŠžçŠ¶æ…‹</param>
    void DrawKeyPoint(int index, float x, float y, bool isSelected);

    /// <summary>
    /// ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ«ã®æç”»
    /// </summary>
    /// <param name="centerX">ä¸­å¿ƒXåº§æ¨™</param>
    /// <param name="centerY">ä¸­å¿ƒYåº§æ¨™</param>
    /// <param name="handleX">ãƒãƒ³ãƒ‰ãƒ«Xåº§æ¨™</param>
    /// <param name="handleY">ãƒãƒ³ãƒ‰ãƒ«Yåº§æ¨™</param>
    /// <param name="isLeft">å·¦ãƒãƒ³ãƒ‰ãƒ«ã‹</param>
    void DrawTangentHandle(float centerX, float centerY, float handleX, float handleY, bool isLeft);

    /// <summary>
    /// ãƒžã‚¦ã‚¹å…¥åŠ›ã®å‡¦ç†
    /// </summary>
    void HandleMouseInput();

    /// <summary>
    /// ã‚«ãƒ¼ãƒ–ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è¡¨ç¤º
    /// </summary>
    void DrawCurveProperties();

    /// <summary>
    /// ãƒ—ãƒªã‚»ãƒƒãƒˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ãƒœã‚¿ãƒ³
    /// </summary>
    void DrawEasingPresets();

    /// <summary>
    /// å€¤ã‚’ã‚°ãƒ©ãƒ•åº§æ¨™ã«å¤‰æ›
    /// </summary>
    ImVec2 ValueToGraph(float time, float value) const;

    /// <summary>
    /// ã‚°ãƒ©ãƒ•åº§æ¨™ã‚’å€¤ã«å¤‰æ›
    /// </summary>
    void GraphToValue(const ImVec2& pos, float& time, float& value) const;

    /// <summary>
    /// ã‚«ãƒ¼ãƒ–å€¤ã®å–å¾—
    /// </summary>
    float GetCurveValue(const CameraKeyframe& kf, CurveType type) const;

    /// <summary>
    /// ã‚«ãƒ¼ãƒ–å€¤ã®è¨­å®š
    /// </summary>
    void SetCurveValue(CameraKeyframe& kf, CurveType type, float value);

    /// <summary>
    /// ãƒ™ã‚¸ã‚§è£œé–“ã®è¨ˆç®—
    /// </summary>
    float CalculateBezier(float t, float p0, float p1, float p2, float p3) const;

    /// <summary>
    /// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã®é©ç”¨
    /// </summary>
    float ApplyEasing(float t, CameraKeyframe::InterpolationType type) const;

    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ã«ã‚¹ãƒŠãƒƒãƒ—
    /// </summary>
    void SnapToGrid(float& time, float& value) const;

private:
    // å‚ç…§
    CameraAnimation* animation_ = nullptr;       ///< å¯¾è±¡ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

    // ã‚°ãƒ©ãƒ•è¨­å®š
    ImVec2 graphPos_;                           ///< ã‚°ãƒ©ãƒ•ä½ç½®
    ImVec2 graphSize_ = ImVec2(600, 300);       ///< ã‚°ãƒ©ãƒ•ã‚µã‚¤ã‚º
    float timeRange_ = 10.0f;                   ///< æ™‚é–“ç¯„å›²
    float valueRangeMin_ = -10.0f;              ///< å€¤ã®æœ€å°ç¯„å›²
    float valueRangeMax_ = 10.0f;               ///< å€¤ã®æœ€å¤§ç¯„å›²
    float zoomX_ = 1.0f;                         ///< Xè»¸ã‚ºãƒ¼ãƒ 
    float zoomY_ = 1.0f;                         ///< Yè»¸ã‚ºãƒ¼ãƒ 
    float panX_ = 0.0f;                          ///< Xè»¸ãƒ‘ãƒ³
    float panY_ = 0.0f;                          ///< Yè»¸ãƒ‘ãƒ³

    // ã‚«ãƒ¼ãƒ–è¨­å®š
    CurveType activeCurve_ = CurveType::POSITION_X;  ///< ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¼ãƒ–
    bool curveVisible_[static_cast<int>(CurveType::COUNT)]; ///< ã‚«ãƒ¼ãƒ–å¯è¦–æ€§
    ImU32 curveColors_[static_cast<int>(CurveType::COUNT)]; ///< ã‚«ãƒ¼ãƒ–è‰²

    // é¸æŠžçŠ¶æ…‹
    int selectedKeyPoint_ = -1;                  ///< é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
    int selectedEasingIndex_ = 0;                ///< é¸æŠžä¸­ã®ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ãƒ—ãƒªã‚»ãƒƒãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    HandleType selectedHandle_ = HandleType::NONE; ///< é¸æŠžä¸­ã®ãƒãƒ³ãƒ‰ãƒ«
    bool isDragging_ = false;                    ///< ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‹
    ImVec2 dragStartPos_;                         ///< ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ä½ç½®
    float dragStartTime_;                         ///< ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®æ™‚é–“
    float dragStartValue_;                        ///< ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®å€¤

    // ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
    bool enableGridSnap_ = false;                ///< ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—æœ‰åŠ¹
    float gridSnapIntervalX_ = 0.1f;             ///< Xè»¸ã‚¹ãƒŠãƒƒãƒ—é–“éš”
    float gridSnapIntervalY_ = 1.0f;             ///< Yè»¸ã‚¹ãƒŠãƒƒãƒ—é–“éš”

    // è¡¨ç¤ºè¨­å®š
    bool showGrid_ = true;                       ///< ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
    bool showAxes_ = true;                       ///< è»¸è¡¨ç¤º
    bool showTangents_ = true;                   ///< ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆè¡¨ç¤º
    bool showValues_ = true;                     ///< å€¤è¡¨ç¤º
    int curveResolution_ = 50;                   ///< ã‚«ãƒ¼ãƒ–è§£åƒåº¦

    // ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆè¨­å®šï¼ˆå°†æ¥çš„ã«ãƒ™ã‚¸ã‚§ã‚«ãƒ¼ãƒ–å®Ÿè£…ç”¨ï¼‰
    struct TangentData {
        float leftLength = 0.3f;                 ///< å·¦ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆé•·ã•
        float leftAngle = 0.0f;                  ///< å·¦ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆè§’åº¦
        float rightLength = 0.3f;                ///< å³ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆé•·ã•
        float rightAngle = 0.0f;                 ///< å³ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆè§’åº¦
        bool broken = false;                     ///< åˆ†é›¢ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆ
    };
    std::vector<TangentData> tangents_;          ///< ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿
};

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraAnimationEditor/CameraAnimationEditor.cpp
============================================================
#ifdef _DEBUG

#include "CameraAnimationEditor.h"
#include "CameraAnimationTimeline.h"
#include "CameraAnimationCurveEditor.h"
#include "CameraAnimationHistory.h"
#include "../CameraManager.h"
#include "../Controller/CameraAnimationController.h"
#include "Vec3Func.h"
#include "ImGuiManager.h"
#include <algorithm>
#include <sstream>

CameraAnimationEditor::CameraAnimationEditor() {
    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®åˆæœŸåŒ–ã¯ Initialize ã§è¡Œã†
}

CameraAnimationEditor::~CameraAnimationEditor() {
    // unique_ptr ãŒè‡ªå‹•çš„ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
}

void CameraAnimationEditor::Initialize(CameraAnimation* animation, Camera* camera) {
    animation_ = animation;
    camera_ = camera;

    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®åˆæœŸåŒ–
    timeline_ = std::make_unique<CameraAnimationTimeline>();
    timeline_->Initialize(animation);

    curveEditor_ = std::make_unique<CameraAnimationCurveEditor>();
    curveEditor_->Initialize(animation);

    history_ = std::make_unique<CameraAnimationHistory>();
    history_->Initialize(animation);
}

void CameraAnimationEditor::Initialize(CameraAnimationController* controller, Camera* camera) {
    controller_ = controller;
    camera_ = camera;

    // ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å–å¾—
    animation_ = controller ? controller->GetCurrentAnimation() : nullptr;

    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®åˆæœŸåŒ–
    if (animation_) {
        // é‡è¦ï¼šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
        animation_->SetCamera(camera);

        timeline_ = std::make_unique<CameraAnimationTimeline>();
        timeline_->Initialize(animation_);

        curveEditor_ = std::make_unique<CameraAnimationCurveEditor>();
        curveEditor_->Initialize(animation_);

        history_ = std::make_unique<CameraAnimationHistory>();
        history_->Initialize(animation_);

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæƒ…å ±ã‚’å–å¾—ã—ã¦è¨­å®š
        targetTransform_ = animation_->GetTarget();
        targetName_ = targetTransform_ ? "Target" : "None";
    }
}

void CameraAnimationEditor::Draw() {
    if (!isOpen_ || !animation_ || !camera_) {
        return;
    }

    // ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
    ImGui::SetNextWindowSize(ImVec2(1200, 800), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Camera Animation Editor", &isOpen_, ImGuiWindowFlags_MenuBar)) {
        ImGui::End();
        return;
    }

    // ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆå‡¦ç†
    ProcessShortcuts();

    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼
    DrawMenuBar();

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é¸æŠžUIï¼ˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼çµŒç”±ã®å ´åˆã®ã¿ï¼‰
    if (controller_) {
        DrawAnimationSelector();
    }

    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæç”»ï¼ˆADVANCEDãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰
    // ä¸Šéƒ¨ï¼šå†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã¨ãƒ„ãƒ¼ãƒ«
    DrawPlaybackControls();

    ImGui::Separator();

    // ä¸­å¤®ï¼šã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã¨ã‚«ãƒ¼ãƒ–ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
    float availHeight = ImGui::GetContentRegionAvail().y - 25.0f; // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼åˆ†ã‚’å¼•ã
    float topHeight = availHeight * 0.4f;
    float bottomHeight = availHeight * 0.6f;

    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³
    if (ImGui::BeginChild("TimelineSection", ImVec2(0, topHeight), true)) {
        DrawTimelinePanel();
    }
    ImGui::EndChild();

    // ä¸‹éƒ¨ã‚’2åˆ†å‰²
    float availWidth = ImGui::GetContentRegionAvail().x;
    float leftWidth = availWidth * 0.7f;
    float rightWidth = availWidth * 0.3f;

    // å·¦ï¼šã‚«ãƒ¼ãƒ–ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
    if (ImGui::BeginChild("CurveSection", ImVec2(leftWidth - 5, bottomHeight), true)) {
        DrawCurveEditorPanel();
    }
    ImGui::EndChild();

    ImGui::SameLine();

    // å³ï¼šã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼
    if (ImGui::BeginChild("InspectorSection", ImVec2(rightWidth - 5, bottomHeight), true)) {
        ImGui::Text("Inspector");
        ImGui::Separator();
        DrawInspectorPanel();
    }
    ImGui::EndChild();

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼
    DrawStatusBar();

    ImGui::End();
}

void CameraAnimationEditor::Update(float deltaTime) {
    if (!animation_ || !camera_) {
        return;
    }


    // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ›´æ–°
    if (timeline_) {
        timeline_->Update(deltaTime);
    }
}

void CameraAnimationEditor::SetTarget(const Transform* target, const std::string& name) {
    targetTransform_ = target;
    targetName_ = name.empty() ? (target ? "Target" : "None") : name;

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    if (animation_) {
        animation_->SetTarget(target);
    }

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã«ã‚‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®šï¼ˆç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¿ï¼‰
    if (controller_) {
        controller_->SetCurrentAnimationTarget(target);
    }
}

void CameraAnimationEditor::ProcessShortcuts() {
    // Ctrl+Z: Undo
    if (ImGui::IsKeyDown(ImGuiKey_LeftCtrl) && ImGui::IsKeyPressed(ImGuiKey_Z)) {
        Undo();
    }

    // Ctrl+Y: Redo
    if (ImGui::IsKeyDown(ImGuiKey_LeftCtrl) && ImGui::IsKeyPressed(ImGuiKey_Y)) {
        Redo();
    }

    // Ctrl+C: Copy
    if (ImGui::IsKeyDown(ImGuiKey_LeftCtrl) && ImGui::IsKeyPressed(ImGuiKey_C)) {
        CopySelectedKeyframes();
    }

    // Ctrl+V: Paste
    if (ImGui::IsKeyDown(ImGuiKey_LeftCtrl) && ImGui::IsKeyPressed(ImGuiKey_V)) {
        PasteKeyframes();
    }

    // Delete: Delete selected keyframes
    if (ImGui::IsKeyPressed(ImGuiKey_Delete)) {
        DeleteSelectedKeyframes();
    }

    // Space: Play/Pause
    if (ImGui::IsKeyPressed(ImGuiKey_Space)) {
        if (animation_->GetPlayState() == CameraAnimation::PlayState::PLAYING) {
            animation_->Pause();
        }
        else {
            animation_->Play();
        }
    }

    // Escape: Deselect all
    if (ImGui::IsKeyPressed(ImGuiKey_Escape)) {
        selectedKeyframes_.clear();
    }
}

void CameraAnimationEditor::DrawMenuBar() {
    if (!ImGui::BeginMenuBar()) {
        return;
    }

    // File menu
    if (ImGui::BeginMenu("File")) {
        if (ImGui::MenuItem("New Animation", "Ctrl+N")) {
            animation_->ClearKeyframes();
            selectedKeyframes_.clear();
        }

        if (ImGui::MenuItem("Load...", "Ctrl+O")) {
            // TODO: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
        }

        if (ImGui::MenuItem("Save", "Ctrl+S")) {
            animation_->SaveToJson(animation_->GetAnimationName() + ".json");
        }

        if (ImGui::MenuItem("Save As...", "Ctrl+Shift+S")) {
            // TODO: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
        }

        ImGui::Separator();

        if (ImGui::MenuItem("Close", "Alt+F4")) {
            Close();
        }

        ImGui::EndMenu();
    }

    // Edit menu
    if (ImGui::BeginMenu("Edit")) {
        if (ImGui::MenuItem("Undo", "Ctrl+Z", false, history_ && history_->CanUndo())) {
            Undo();
        }

        if (ImGui::MenuItem("Redo", "Ctrl+Y", false, history_ && history_->CanRedo())) {
            Redo();
        }

        ImGui::Separator();

        if (ImGui::MenuItem("Copy", "Ctrl+C", false, !selectedKeyframes_.empty())) {
            CopySelectedKeyframes();
        }

        if (ImGui::MenuItem("Paste", "Ctrl+V", false, !clipboard_.empty())) {
            PasteKeyframes();
        }

        if (ImGui::MenuItem("Delete", "Del", false, !selectedKeyframes_.empty())) {
            DeleteSelectedKeyframes();
        }

        ImGui::Separator();

        if (ImGui::MenuItem("Select All", "Ctrl+A")) {
            selectedKeyframes_.clear();
            for (size_t i = 0; i < animation_->GetKeyframeCount(); ++i) {
                selectedKeyframes_.push_back(static_cast<int>(i));
            }
        }

        ImGui::EndMenu();
    }

    // View menu
    if (ImGui::BeginMenu("View")) {
        // ç¾åœ¨å®Ÿè£…æ¸ˆã¿ã®æ©Ÿèƒ½ã®ã¿è¡¨ç¤º
        // å°†æ¥çš„ã«æ‹¡å¼µäºˆå®š

        ImGui::EndMenu();
    }

    // Animation menu
    if (ImGui::BeginMenu("Animation")) {
        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æ“ä½œ
        if (ImGui::MenuItem("Add Keyframe", "A", false, camera_ && animation_)) {
            if (camera_ && animation_) {
                float currentTime = animation_->GetPlaybackTime();
                CameraKeyframe newKf;
                newKf.time = currentTime;
                newKf.position = camera_->GetTranslate();
                newKf.rotation = camera_->GetRotate();
                newKf.fov = camera_->GetFovY();
                newKf.interpolation = CameraKeyframe::InterpolationType::LINEAR;

                animation_->AddKeyframe(newKf);
                if (history_) {
                    history_->RecordAdd(animation_->GetKeyframeCount() - 1);
                }
            }
        }

        if (ImGui::MenuItem("Delete Selected", "Delete", false, !selectedKeyframes_.empty())) {
            DeleteSelectedKeyframes();
        }

        if (ImGui::MenuItem("Clear All Keyframes", nullptr, false, animation_ && animation_->GetKeyframeCount() > 0)) {
            if (animation_) {
                animation_->ClearKeyframes();
                selectedKeyframes_.clear();
            }
        }

        ImGui::Separator();

        ImGui::MenuItem("Enable Grid Snap", nullptr, &enableGridSnap_);

        ImGui::Separator();

        if (ImGui::BeginMenu("Grid Snap Interval")) {
            if (ImGui::MenuItem("0.1 sec", nullptr, gridSnapInterval_ == 0.1f)) {
                gridSnapInterval_ = 0.1f;
            }
            if (ImGui::MenuItem("0.25 sec", nullptr, gridSnapInterval_ == 0.25f)) {
                gridSnapInterval_ = 0.25f;
            }
            if (ImGui::MenuItem("0.5 sec", nullptr, gridSnapInterval_ == 0.5f)) {
                gridSnapInterval_ = 0.5f;
            }
            if (ImGui::MenuItem("1.0 sec", nullptr, gridSnapInterval_ == 1.0f)) {
                gridSnapInterval_ = 1.0f;
            }
            ImGui::EndMenu();
        }

        ImGui::EndMenu();
    }

    // Help menu
    if (ImGui::BeginMenu("Help")) {
        if (ImGui::MenuItem("Shortcuts")) {
            ImGui::OpenPopup("ShortcutsPopup");
        }
        if (ImGui::MenuItem("About")) {
            ImGui::OpenPopup("AboutPopup");
        }
        ImGui::EndMenu();
    }

    ImGui::EndMenuBar();

    // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—
    if (ImGui::BeginPopupModal("ShortcutsPopup", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("Keyboard Shortcuts:");
        ImGui::Separator();
        ImGui::Text("Space: Play/Pause");
        ImGui::Text("Ctrl+Z: Undo");
        ImGui::Text("Ctrl+Y: Redo");
        ImGui::Text("Ctrl+C: Copy");
        ImGui::Text("Ctrl+V: Paste");
        ImGui::Text("Delete: Delete Selected");
        ImGui::Text("1-5: Change Edit Mode");
        ImGui::Separator();
        if (ImGui::Button("Close")) {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }
}


void CameraAnimationEditor::DrawPlaybackControls() {
    if (!animation_) {
        ImGui::Text("No animation loaded");
        return;
    }

    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(15, 8));

    // å†ç”Ÿãƒœã‚¿ãƒ³
    if (animation_->GetPlayState() == CameraAnimation::PlayState::PLAYING) {
        if (ImGui::Button("||", ImVec2(40, 0))) {
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼çµŒç”±ã§å‘¼ã³å‡ºã—ï¼ˆisActive_ãƒ•ãƒ©ã‚°ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ï¼‰
            if (controller_) {
                controller_->Pause();
            }
            else {
                animation_->Pause();
            }
        }
    }
    else {
        if (ImGui::Button(">", ImVec2(40, 0))) {
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼çµŒç”±ã§å‘¼ã³å‡ºã—ï¼ˆisActive_ãƒ•ãƒ©ã‚°ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ï¼‰
            if (controller_) {
                controller_->Play();
            }
            else {
                animation_->Play();
            }
        }
    }

    ImGui::SameLine();
    if (ImGui::Button("[]", ImVec2(40, 0))) {
        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼çµŒç”±ã§å‘¼ã³å‡ºã—ï¼ˆisActive_ãƒ•ãƒ©ã‚°ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ï¼‰
        if (controller_) {
            controller_->Stop();
        }
        else {
            animation_->Stop();
        }
    }

    ImGui::SameLine();
    if (ImGui::Button("|<", ImVec2(40, 0))) {
        animation_->SetCurrentTime(0.0f);
    }

    ImGui::SameLine();
    if (ImGui::Button(">|", ImVec2(40, 0))) {
        animation_->SetCurrentTime(animation_->GetDuration());
    }

    // ã‚¿ã‚¤ãƒ ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤
    ImGui::SameLine();
    ImGui::Text("Time: %.2f / %.2f", animation_->GetPlaybackTime(), animation_->GetDuration());

    // ãƒ«ãƒ¼ãƒ—ãƒˆã‚°ãƒ«
    ImGui::SameLine();
    bool isLooping = animation_->IsLooping();
    if (ImGui::Checkbox("Loop", &isLooping)) {
        animation_->SetLooping(isLooping);
    }

    // å†ç”Ÿé€Ÿåº¦
    ImGui::SameLine();
    ImGui::SetNextItemWidth(100);
    static float playSpeed = 1.0f;
    if (ImGui::DragFloat("Speed", &playSpeed, 0.01f, -2.0f, 2.0f, "%.2fx")) {
        animation_->SetPlaySpeed(playSpeed);
    }

    ImGui::PopStyleVar();

    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆã‚¹ã‚¯ãƒ©ãƒ–ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½ä»˜ãï¼‰
    float displayTime = animation_->GetPlaybackTime();
    float duration = animation_->GetDuration();
    if (duration > 0.0f) {
        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯èƒŒæ™¯è‰²ã‚’å¤‰æ›´
        if (enablePreview_ && timeline_ && (timeline_->IsKeyframePreviewActive() || timeline_->IsScrubbing())) {
            ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.1f, 0.2f, 0.4f, 1.0f));
        }

        if (ImGui::SliderFloat("##Timeline", &displayTime, 0.0f, duration, "%.2fs")) {
            if (enablePreview_) {
                if (ImGui::IsItemActive()) {
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã„ã‚‹æ™‚
                    // AnimationControllerãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ãªã„å ´åˆã¯ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
                    CameraManager* manager = CameraManager::GetInstance();
                    if (manager && manager->GetActiveControllerName() != "Animation") {
                        if (previousControllerName_.empty()) {
                            previousControllerName_ = manager->GetActiveControllerName();
                        }
                        manager->DeactivateAllControllers();
                        manager->ActivateController("Animation");
                    }
                    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã§ã‚¹ã‚¯ãƒ©ãƒ–å‡¦ç†ãŒè¡Œã‚ã‚Œã‚‹
                }
            }
        }

        if (enablePreview_ && timeline_ && (timeline_->IsKeyframePreviewActive() || timeline_->IsScrubbing())) {
            ImGui::PopStyleColor();
        }
    }
}

void CameraAnimationEditor::DrawTimelinePanel() {
    if (!animation_) {
        ImGui::Text("No animation loaded");
        return;
    }

    if (timeline_) {
        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        if (ImGui::Checkbox("Enable Preview", &enablePreview_)) {
            if (enablePreview_) {
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹ï¼šç¾åœ¨ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’è¨˜æ†¶ã—ã¦AnimationControllerã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
                CameraManager* manager = CameraManager::GetInstance();
                if (manager) {
                    previousControllerName_ = manager->GetActiveControllerName();
                    manager->DeactivateAllControllers();
                    manager->ActivateController("Animation");
                }
            }
            else {
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼çµ‚äº†ï¼šå…ƒã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã«æˆ»ã™
                CameraManager* manager = CameraManager::GetInstance();
                if (manager) {
                    manager->DeactivateAllControllers();
                    if (!previousControllerName_.empty()) {
                        manager->ActivateController(previousControllerName_);
                    }
                }
            }
        }

        // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’é€šçŸ¥
        timeline_->SetPreviewMode(enablePreview_);

        // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«æç”»ã‚’å§”è­²
        timeline_->Draw();

        // é¸æŠžçŠ¶æ…‹ã‚’åŒæœŸ
        selectedKeyframes_ = timeline_->GetSelectedKeyframes();
        hoveredKeyframe_ = timeline_->GetHoveredKeyframe();
        isDragging_ = timeline_->IsDragging();
    }
}

void CameraAnimationEditor::DrawInspectorPanel() {
    ImGui::Text("Inspector");
    ImGui::Separator();

    if (!animation_) {
        ImGui::TextDisabled("No animation loaded");
        return;
    }

    // Start Mode Settings ã‚»ã‚¯ã‚·ãƒ§ãƒ³
    if (ImGui::CollapsingHeader("Start Mode Settings", ImGuiTreeNodeFlags_DefaultOpen)) {
        // é–‹å§‹ãƒ¢ãƒ¼ãƒ‰é¸æŠž
        const char* startModes[] = { "Jump Cut", "Smooth Blend" };
        int startModeIndex = static_cast<int>(animation_->GetStartMode());
        if (ImGui::Combo("Start Mode", &startModeIndex, startModes, 2)) {
            animation_->SetStartMode(static_cast<CameraAnimation::StartMode>(startModeIndex));
        }

        // é–‹å§‹ãƒ¢ãƒ¼ãƒ‰ã®èª¬æ˜Ž
        if (startModeIndex == 0) {
            ImGui::TextWrapped("Jump Cut: Instantly moves to the first keyframe when playback starts.");
        }
        else {
            ImGui::TextWrapped("Smooth Blend: Smoothly transitions from current camera position to the first keyframe.");
        }

        // SMOOTH_BLENDã®å ´åˆã€ãƒ–ãƒ¬ãƒ³ãƒ‰æ™‚é–“è¨­å®š
        if (animation_->GetStartMode() == CameraAnimation::StartMode::SMOOTH_BLEND) {
            float blendDuration = animation_->GetBlendDuration();
            if (ImGui::DragFloat("Blend Duration (sec)", &blendDuration, 0.01f, 0.1f, 2.0f)) {
                animation_->SetBlendDuration(blendDuration);
            }

            // ãƒ–ãƒ¬ãƒ³ãƒ‰ä¸­ã®é€²è¡ŒçŠ¶æ³è¡¨ç¤º
            if (animation_->IsBlending()) {
                ImGui::ProgressBar(animation_->GetBlendProgress(), ImVec2(-1, 0), "Blending...");
            }
        }

        ImGui::Separator();
    }

    // Target Settingsã‚»ã‚¯ã‚·ãƒ§ãƒ³
    if (ImGui::CollapsingHeader("Target Settings", ImGuiTreeNodeFlags_DefaultOpen)) {
        // ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¡¨ç¤º
        ImGui::Text("Current Target: ");
        ImGui::SameLine();
        if (targetTransform_) {
            ImGui::TextColored(ImVec4(0.2f, 0.8f, 0.2f, 1.0f), "%s", targetName_.c_str());
        }
        else {
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1.0f), "None");
        }

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®šãƒœã‚¿ãƒ³
        if (ImGui::Button("Set Target")) {
            // å®Ÿéš›ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®šã¯ã‚²ãƒ¼ãƒ å´ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹
            // ã“ã“ã§ã¯UIã®èª¬æ˜Žã®ã¿
            ImGui::OpenPopup("TargetSetHelp");
        }
        ImGui::SameLine();
        if (ImGui::Button("Clear Target")) {
            SetTarget(nullptr, "None");
        }

        // ãƒ˜ãƒ«ãƒ—ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—
        if (ImGui::BeginPopup("TargetSetHelp")) {
            ImGui::Text("To set a target:");
            ImGui::BulletText("Call SetTarget() from game code");
            ImGui::BulletText("Pass the target's Transform pointer");
            ImGui::Separator();
            ImGui::TextWrapped("When Target Relative mode is active, keyframe positions will be interpreted as offsets from the target.");
            ImGui::EndPopup();
        }

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç›¸å¯¾ãƒ¢ãƒ¼ãƒ‰ã®èª¬æ˜Ž
        if (targetTransform_) {
            ImGui::TextWrapped("Target is set. Keyframes with TARGET_RELATIVE coordinate type will use this target as reference.");
        }
        else {
            ImGui::TextColored(ImVec4(0.8f, 0.8f, 0.2f, 1.0f),
                "No target set. TARGET_RELATIVE keyframes will use world coordinates.");
        }

        ImGui::Separator();
    }

    // æ–°è¦è¿½åŠ ï¼šã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ ã‚»ã‚¯ã‚·ãƒ§ãƒ³
    if (ImGui::CollapsingHeader("Add New Keyframe")) {
        static float newKeyTime = 0.0f;
        static int coordTypeIndex = 0; // 0: WORLD, 1: TARGET_RELATIVE

        ImGui::DragFloat("Time (seconds)", &newKeyTime, 0.01f, 0.0f, 10.0f);

        // åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—é¸æŠž
        const char* coordTypes[] = { "World", "Target Relative" };
        ImGui::Combo("Coordinate Type##AddFrame", &coordTypeIndex, coordTypes, 2);

        // TARGET_RELATIVEãƒ¢ãƒ¼ãƒ‰é¸æŠžæ™‚ã®è­¦å‘Š
        if (coordTypeIndex == 1 && !targetTransform_) {
            ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.2f, 1.0f),
                "Warning: No target set. Will use world coordinates.");
        }

        if (ImGui::Button("Add from Current Camera")) {
            if (camera_) {
                CameraKeyframe newKf;
                newKf.time = enableGridSnap_ ? SnapToGrid(newKeyTime) : newKeyTime;

                // åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ä½ç½®ã‚’è¨­å®š
                if (coordTypeIndex == 1 && targetTransform_) {
                    // TARGET_RELATIVEãƒ¢ãƒ¼ãƒ‰: ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ä½ç½®ã‹ã‚‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’å¼•ã„ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
                    newKf.position = Vec3::Subtract(camera_->GetTranslate(), targetTransform_->translate);
                }
                else {
                    // WORLDãƒ¢ãƒ¼ãƒ‰: ãã®ã¾ã¾ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ä½¿ç”¨
                    newKf.position = camera_->GetTranslate();
                }

                newKf.rotation = camera_->GetRotate();
                newKf.fov = camera_->GetFovY();
                newKf.interpolation = CameraKeyframe::InterpolationType::LINEAR;
                newKf.coordinateType = static_cast<CameraKeyframe::CoordinateType>(coordTypeIndex);

                animation_->AddKeyframe(newKf);
                if (history_) {
                    history_->RecordAdd(animation_->GetKeyframeCount() - 1);
                }

                // æ™‚é–“ã‚’æ¬¡ã®ãƒã‚¤ãƒ³ãƒˆã«è‡ªå‹•ã§é€²ã‚ã‚‹
                newKeyTime = newKeyTime + 1.0f;
            }
            else {
                ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Camera not available");
            }
        }

        ImGui::SameLine();
        if (ImGui::Button("Add Default")) {
            CameraKeyframe defaultKf;
            defaultKf.time = enableGridSnap_ ? SnapToGrid(newKeyTime) : newKeyTime;
            defaultKf.position = Vector3(0.0f, 5.0f, -10.0f); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ï¼ˆã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
            defaultKf.rotation = Vector3(0.2f, 0.0f, 0.0f);
            defaultKf.fov = 45.0f * 3.14159265f / 180.0f;
            defaultKf.interpolation = CameraKeyframe::InterpolationType::LINEAR;
            defaultKf.coordinateType = static_cast<CameraKeyframe::CoordinateType>(coordTypeIndex);

            animation_->AddKeyframe(defaultKf);
            if (history_) {
                history_->RecordAdd(animation_->GetKeyframeCount() - 1);
            }

            newKeyTime = newKeyTime + 1.0f;
        }

        ImGui::Separator();
    }

    if (ImGui::CollapsingHeader("Keyframe Param")) {

        // é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æƒ…å ±
        if (selectedKeyframes_.empty()) {
            ImGui::TextDisabled("No keyframe selected");
            return;
        }

        if (selectedKeyframes_.size() == 1) {
            // å˜ä¸€é¸æŠž
            int idx = selectedKeyframes_[0];
            if (idx >= 0 && idx < static_cast<int>(animation_->GetKeyframeCount())) {
                CameraKeyframe kf = animation_->GetKeyframe(idx);
                bool changed = false;

                ImGui::Text("Keyframe %d", idx);
                ImGui::Separator();

                // æ™‚é–“
                if (ImGui::DragFloat("Time", &kf.time, 0.01f, 0.0f, animation_->GetDuration())) {
                    if (enableGridSnap_) {
                        kf.time = SnapToGrid(kf.time);
                    }
                    changed = true;
                }

                // åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—
                const char* coordTypes[] = { "World", "Target Relative" };
                int currentCoordType = static_cast<int>(kf.coordinateType);
                if (ImGui::Combo("Coordinate Type##FrameParam", &currentCoordType, coordTypes, 2)) {
                    kf.coordinateType = static_cast<CameraKeyframe::CoordinateType>(currentCoordType);
                    changed = true;
                }

                // TARGET_RELATIVEãƒ¢ãƒ¼ãƒ‰ã®èª¬æ˜Ž
                if (kf.coordinateType == CameraKeyframe::CoordinateType::TARGET_RELATIVE) {
                    if (targetTransform_) {
                        ImGui::TextColored(ImVec4(0.2f, 0.8f, 0.8f, 1.0f), "Position is offset from target");
                    }
                    else {
                        ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.2f, 1.0f), "No target! Using world coordinates");
                    }
                }

                // ä½ç½®
                const char* posLabel = (kf.coordinateType == CameraKeyframe::CoordinateType::TARGET_RELATIVE)
                    ? "Position (Offset)" : "Position";
                if (ImGui::DragFloat3(posLabel, &kf.position.x, 0.1f)) {
                    changed = true;
                }

                // å›žè»¢ï¼ˆåº¦å˜ä½ï¼‰
                Vector3 rotDeg = {
                    kf.rotation.x * 180.0f / 3.14159265f,
                    kf.rotation.y * 180.0f / 3.14159265f,
                    kf.rotation.z * 180.0f / 3.14159265f
                };
                if (ImGui::DragFloat3("Rotation", &rotDeg.x, 1.0f)) {
                    kf.rotation = {
                        rotDeg.x * 3.14159265f / 180.0f,
                        rotDeg.y * 3.14159265f / 180.0f,
                        rotDeg.z * 3.14159265f / 180.0f
                    };
                    changed = true;
                }

                // FOVï¼ˆåº¦å˜ä½ï¼‰
                float fovDeg = kf.fov * 180.0f / 3.14159265f;
                if (ImGui::DragFloat("FOV", &fovDeg, 0.5f, 10.0f, 120.0f)) {
                    kf.fov = fovDeg * 3.14159265f / 180.0f;
                    changed = true;
                }

                // è£œé–“ã‚¿ã‚¤ãƒ—
                const char* interpTypes[] = { "Linear", "Ease In", "Ease Out", "Ease In-Out" };
                int currentType = static_cast<int>(kf.interpolation);
                if (ImGui::Combo("Interpolation", &currentType, interpTypes, 4)) {
                    kf.interpolation = static_cast<CameraKeyframe::InterpolationType>(currentType);
                    changed = true;
                }

                if (changed) {
                    // å±¥æ­´ã«è¨˜éŒ²ã—ã¦ã‹ã‚‰ç·¨é›†
                    if (history_) {
                        history_->RecordEdit(idx, animation_->GetKeyframe(idx), kf);
                    }
                    animation_->EditKeyframe(idx, kf);
                }

                // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©çŠ¶æ…‹ã‚’é©ç”¨ãƒœã‚¿ãƒ³
                if (ImGui::Button("Apply Current Camera")) {
                    if (camera_) {
                        // åº§æ¨™ç³»ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ä½ç½®ã‚’è¨­å®š
                        if (kf.coordinateType == CameraKeyframe::CoordinateType::TARGET_RELATIVE && targetTransform_) {
                            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç›¸å¯¾: ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ã—ã¦è¨ˆç®—
                            kf.position = Vec3::Subtract(camera_->GetTranslate(), targetTransform_->translate);
                        }
                        else {
                            // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™: ãã®ã¾ã¾ä½¿ç”¨
                            kf.position = camera_->GetTranslate();
                        }
                        kf.rotation = camera_->GetRotate();
                        kf.fov = camera_->GetFovY();
                        animation_->EditKeyframe(idx, kf);
                    }
                }

                // å‰Šé™¤ãƒœã‚¿ãƒ³ï¼ˆèµ¤è‰²ã§å¼·èª¿ï¼‰
                ImGui::Spacing();
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.9f, 0.3f, 0.3f, 1.0f));
                ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(1.0f, 0.1f, 0.1f, 1.0f));
                if (ImGui::Button("Delete Keyframe", ImVec2(-1, 0))) {
                    DeleteSelectedKeyframes();
                }
                ImGui::PopStyleColor(3);
            }
        }
        else {
            // è¤‡æ•°é¸æŠž
            ImGui::Text("%d keyframes selected", static_cast<int>(selectedKeyframes_.size()));
            ImGui::Separator();

            // ä¸€æ‹¬æ“ä½œ
            static Vector3 offsetPos = { 0, 0, 0 };
            if (ImGui::DragFloat3("Offset Position", &offsetPos.x, 0.1f)) {
                // é©ç”¨ãƒœã‚¿ãƒ³ã§å®Ÿè¡Œ
            }

            if (ImGui::Button("Apply Offset")) {
                for (int idx : selectedKeyframes_) {
                    if (idx >= 0 && idx < static_cast<int>(animation_->GetKeyframeCount())) {
                        CameraKeyframe kf = animation_->GetKeyframe(idx);
                        kf.position.x += offsetPos.x;
                        kf.position.y += offsetPos.y;
                        kf.position.z += offsetPos.z;
                        animation_->EditKeyframe(idx, kf);
                    }
                }
                offsetPos = { 0, 0, 0 };
            }

            // å‰Šé™¤ãƒœã‚¿ãƒ³ï¼ˆè¤‡æ•°é¸æŠžæ™‚ã€èµ¤è‰²ã§å¼·èª¿ï¼‰
            ImGui::Spacing();
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.9f, 0.3f, 0.3f, 1.0f));
            ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(1.0f, 0.1f, 0.1f, 1.0f));
            if (ImGui::Button("Delete Selected Keyframes", ImVec2(-1, 0))) {
                DeleteSelectedKeyframes();
            }
            ImGui::PopStyleColor(3);
        }
    }
}

void CameraAnimationEditor::DrawCurveEditorPanel() {
    if (curveEditor_) {
        curveEditor_->Draw(selectedKeyframes_);
    }
}

void CameraAnimationEditor::DrawStatusBar() {
    ImGui::Separator();

    if (!animation_) {
        ImGui::Text("Status: No animation loaded - Add keyframes to begin");
        return;
    }

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º
    if (enablePreview_ && timeline_ && (timeline_->IsKeyframePreviewActive() || timeline_->IsScrubbing())) {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.2f, 1.0f, 0.8f, 1.0f));
        ImGui::Text("[PREVIEW MODE]");
        ImGui::PopStyleColor();
        ImGui::SameLine();
    }

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æƒ…å ±
    const char* modeNames[] = { "Select", "Move", "Scale", "Add", "Delete", "Scrub" };
    const char* modeHelp[] = {
        "Click keyframes to select",
        "Drag selected keyframes to move",
        "Drag to scale timing",
        "Double-click timeline to add keyframe",
        "Select and press Delete key",
        "Drag to preview animation"
    };

    // çµ±è¨ˆæƒ…å ±
    ImGui::Text("Keyframes: %zu | Selected: %zu | Snap: %s (%.2fs)",
        animation_->GetKeyframeCount(),
        selectedKeyframes_.size(),
        enableGridSnap_ ? "ON" : "OFF",
        gridSnapInterval_);
}


float CameraAnimationEditor::SnapToGrid(float time) const {
    if (!enableGridSnap_) {
        return time;
    }
    return std::round(time / gridSnapInterval_) * gridSnapInterval_;
}

void CameraAnimationEditor::CopySelectedKeyframes() {
    clipboard_.clear();
    for (int idx : selectedKeyframes_) {
        if (idx >= 0 && idx < static_cast<int>(animation_->GetKeyframeCount())) {
            clipboard_.push_back(animation_->GetKeyframe(idx));
        }
    }
}

void CameraAnimationEditor::PasteKeyframes() {
    if (clipboard_.empty()) {
        return;
    }

    float currentTime = animation_->GetPlaybackTime();
    float minTime = clipboard_[0].time;

    // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å†…ã®æœ€å°æ™‚é–“ã‚’åŸºæº–ã«ãƒšãƒ¼ã‚¹ãƒˆ
    for (const auto& kf : clipboard_) {
        CameraKeyframe newKf = kf;
        newKf.time = currentTime + (kf.time - minTime);

        if (history_) {
            history_->RecordAdd(animation_->GetKeyframeCount());
        }
        animation_->AddKeyframe(newKf);
    }
}

void CameraAnimationEditor::DeleteSelectedKeyframes() {
    if (selectedKeyframes_.empty()) {
        return;
    }

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é™é †ã«ã‚½ãƒ¼ãƒˆï¼ˆå¾Œã‚ã‹ã‚‰å‰Šé™¤ã™ã‚‹ãŸã‚ï¼‰
    std::sort(selectedKeyframes_.rbegin(), selectedKeyframes_.rend());

    for (int idx : selectedKeyframes_) {
        if (idx >= 0 && idx < static_cast<int>(animation_->GetKeyframeCount())) {
            if (history_) {
                history_->RecordDelete(idx, animation_->GetKeyframe(idx));
            }
            animation_->RemoveKeyframe(idx);
        }
    }

    selectedKeyframes_.clear();
}

void CameraAnimationEditor::Undo() {
    if (history_ && history_->CanUndo()) {
        history_->Undo();
    }
}

void CameraAnimationEditor::Redo() {
    if (history_ && history_->CanRedo()) {
        history_->Redo();
    }
}

void CameraAnimationEditor::DrawAnimationSelector() {
    if (!controller_) return;

    ImGui::Separator();

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é¸æŠžã‚³ãƒ³ãƒœãƒœãƒƒã‚¯ã‚¹
    auto animList = controller_->GetAnimationList();
    std::string currentName = controller_->GetCurrentAnimationName();

    ImGui::Text("Animation:");
    ImGui::SameLine();
    ImGui::SetNextItemWidth(200);
    if (ImGui::BeginCombo("##AnimSelect", currentName.c_str())) {
        for (const auto& name : animList) {
            bool isSelected = (name == currentName);
            if (ImGui::Selectable(name.c_str(), isSelected)) {
                if (controller_->SwitchAnimation(name)) {
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ‡ã‚Šæ›¿ãˆæˆåŠŸ
                    animation_ = controller_->GetCurrentAnimation();

                    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å†åˆæœŸåŒ–
                    if (animation_) {
                        // é‡è¦ï¼šåˆ‡ã‚Šæ›¿ãˆå¾Œã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚‚ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
                        animation_->SetCamera(camera_);

                        timeline_->Initialize(animation_);
                        curveEditor_->Initialize(animation_);
                        history_->Initialize(animation_);

                        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæƒ…å ±ã‚’æ›´æ–°
                        targetTransform_ = animation_->GetTarget();
                        targetName_ = targetTransform_ ? (name + " Target") : "None";
                    }
                }
            }
            if (isSelected) {
                ImGui::SetItemDefaultFocus();
            }
        }
        ImGui::EndCombo();
    }

    ImGui::SameLine();

    // æ–°è¦ä½œæˆãƒœã‚¿ãƒ³
    if (ImGui::Button("New")) {
        ImGui::OpenPopup("NewAnimation");
    }

    ImGui::SameLine();

    // è¤‡è£½ãƒœã‚¿ãƒ³
    if (ImGui::Button("Duplicate")) {
        std::string newName = currentName + "_copy";
        if (controller_->DuplicateAnimation(currentName, newName)) {
            controller_->SwitchAnimation(newName);
            animation_ = controller_->GetCurrentAnimation();
            // é‡è¦ï¼šè¤‡è£½ã—ãŸã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚‚ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
            if (animation_) {
                animation_->SetCamera(camera_);
            }
        }
    }

    ImGui::SameLine();

    // å‰Šé™¤ãƒœã‚¿ãƒ³
    if (currentName != "Default") {
        if (ImGui::Button("Delete")) {
            ImGui::OpenPopup("DeleteAnimation");
        }
    }

    ImGui::SameLine();

    // ä¿å­˜ãƒœã‚¿ãƒ³
    if (ImGui::Button("Save")) {
        std::string fileName = currentName;
        controller_->SaveAnimationToFile(fileName);
    }

    ImGui::SameLine();

    // èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³
    if (ImGui::Button("Load")) {
        ImGui::OpenPopup("LoadAnimation");
    }

    // æ–°è¦ä½œæˆãƒ€ã‚¤ã‚¢ãƒ­ã‚°
    if (ImGui::BeginPopup("NewAnimation")) {
        static char nameBuf[128] = "NewAnimation";
        ImGui::Text("Animation Name:");
        ImGui::InputText("##Name", nameBuf, sizeof(nameBuf));

        if (ImGui::Button("Create")) {
            if (controller_->CreateAnimation(nameBuf)) {
                controller_->SwitchAnimation(nameBuf);
                animation_ = controller_->GetCurrentAnimation();
                // é‡è¦ï¼šæ–°è¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚‚ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
                if (animation_) {
                    animation_->SetCamera(camera_);
                }
            }
            ImGui::CloseCurrentPopup();
        }

        ImGui::SameLine();
        if (ImGui::Button("Cancel")) {
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }

    // å‰Šé™¤ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
    if (ImGui::BeginPopup("DeleteAnimation")) {
        ImGui::Text("Delete animation '%s'?", currentName.c_str());
        ImGui::Text("This action cannot be undone.");

        if (ImGui::Button("Delete", ImVec2(120, 0))) {
            controller_->DeleteAnimation(currentName);
            animation_ = controller_->GetCurrentAnimation();
            // é‡è¦ï¼šå‰Šé™¤å¾Œã®ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚‚ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
            if (animation_) {
                animation_->SetCamera(camera_);
            }
            ImGui::CloseCurrentPopup();
        }

        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }

    // èª­ã¿è¾¼ã¿ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
    if (ImGui::BeginPopup("LoadAnimation")) {
        static char nameBuf[128] = "LoadedAnimation";
        static char pathBuf[256] = "resources/CameraAnimations/";

        ImGui::Text("Animation Name:");
        ImGui::InputText("##LoadName", nameBuf, sizeof(nameBuf));

        if (ImGui::Button("Load")) {
            if (controller_->LoadAnimationFromFile(nameBuf)) {
                controller_->SwitchAnimation(nameBuf);
                animation_ = controller_->GetCurrentAnimation();
                // é‡è¦ï¼šèª­ã¿è¾¼ã‚“ã ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚‚ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
                if (animation_) {
                    animation_->SetCamera(camera_);
                }
            }
            ImGui::CloseCurrentPopup();
        }

        ImGui::SameLine();
        if (ImGui::Button("Cancel")) {
            ImGui::CloseCurrentPopup();
        }

        ImGui::EndPopup();
    }

    ImGui::Separator();
}

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraAnimationEditor/CameraAnimationEditor.h
============================================================
#pragma once

#ifdef _DEBUG

#include "CameraAnimation/CameraAnimation.h"
#include "CameraAnimation/CameraKeyframe.h"
#include "Camera.h"
#include <memory>
#include <vector>

// Forward declarations
class CameraAnimationTimeline;
class CameraAnimationCurveEditor;
class CameraAnimationHistory;

/// <summary>
/// é«˜åº¦ãªã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
/// ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç·¨é›†æ©Ÿèƒ½ã‚’æä¾›
/// </summary>
class CameraAnimationEditor {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    CameraAnimationEditor();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~CameraAnimationEditor();

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    /// <param name="animation">ç·¨é›†å¯¾è±¡ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</param>
    /// <param name="camera">ã‚«ãƒ¡ãƒ©</param>
    void Initialize(CameraAnimation* animation, Camera* camera);

    /// <summary>
    /// åˆæœŸåŒ–ï¼ˆCameraAnimationControllerä½¿ç”¨ï¼‰
    /// </summary>
    /// <param name="controller">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼</param>
    /// <param name="camera">ã‚«ãƒ¡ãƒ©</param>
    void Initialize(class CameraAnimationController* controller, Camera* camera);

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼UIã®æç”»
    /// </summary>
    void Draw();

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
    void Update(float deltaTime);

    /// <summary>
    /// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆå‡¦ç†
    /// </summary>
    void ProcessShortcuts();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’é–‹ã
    /// </summary>
    void Open() { isOpen_ = true; }

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’é–‰ã˜ã‚‹
    /// </summary>
    void Close() { isOpen_ = false; }

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒé–‹ã„ã¦ã„ã‚‹ã‹
    /// </summary>
    bool IsOpen() const { return isOpen_; }

    /// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¨­å®š
    /// </summary>
    /// <param name="target">ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ </param>
    /// <param name="name">ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåï¼ˆè¡¨ç¤ºç”¨ï¼‰</param>
    void SetTarget(const Transform* target, const std::string& name = "");

    /// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’å–å¾—
    /// </summary>
    const Transform* GetTarget() const { return targetTransform_; }

private:
    /// <summary>
    /// ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®æç”»
    /// </summary>
    void DrawMenuBar();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é¸æŠžUIã®æç”»
    /// </summary>
    void DrawAnimationSelector();

    /// <summary>
    /// ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ‘ãƒãƒ«ã®æç”»
    /// </summary>
    void DrawTimelinePanel();

    /// <summary>
    /// ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ãƒ‘ãƒãƒ«ã®æç”»
    /// </summary>
    void DrawInspectorPanel();

    /// <summary>
    /// ã‚«ãƒ¼ãƒ–ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ‘ãƒãƒ«ã®æç”»
    /// </summary>
    void DrawCurveEditorPanel();

    /// <summary>
    /// ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã®æç”»
    /// </summary>
    void DrawStatusBar();

    /// <summary>
    /// å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®æç”»
    /// </summary>
    void DrawPlaybackControls();

    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—ã®å‡¦ç†
    /// </summary>
    /// <param name="time">å…¥åŠ›æ™‚é–“</param>
    /// <returns>ã‚¹ãƒŠãƒƒãƒ—å¾Œã®æ™‚é–“</returns>
    float SnapToGrid(float time) const;

    /// <summary>
    /// ã‚³ãƒ”ãƒ¼å‡¦ç†
    /// </summary>
    void CopySelectedKeyframes();

    /// <summary>
    /// ãƒšãƒ¼ã‚¹ãƒˆå‡¦ç†
    /// </summary>
    void PasteKeyframes();

    /// <summary>
    /// å‰Šé™¤å‡¦ç†
    /// </summary>
    void DeleteSelectedKeyframes();

    /// <summary>
    /// ã‚¢ãƒ³ãƒ‰ã‚¥å‡¦ç†
    /// </summary>
    void Undo();

    /// <summary>
    /// ãƒªãƒ‰ã‚¥å‡¦ç†
    /// </summary>
    void Redo();

private:
    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼çŠ¶æ…‹
    bool isOpen_ = false;                        ///< ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒé–‹ã„ã¦ã„ã‚‹ã‹

    // ç·¨é›†å¯¾è±¡
    CameraAnimation* animation_ = nullptr;       ///< ç·¨é›†ä¸­ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    Camera* camera_ = nullptr;                   ///< ã‚«ãƒ¡ãƒ©
    class CameraAnimationController* controller_ = nullptr; ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ï¼ˆè¤‡æ•°ç®¡ç†ç”¨ï¼‰

    // UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    std::unique_ptr<CameraAnimationTimeline> timeline_;     ///< ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    std::unique_ptr<CameraAnimationCurveEditor> curveEditor_; ///< ã‚«ãƒ¼ãƒ–ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
    std::unique_ptr<CameraAnimationHistory> history_;        ///< ç·¨é›†å±¥æ­´

    // é¸æŠžçŠ¶æ…‹
    std::vector<int> selectedKeyframes_;         ///< é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    int hoveredKeyframe_ = -1;                   ///< ãƒ›ãƒãƒ¼ä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 

    // ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹
    bool isDragging_ = false;                    ///< ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‹
    std::vector<float> dragStartTimes_;          ///< ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®å„ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“

    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¨­å®š
    float gridSnapInterval_ = 0.1f;              ///< ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—é–“éš”
    bool enableGridSnap_ = true;                 ///< ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—æœ‰åŠ¹åŒ–

    // ã‚³ãƒ”ãƒ¼ãƒãƒƒãƒ•ã‚¡
    std::vector<CameraKeyframe> clipboard_;      ///< ã‚³ãƒ”ãƒ¼ã—ãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½
    bool enablePreview_ = false;                  ///< ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹åŒ–
    std::string previousControllerName_;         ///< ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‰ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š
    const Transform* targetTransform_ = nullptr;  ///< ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
    std::string targetName_ = "None";            ///< ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåï¼ˆè¡¨ç¤ºç”¨ï¼‰
};

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraAnimationEditor/CameraAnimationHistory.cpp
============================================================
#ifdef _DEBUG

#include "CameraAnimationHistory.h"
#include <sstream>

// AddKeyframeActionå®Ÿè£…
void CameraAnimationHistory::AddKeyframeAction::Execute(CameraAnimation* animation) {
    animation->AddKeyframe(keyframe_);
}

void CameraAnimationHistory::AddKeyframeAction::Undo(CameraAnimation* animation) {
    animation->RemoveKeyframe(index_);
}

// DeleteKeyframeActionå®Ÿè£…
void CameraAnimationHistory::DeleteKeyframeAction::Execute(CameraAnimation* animation) {
    animation->RemoveKeyframe(index_);
}

void CameraAnimationHistory::DeleteKeyframeAction::Undo(CameraAnimation* animation) {
    animation->AddKeyframe(keyframe_);
}

// EditKeyframeActionå®Ÿè£…
void CameraAnimationHistory::EditKeyframeAction::Execute(CameraAnimation* animation) {
    animation->EditKeyframe(index_, newKeyframe_);
}

void CameraAnimationHistory::EditKeyframeAction::Undo(CameraAnimation* animation) {
    animation->EditKeyframe(index_, oldKeyframe_);
}

// CameraAnimationHistoryå®Ÿè£…
CameraAnimationHistory::CameraAnimationHistory() {
    history_.reserve(maxHistorySize_);
}

CameraAnimationHistory::~CameraAnimationHistory() {
    Clear();
}

void CameraAnimationHistory::Initialize(CameraAnimation* animation) {
    animation_ = animation;
    Clear();
}

void CameraAnimationHistory::ExecuteAction(std::unique_ptr<Action> action) {
    if (!animation_ || !action || isExecuting_) {
        return;
    }

    // å®Ÿè¡Œä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
    isExecuting_ = true;

    // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå¾Œã®å±¥æ­´ã‚’å‰Šé™¤
    if (currentIndex_ < history_.size()) {
        history_.erase(history_.begin() + currentIndex_, history_.end());
    }

    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
    action->Execute(animation_);

    // å±¥æ­´ã«è¿½åŠ 
    history_.push_back(std::move(action));
    currentIndex_ = history_.size();

    // å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™
    LimitHistorySize();

    isExecuting_ = false;
}

void CameraAnimationHistory::RecordAdd(size_t index) {
    if (!animation_ || index >= animation_->GetKeyframeCount()) {
        return;
    }

    auto action = std::make_unique<AddKeyframeAction>(
        animation_->GetKeyframe(index), index);

    // ExecuteActionã¯ä½¿ã‚ãªã„ï¼ˆæ—¢ã«è¿½åŠ æ¸ˆã¿ã®ãŸã‚ï¼‰
    if (currentIndex_ < history_.size()) {
        history_.erase(history_.begin() + currentIndex_, history_.end());
    }
    history_.push_back(std::move(action));
    currentIndex_ = history_.size();
    LimitHistorySize();
}

void CameraAnimationHistory::RecordDelete(size_t index, const CameraKeyframe& keyframe) {
    if (!animation_) {
        return;
    }

    auto action = std::make_unique<DeleteKeyframeAction>(keyframe, index);

    // ExecuteActionã¯ä½¿ã‚ãªã„ï¼ˆæ—¢ã«å‰Šé™¤æ¸ˆã¿ã®ãŸã‚ï¼‰
    if (currentIndex_ < history_.size()) {
        history_.erase(history_.begin() + currentIndex_, history_.end());
    }
    history_.push_back(std::move(action));
    currentIndex_ = history_.size();
    LimitHistorySize();
}

void CameraAnimationHistory::RecordEdit(size_t index, const CameraKeyframe& oldKf, const CameraKeyframe& newKf) {
    if (!animation_ || index >= animation_->GetKeyframeCount()) {
        return;
    }

    auto action = std::make_unique<EditKeyframeAction>(index, oldKf, newKf);

    // ExecuteActionã¯ä½¿ã‚ãªã„ï¼ˆæ—¢ã«ç·¨é›†æ¸ˆã¿ã®ãŸã‚ï¼‰
    if (currentIndex_ < history_.size()) {
        history_.erase(history_.begin() + currentIndex_, history_.end());
    }
    history_.push_back(std::move(action));
    currentIndex_ = history_.size();
    LimitHistorySize();
}

void CameraAnimationHistory::Undo() {
    if (!animation_ || !CanUndo() || isExecuting_) {
        return;
    }

    isExecuting_ = true;

    currentIndex_--;
    history_[currentIndex_]->Undo(animation_);

    isExecuting_ = false;
}

void CameraAnimationHistory::Redo() {
    if (!animation_ || !CanRedo() || isExecuting_) {
        return;
    }

    isExecuting_ = true;

    history_[currentIndex_]->Execute(animation_);
    currentIndex_++;

    isExecuting_ = false;
}

void CameraAnimationHistory::Clear() {
    history_.clear();
    currentIndex_ = 0;
}

void CameraAnimationHistory::LimitHistorySize() {
    if (history_.size() > maxHistorySize_) {
        size_t removeCount = history_.size() - maxHistorySize_;
        history_.erase(history_.begin(), history_.begin() + removeCount);

        if (currentIndex_ > removeCount) {
            currentIndex_ -= removeCount;
        } else {
            currentIndex_ = 0;
        }
    }
}

std::string CameraAnimationHistory::GetHistoryInfo() const {
    std::stringstream ss;
    ss << "History: " << currentIndex_ << "/" << history_.size() << "\n";

    for (size_t i = 0; i < history_.size(); ++i) {
        if (i == currentIndex_) {
            ss << "> ";
        } else {
            ss << "  ";
        }

        ss << i << ": " << history_[i]->GetDescription();

        if (i == currentIndex_ - 1) {
            ss << " <-- Current";
        }

        ss << "\n";
    }

    return ss.str();
}

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraAnimationEditor/CameraAnimationHistory.h
============================================================
#pragma once
#include "CameraAnimation/CameraAnimation.h"
#include "CameraAnimation/CameraKeyframe.h"
#include <vector>
#include <memory>
#include <string>

#ifdef _DEBUG

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ç·¨é›†å±¥æ­´ç®¡ç†
/// ã‚¢ãƒ³ãƒ‰ã‚¥/ãƒªãƒ‰ã‚¥æ©Ÿèƒ½ã‚’æä¾›
/// </summary>
class CameraAnimationHistory {
public:
    /// <summary>
    /// æ“ä½œã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class ActionType {
        ADD_KEYFRAME,       ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ 
        DELETE_KEYFRAME,    ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ å‰Šé™¤
        EDIT_KEYFRAME,      ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç·¨é›†
        MOVE_KEYFRAME,      ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç§»å‹•
        BULK_EDIT,          ///< ä¸€æ‹¬ç·¨é›†
        CLEAR_ALL           ///< å…¨æ¶ˆåŽ»
    };

    /// <summary>
    /// ç·¨é›†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®åŸºåº•ã‚¯ãƒ©ã‚¹
    /// </summary>
    class Action {
    public:
        virtual ~Action() = default;

        /// <summary>
        /// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œ
        /// </summary>
        virtual void Execute(CameraAnimation* animation) = 0;

        /// <summary>
        /// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å–ã‚Šæ¶ˆã—
        /// </summary>
        virtual void Undo(CameraAnimation* animation) = 0;

        /// <summary>
        /// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
        /// </summary>
        virtual ActionType GetType() const = 0;

        /// <summary>
        /// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®èª¬æ˜Žã‚’å–å¾—
        /// </summary>
        virtual std::string GetDescription() const = 0;
    };

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    /// </summary>
    class AddKeyframeAction : public Action {
    public:
        AddKeyframeAction(const CameraKeyframe& keyframe, size_t index)
            : keyframe_(keyframe), index_(index) {}

        void Execute(CameraAnimation* animation) override;
        void Undo(CameraAnimation* animation) override;
        ActionType GetType() const override { return ActionType::ADD_KEYFRAME; }
        std::string GetDescription() const override { return "Add Keyframe"; }

    private:
        CameraKeyframe keyframe_;
        size_t index_;
    };

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ å‰Šé™¤ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    /// </summary>
    class DeleteKeyframeAction : public Action {
    public:
        DeleteKeyframeAction(const CameraKeyframe& keyframe, size_t index)
            : keyframe_(keyframe), index_(index) {}

        void Execute(CameraAnimation* animation) override;
        void Undo(CameraAnimation* animation) override;
        ActionType GetType() const override { return ActionType::DELETE_KEYFRAME; }
        std::string GetDescription() const override { return "Delete Keyframe"; }

    private:
        CameraKeyframe keyframe_;
        size_t index_;
    };

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç·¨é›†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    /// </summary>
    class EditKeyframeAction : public Action {
    public:
        EditKeyframeAction(size_t index, const CameraKeyframe& oldKf, const CameraKeyframe& newKf)
            : index_(index), oldKeyframe_(oldKf), newKeyframe_(newKf) {}

        void Execute(CameraAnimation* animation) override;
        void Undo(CameraAnimation* animation) override;
        ActionType GetType() const override { return ActionType::EDIT_KEYFRAME; }
        std::string GetDescription() const override { return "Edit Keyframe"; }

    private:
        size_t index_;
        CameraKeyframe oldKeyframe_;
        CameraKeyframe newKeyframe_;
    };

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    CameraAnimationHistory();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~CameraAnimationHistory();

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    /// <param name="animation">å¯¾è±¡ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</param>
    void Initialize(CameraAnimation* animation);

    /// <summary>
    /// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®è¨˜éŒ²ã¨å®Ÿè¡Œ
    /// </summary>
    void ExecuteAction(std::unique_ptr<Action> action);

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ ã‚’è¨˜éŒ²
    /// </summary>
    void RecordAdd(size_t index);

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ å‰Šé™¤ã‚’è¨˜éŒ²
    /// </summary>
    void RecordDelete(size_t index, const CameraKeyframe& keyframe);

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç·¨é›†ã‚’è¨˜éŒ²
    /// </summary>
    void RecordEdit(size_t index, const CameraKeyframe& oldKf, const CameraKeyframe& newKf);

    /// <summary>
    /// ã‚¢ãƒ³ãƒ‰ã‚¥å®Ÿè¡Œ
    /// </summary>
    void Undo();

    /// <summary>
    /// ãƒªãƒ‰ã‚¥å®Ÿè¡Œ
    /// </summary>
    void Redo();

    /// <summary>
    /// ã‚¢ãƒ³ãƒ‰ã‚¥å¯èƒ½ã‹
    /// </summary>
    bool CanUndo() const { return currentIndex_ > 0; }

    /// <summary>
    /// ãƒªãƒ‰ã‚¥å¯èƒ½ã‹
    /// </summary>
    bool CanRedo() const { return currentIndex_ < history_.size(); }

    /// <summary>
    /// å±¥æ­´ã®ã‚¯ãƒªã‚¢
    /// </summary>
    void Clear();

    /// <summary>
    /// æœ€å¤§å±¥æ­´æ•°ã®è¨­å®š
    /// </summary>
    void SetMaxHistorySize(size_t size) { maxHistorySize_ = size; }

    /// <summary>
    /// ç¾åœ¨ã®å±¥æ­´æ•°ã‚’å–å¾—
    /// </summary>
    size_t GetHistorySize() const { return history_.size(); }

    /// <summary>
    /// ç¾åœ¨ã®å±¥æ­´ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    /// </summary>
    size_t GetCurrentIndex() const { return currentIndex_; }

    /// <summary>
    /// å±¥æ­´æƒ…å ±ã®å–å¾—ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    /// </summary>
    std::string GetHistoryInfo() const;

private:
    /// <summary>
    /// å±¥æ­´ã‚µã‚¤ã‚ºã®åˆ¶é™
    /// </summary>
    void LimitHistorySize();

private:
    CameraAnimation* animation_ = nullptr;                   ///< å¯¾è±¡ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    std::vector<std::unique_ptr<Action>> history_;          ///< ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å±¥æ­´
    size_t currentIndex_ = 0;                               ///< ç¾åœ¨ã®å±¥æ­´ä½ç½®
    size_t maxHistorySize_ = 100;                           ///< æœ€å¤§å±¥æ­´æ•°
    bool isExecuting_ = false;                              ///< ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œä¸­ãƒ•ãƒ©ã‚°
};

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraAnimationEditor/CameraAnimationTimeline.cpp
============================================================
#ifdef _DEBUG

#include "CameraAnimationTimeline.h"
#include <algorithm>
#include <cmath>

CameraAnimationTimeline::CameraAnimationTimeline() {
  // ãƒˆãƒ©ãƒƒã‚¯å¯è¦–æ€§ã®åˆæœŸåŒ–ï¼ˆã‚µãƒžãƒªãƒ¼ãƒˆãƒ©ãƒƒã‚¯ã®ã¿è¡¨ç¤ºï¼‰
  for (int i = 0; i < static_cast<int>(TrackType::COUNT); ++i) {
    trackVisible_[i] = (i == 0);  // SUMMARYã®ã¿true
  }
}

CameraAnimationTimeline::~CameraAnimationTimeline() {
}

void CameraAnimationTimeline::Initialize(CameraAnimation* animation) {
  animation_ = animation;
  selectedKeyframes_.clear();
  hoveredKeyframe_ = -1;
}

void CameraAnimationTimeline::Draw() {
  if (!animation_) return;

  ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
  ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));

  // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
  ImVec2 contentSize = ImGui::GetContentRegionAvail();
  if (contentSize.x < 100 || contentSize.y < 100) {
    ImGui::PopStyleVar(2);
    return;
  }

  if (ImGui::BeginChild("Timeline", ImVec2(contentSize.x, timelineHeight_), true,
    ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse)) {

    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImGui::GetContentRegionAvail();

    // èƒŒæ™¯
    drawList->AddRectFilled(canvasPos,
      ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y),
      IM_COL32(40, 40, 40, 255));

    // ã‚°ãƒªãƒƒãƒ‰æç”»
    DrawGrid();

    // ã‚¿ã‚¤ãƒ ãƒ«ãƒ¼ãƒ©ãƒ¼æç”»
    DrawTimeRuler();

    // ãƒˆãƒ©ãƒƒã‚¯æç”»
    float yPos = canvasPos.y + rulerHeight_;
    for (int i = 0; i < static_cast<int>(TrackType::COUNT); ++i) {
      if (trackVisible_[i]) {
        DrawTrack(static_cast<TrackType>(i), yPos);
        yPos += trackHeight_;
      }
    }

    // å†ç”Ÿãƒ˜ãƒƒãƒ‰æç”»
    DrawPlayhead();

    // é¸æŠžçŸ©å½¢æç”»
    if (isRectSelecting_) {
      DrawSelectionRect();
    }

    // ãƒžã‚¦ã‚¹å…¥åŠ›å‡¦ç†
    HandleMouseInput();

    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›å‡¦ç†
    HandleKeyboardInput();
  }
  ImGui::EndChild();

  ImGui::PopStyleVar(2);
}

void CameraAnimationTimeline::Update(float deltaTime) {
  // ãƒ›ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
  if (hoveredKeyframe_ >= 0) {
    hoverAnimTime_ += deltaTime * 3.0f;
  } else {
    hoverAnimTime_ = 0.0f;
  }

  if (isKeyframePreviewActive_)
  {
    animation_->SetCurrentTime(previewTime_);
  }
}

void CameraAnimationTimeline::SetTrackVisible(TrackType track, bool visible) {
  int index = static_cast<int>(track);
  if (index >= 0 && index < static_cast<int>(TrackType::COUNT)) {
    trackVisible_[index] = visible;
  }
}

void CameraAnimationTimeline::DrawTimeRuler() {
  ImDrawList* drawList = ImGui::GetWindowDrawList();
  ImVec2 canvasPos = ImGui::GetCursorScreenPos();
  ImVec2 canvasSize = ImGui::GetContentRegionAvail();

  // ãƒ«ãƒ¼ãƒ©ãƒ¼èƒŒæ™¯
  drawList->AddRectFilled(
    ImVec2(canvasPos.x + trackLabelWidth_, canvasPos.y),
    ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + rulerHeight_),
    IM_COL32(50, 50, 50, 255));

  // æ™‚é–“ãƒžãƒ¼ã‚«ãƒ¼
  float duration = animation_->GetDuration();
  float timeStep = 1.0f / zoom_;  // 1ç§’ã”ã¨ï¼ˆã‚ºãƒ¼ãƒ ã«å¿œã˜ã¦èª¿æ•´ï¼‰

  // é©åˆ‡ãªæ™‚é–“åˆ»ã¿ã‚’é¸æŠž
  if (timeStep < 0.1f) timeStep = 0.1f;
  else if (timeStep < 0.5f) timeStep = 0.5f;
  else if (timeStep < 1.0f) timeStep = 1.0f;
  else if (timeStep < 5.0f) timeStep = 5.0f;
  else timeStep = 10.0f;

  for (float time = 0; time <= duration + timeStep; time += timeStep) {
    float x = TimeToScreenX(time);
    if (x < trackLabelWidth_ || x > canvasSize.x) continue;

    // ä¸»ç›®ç››ã‚Š
    drawList->AddLine(
      ImVec2(canvasPos.x + x, canvasPos.y + rulerHeight_ - 10),
      ImVec2(canvasPos.x + x, canvasPos.y + rulerHeight_),
      IM_COL32(200, 200, 200, 255));

    // æ™‚é–“ãƒ©ãƒ™ãƒ«
    char label[32];
    snprintf(label, sizeof(label), "%.1f", time);
    drawList->AddText(
      ImVec2(canvasPos.x + x - 10, canvasPos.y + 2),
      IM_COL32(200, 200, 200, 255),
      label);

    // å‰¯ç›®ç››ã‚Šï¼ˆ0.1ç§’åˆ»ã¿ï¼‰
    if (timeStep >= 1.0f) {
      for (float subTime = time + 0.1f; subTime < time + timeStep && subTime <= duration; subTime += 0.1f) {
        float subX = TimeToScreenX(subTime);
        if (subX < trackLabelWidth_ || subX > canvasSize.x) continue;

        drawList->AddLine(
          ImVec2(canvasPos.x + subX, canvasPos.y + rulerHeight_ - 5),
          ImVec2(canvasPos.x + subX, canvasPos.y + rulerHeight_),
          IM_COL32(100, 100, 100, 255));
      }
    }
  }
}

void CameraAnimationTimeline::DrawGrid() {
  ImDrawList* drawList = ImGui::GetWindowDrawList();
  ImVec2 canvasPos = ImGui::GetCursorScreenPos();
  ImVec2 canvasSize = ImGui::GetContentRegionAvail();

  // åž‚ç›´ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆæ™‚é–“ï¼‰
  float timeStep = gridSnapInterval_;
  float duration = animation_->GetDuration();

  for (float time = 0; time <= duration + timeStep; time += timeStep) {
    float x = TimeToScreenX(time);
    if (x < trackLabelWidth_ || x > canvasSize.x) continue;

    drawList->AddLine(
      ImVec2(canvasPos.x + x, canvasPos.y + rulerHeight_),
      ImVec2(canvasPos.x + x, canvasPos.y + canvasSize.y),
      gridColor_, 1.0f);
  }

  // æ°´å¹³ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆãƒˆãƒ©ãƒƒã‚¯å¢ƒç•Œï¼‰
  float yPos = canvasPos.y + rulerHeight_;
  for (int i = 0; i < static_cast<int>(TrackType::COUNT); ++i) {
    if (trackVisible_[i]) {
      drawList->AddLine(
        ImVec2(canvasPos.x + trackLabelWidth_, yPos),
        ImVec2(canvasPos.x + canvasSize.x, yPos),
        gridColor_, 1.0f);
      yPos += trackHeight_;
    }
  }
}

void CameraAnimationTimeline::DrawPlayhead() {
  ImDrawList* drawList = ImGui::GetWindowDrawList();
  ImVec2 canvasPos = ImGui::GetCursorScreenPos();
  ImVec2 canvasSize = ImGui::GetContentRegionAvail();

  float currentTime = animation_->GetPlaybackTime();
  float x = TimeToScreenX(currentTime);

  if (x >= trackLabelWidth_ && x <= canvasSize.x) {
    // å†ç”Ÿãƒ˜ãƒƒãƒ‰æœ¬ä½“
    drawList->AddLine(
      ImVec2(canvasPos.x + x, canvasPos.y),
      ImVec2(canvasPos.x + x, canvasPos.y + canvasSize.y),
      playheadColor_, 2.0f);

    // å†ç”Ÿãƒ˜ãƒƒãƒ‰ãƒãƒ³ãƒ‰ãƒ«ï¼ˆä¸Šéƒ¨ï¼‰
    ImVec2 handlePoints[3] = {
        ImVec2(canvasPos.x + x - 5, canvasPos.y),
        ImVec2(canvasPos.x + x + 5, canvasPos.y),
        ImVec2(canvasPos.x + x, canvasPos.y + 10)
    };
    drawList->AddTriangleFilled(handlePoints[0], handlePoints[1], handlePoints[2], playheadColor_);
  }
}

void CameraAnimationTimeline::DrawTrack(TrackType trackType, float yPos) {
  ImDrawList* drawList = ImGui::GetWindowDrawList();
  ImVec2 canvasPos = ImGui::GetCursorScreenPos();
  ImVec2 canvasSize = ImGui::GetContentRegionAvail();

  // ãƒˆãƒ©ãƒƒã‚¯ãƒ©ãƒ™ãƒ«
  ImVec2 labelPos = ImVec2(canvasPos.x + 5, yPos + 5);
  drawList->AddText(labelPos, IM_COL32(200, 200, 200, 255), GetTrackName(trackType));

  // ãƒˆãƒ©ãƒƒã‚¯ãƒ©ãƒ™ãƒ«èƒŒæ™¯
  drawList->AddRectFilled(
    ImVec2(canvasPos.x, yPos),
    ImVec2(canvasPos.x + trackLabelWidth_, yPos + trackHeight_),
    IM_COL32(60, 60, 60, 255));

  // ãƒˆãƒ©ãƒƒã‚¯èƒŒæ™¯
  drawList->AddRectFilled(
    ImVec2(canvasPos.x + trackLabelWidth_, yPos),
    ImVec2(canvasPos.x + canvasSize.x, yPos + trackHeight_),
    IM_COL32(45, 45, 45, 255));

  // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æç”»
  for (size_t i = 0; i < animation_->GetKeyframeCount(); ++i) {
    const CameraKeyframe& kf = animation_->GetKeyframe(i);
    float x = TimeToScreenX(kf.time);

    if (x < trackLabelWidth_ || x > canvasSize.x) continue;

    bool isSelected = std::find(selectedKeyframes_.begin(),
      selectedKeyframes_.end(),
      static_cast<int>(i)) != selectedKeyframes_.end();
    bool isHovered = (hoveredKeyframe_ == static_cast<int>(i) && hoveredTrack_ == trackType);

    // SUMMARYãƒˆãƒ©ãƒƒã‚¯ã®å ´åˆã¯å…¨ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤º
    if (trackType == TrackType::SUMMARY) {
      DrawKeyframe(static_cast<int>(i), x, yPos + trackHeight_ / 2, isSelected, isHovered);
    }
    // å€‹åˆ¥ãƒˆãƒ©ãƒƒã‚¯ã®å ´åˆã¯å¯¾å¿œã™ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã¿è¡¨ç¤º
    else {
      // TODO: ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã”ã¨ã®å¤‰æ›´æ¤œå‡º
      DrawKeyframe(static_cast<int>(i), x, yPos + trackHeight_ / 2, isSelected, isHovered);
    }
  }
}

void CameraAnimationTimeline::DrawKeyframe(int index, float xPos, float yPos, bool isSelected, bool isHovered) {
  ImDrawList* drawList = ImGui::GetWindowDrawList();
  ImVec2 canvasPos = ImGui::GetCursorScreenPos();

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æžœ
  float scale = 1.0f;
  if (isHovered) {
    scale = 1.0f + 0.2f * std::sin(hoverAnimTime_);
  }
  if (isSelected) {
    scale *= 1.1f;
  }

  float size = keyframeSize_ * scale;

  // è‰²é¸æŠž
  ImU32 color = IM_COL32(150, 150, 255, 255);
  if (isSelected) {
    color = selectedColor_;
  } else if (isHovered) {
    color = hoveredColor_;
  }

  ImVec2 center = ImVec2(canvasPos.x + xPos, yPos);

  // ã‚¹ã‚¿ã‚¤ãƒ«ã«å¿œã˜ãŸæç”»
  switch (keyframeStyle_) {
  case KeyframeStyle::DIAMOND: {
    ImVec2 points[4] = {
        ImVec2(center.x, center.y - size),      // ä¸Š
        ImVec2(center.x + size, center.y),      // å³
        ImVec2(center.x, center.y + size),      // ä¸‹
        ImVec2(center.x - size, center.y)       // å·¦
    };
    drawList->AddConvexPolyFilled(points, 4, color);
    drawList->AddPolyline(points, 4, IM_COL32(255, 255, 255, 200), ImDrawFlags_Closed, 2.0f);
    break;
  }
  case KeyframeStyle::CIRCLE:
    drawList->AddCircleFilled(center, size, color);
    drawList->AddCircle(center, size, IM_COL32(255, 255, 255, 200), 0, 2.0f);
    break;

  case KeyframeStyle::SQUARE:
    drawList->AddRectFilled(
      ImVec2(center.x - size, center.y - size),
      ImVec2(center.x + size, center.y + size),
      color);
    drawList->AddRect(
      ImVec2(center.x - size, center.y - size),
      ImVec2(center.x + size, center.y + size),
      IM_COL32(255, 255, 255, 200), 0.0f, 0, 2.0f);
    break;

  case KeyframeStyle::TRIANGLE: {
    ImVec2 points[3] = {
        ImVec2(center.x, center.y - size),
        ImVec2(center.x + size, center.y + size),
        ImVec2(center.x - size, center.y + size)
    };
    drawList->AddTriangleFilled(points[0], points[1], points[2], color);
    drawList->AddTriangle(points[0], points[1], points[2],
      IM_COL32(255, 255, 255, 200), 2.0f);
    break;
  }
  }
}

void CameraAnimationTimeline::DrawSelectionRect() {
  ImDrawList* drawList = ImGui::GetWindowDrawList();

  ImU32 fillColor = IM_COL32(100, 150, 255, 50);
  ImU32 borderColor = IM_COL32(100, 150, 255, 200);

  drawList->AddRectFilled(dragStartPos_, dragCurrentPos_, fillColor);
  drawList->AddRect(dragStartPos_, dragCurrentPos_, borderColor);
}

void CameraAnimationTimeline::HandleMouseInput() {
  ImVec2 mousePos = ImGui::GetMousePos();
  ImVec2 canvasPos = ImGui::GetCursorScreenPos();
  ImVec2 canvasSize = ImGui::GetContentRegionAvail();

  // ãƒžã‚¦ã‚¹ãŒã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
  if (mousePos.x < canvasPos.x || mousePos.x > canvasPos.x + canvasSize.x ||
    mousePos.y < canvasPos.y || mousePos.y > canvasPos.y + canvasSize.y) {
    return;
  }

  // å·¦ã‚¯ãƒªãƒƒã‚¯
  if (ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
    float relX = mousePos.x - canvasPos.x;
    float relY = mousePos.y - canvasPos.y;

    // ã‚¿ã‚¤ãƒ ãƒ«ãƒ¼ãƒ©ãƒ¼ä¸Šã§ã‚¯ãƒªãƒƒã‚¯ â†’ ã‚¹ã‚¯ãƒ©ãƒ–é–‹å§‹
    if (relY < rulerHeight_) {
      isScrubbing_ = true;
      scrubTime_ = ScreenXToTime(relX);
      // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã§ãªã„å ´åˆã®ã¿SetCurrentTime()ã‚’å‘¼ã¶
      if (isPreviewModeEnabled_ && !isKeyframePreviewActive_) {
        animation_->SetCurrentTime(scrubTime_);
      }
    }
    // ãƒˆãƒ©ãƒƒã‚¯ä¸Šã§ã‚¯ãƒªãƒƒã‚¯
    else if (relX > trackLabelWidth_) {
      // ã©ã®ãƒˆãƒ©ãƒƒã‚¯ä¸Šã‹ã‚’åˆ¤å®š
      float trackY = rulerHeight_;
      for (int i = 0; i < static_cast<int>(TrackType::COUNT); ++i) {
        if (trackVisible_[i]) {
          if (relY >= trackY && relY < trackY + trackHeight_) {
            hoveredTrack_ = static_cast<TrackType>(i);
            break;
          }
          trackY += trackHeight_;
        }
      }

      // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
      int hitIndex = HitTestKeyframe(relX, relY, hoveredTrack_);

      if (hitIndex >= 0) {
        // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒãƒ’ãƒƒãƒˆ â†’ é¸æŠžå‡¦ç†
        if (ImGui::GetIO().KeyCtrl) {
          // Ctrl+ã‚¯ãƒªãƒƒã‚¯ï¼šãƒˆã‚°ãƒ«é¸æŠž
          auto it = std::find(selectedKeyframes_.begin(),
            selectedKeyframes_.end(), hitIndex);
          if (it != selectedKeyframes_.end()) {
            selectedKeyframes_.erase(it);
          } else {
            selectedKeyframes_.push_back(hitIndex);
          }
        } else if (ImGui::GetIO().KeyShift && !selectedKeyframes_.empty()) {
          // Shift+ã‚¯ãƒªãƒƒã‚¯ï¼šç¯„å›²é¸æŠž
          int lastSelected = selectedKeyframes_.back();
          int start = std::min<int>(lastSelected, hitIndex);
          int end = std::max<int>(lastSelected, hitIndex);
          for (int i = start; i <= end; ++i) {
            if (std::ranges::find(selectedKeyframes_, i) == selectedKeyframes_.end()) {
              selectedKeyframes_.push_back(i);
            }
          }
        } else {
          // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯ï¼šå˜ä¸€é¸æŠž
          selectedKeyframes_.clear();
          selectedKeyframes_.push_back(hitIndex);
        }

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ãªå ´åˆã€é¸æŠžã—ãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚é–“ã«ã‚¸ãƒ£ãƒ³ãƒ—
        if (isPreviewModeEnabled_ && hitIndex >= 0 &&
            hitIndex < static_cast<int>(animation_->GetKeyframeCount())) {
          const CameraKeyframe& kf = animation_->GetKeyframe(hitIndex);
          isKeyframePreviewActive_ = true;
          previewKeyframeIndex_ = hitIndex;
          previewTime_ = kf.time;
          animation_->SetCurrentTime(previewTime_);
        }

        // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
        isDragging_ = true;
        dragStartPos_ = mousePos;
        dragStartTimes_.clear();
        for (int idx : selectedKeyframes_) {
          if (idx >= 0 && idx < static_cast<int>(animation_->GetKeyframeCount())) {
            dragStartTimes_.push_back(animation_->GetKeyframe(idx).time);
          }
        }
      } else {
        // ç©ºç™½ã‚¯ãƒªãƒƒã‚¯ â†’ çŸ©å½¢é¸æŠžé–‹å§‹
        if (!ImGui::GetIO().KeyCtrl) {
          selectedKeyframes_.clear();
        }

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è§£é™¤
        if (isPreviewModeEnabled_) {
          isKeyframePreviewActive_ = false;
          previewKeyframeIndex_ = -1;
        }

        isRectSelecting_ = true;
        dragStartPos_ = mousePos;
        dragCurrentPos_ = mousePos;
      }
    }
  }

  // å·¦ãƒ‰ãƒ©ãƒƒã‚°
  if (ImGui::IsMouseDragging(ImGuiMouseButton_Left)) {
    if (isScrubbing_) {
      // ã‚¹ã‚¯ãƒ©ãƒ–ä¸­
      float relX = mousePos.x - canvasPos.x;
      scrubTime_ = ScreenXToTime(relX);
      scrubTime_ = std::max<float>(0.0f, std::min<float>(scrubTime_, animation_->GetDuration()));
      // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã§ãªã„å ´åˆã®ã¿SetCurrentTime()ã‚’å‘¼ã¶
      if (isPreviewModeEnabled_ && !isKeyframePreviewActive_) {
        animation_->SetCurrentTime(scrubTime_);
      }
    } else if (isDragging_) {
      // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ‰ãƒ©ãƒƒã‚°ä¸­
      ProcessKeyframeDrag();
    } else if (isRectSelecting_) {
      // çŸ©å½¢é¸æŠžä¸­
      dragCurrentPos_ = mousePos;
    }
  }

  // å·¦ãƒªãƒªãƒ¼ã‚¹
  if (ImGui::IsMouseReleased(ImGuiMouseButton_Left)) {
    if (isRectSelecting_) {
      ProcessRectSelection();
    }

    isScrubbing_ = false;
    isDragging_ = false;
    isRectSelecting_ = false;
    dragStartTimes_.clear();
  }

  // ãƒ›ãƒãƒ¼æ¤œå‡º
  if (!isDragging_ && !isRectSelecting_) {
    float relX = mousePos.x - canvasPos.x;
    float relY = mousePos.y - canvasPos.y;

    // ãƒˆãƒ©ãƒƒã‚¯åˆ¤å®š
    float trackY = rulerHeight_;
    hoveredTrack_ = TrackType::SUMMARY;
    for (int i = 0; i < static_cast<int>(TrackType::COUNT); ++i) {
      if (trackVisible_[i]) {
        if (relY >= trackY && relY < trackY + trackHeight_) {
          hoveredTrack_ = static_cast<TrackType>(i);
          break;
        }
        trackY += trackHeight_;
      }
    }

    hoveredKeyframe_ = HitTestKeyframe(relX, relY, hoveredTrack_);
  }

  // ä¸­ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ï¼ˆãƒ‘ãƒ³é–‹å§‹ï¼‰
  if (ImGui::IsMouseClicked(ImGuiMouseButton_Middle)) {
    isPanning_ = true;
    dragStartOffset_ = offset_;
  }

  // ä¸­ãƒœã‚¿ãƒ³ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆãƒ‘ãƒ³ï¼‰
  if (ImGui::IsMouseDragging(ImGuiMouseButton_Middle) && isPanning_) {
    ImVec2 delta = ImGui::GetMouseDragDelta(ImGuiMouseButton_Middle);
    offset_ = dragStartOffset_ - delta.x / (100.0f * zoom_);
    ClampOffset();
  }

  // ä¸­ãƒœã‚¿ãƒ³ãƒªãƒªãƒ¼ã‚¹
  if (ImGui::IsMouseReleased(ImGuiMouseButton_Middle)) {
    isPanning_ = false;
  }

  // ãƒžã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ï¼ˆã‚ºãƒ¼ãƒ /ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰
  if (ImGui::GetIO().MouseWheel != 0) {
    if (ImGui::GetIO().KeyCtrl) {
      // Ctrl + ãƒ›ã‚¤ãƒ¼ãƒ«ï¼šã‚ºãƒ¼ãƒ 
      float zoomDelta = ImGui::GetIO().MouseWheel > 0 ? 1.2f : 0.8f;
      float newZoom = zoom_ * zoomDelta;

      // ã‚ºãƒ¼ãƒ åˆ¶é™
      newZoom = std::max<float>(minZoom_, std::min<float>(maxZoom_, newZoom));

      // ãƒžã‚¦ã‚¹ä½ç½®ã‚’ä¸­å¿ƒã«ã‚ºãƒ¼ãƒ 
      float mouseTime = ScreenXToTime(mousePos.x - canvasPos.x);
      zoom_ = newZoom;
      float newMouseTime = ScreenXToTime(mousePos.x - canvasPos.x);
      offset_ += (newMouseTime - mouseTime);
      ClampOffset();
    } else if (ImGui::GetIO().KeyShift) {
      // Shift + ãƒ›ã‚¤ãƒ¼ãƒ«ï¼šæ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
      offset_ -= ImGui::GetIO().MouseWheel * 0.5f / zoom_;
      ClampOffset();
    }
  }
}

void CameraAnimationTimeline::HandleKeyboardInput() {
  // Delete: é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å‰Šé™¤
  if (ImGui::IsKeyPressed(ImGuiKey_Delete) && !selectedKeyframes_.empty()) {
    // å‰Šé™¤å‡¦ç†ã¯ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹ã§è¡Œã†
  }

  // A: å…¨é¸æŠž
  if (ImGui::GetIO().KeyCtrl && ImGui::IsKeyPressed(ImGuiKey_A)) {
    selectedKeyframes_.clear();
    for (size_t i = 0; i < animation_->GetKeyframeCount(); ++i) {
      selectedKeyframes_.push_back(static_cast<int>(i));
    }
  }
}

float CameraAnimationTimeline::TimeToScreenX(float time) const {
  return trackLabelWidth_ + (time - offset_) * 100.0f * zoom_;
}

float CameraAnimationTimeline::ScreenXToTime(float x) const {
  return ((x - trackLabelWidth_) / (100.0f * zoom_)) + offset_;
}

int CameraAnimationTimeline::HitTestKeyframe(float x, float y, TrackType trackType) const {
  // ãƒˆãƒ©ãƒƒã‚¯ã®Yç¯„å›²ã‚’è¨ˆç®—
  float trackY = rulerHeight_;
  for (int i = 0; i < static_cast<int>(trackType); ++i) {
    if (trackVisible_[i]) {
      trackY += trackHeight_;
    }
  }

  // Yåº§æ¨™ãƒã‚§ãƒƒã‚¯
  if (y < trackY || y > trackY + trackHeight_) {
    return -1;
  }

  // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ã®è·é›¢ãƒã‚§ãƒƒã‚¯
  for (size_t i = 0; i < animation_->GetKeyframeCount(); ++i) {
    const CameraKeyframe& kf = animation_->GetKeyframe(i);
    float kfX = TimeToScreenX(kf.time);
    float kfY = trackY + trackHeight_ / 2;

    float dist = std::sqrt((x - kfX) * (x - kfX) + (y - kfY) * (y - kfY));
    if (dist <= keyframeSize_) {
      return static_cast<int>(i);
    }
  }

  return -1;
}

void CameraAnimationTimeline::ProcessRectSelection() {
  // çŸ©å½¢å†…ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠž
  float left = std::min<float>(dragStartPos_.x, dragCurrentPos_.x);
  float right = std::max<float>(dragStartPos_.x, dragCurrentPos_.x);
  float top = std::min<float>(dragStartPos_.y, dragCurrentPos_.y);
  float bottom = std::max<float>(dragStartPos_.y, dragCurrentPos_.y);

  for (size_t i = 0; i < animation_->GetKeyframeCount(); ++i) {
    const CameraKeyframe& kf = animation_->GetKeyframe(i);
    float kfX = TimeToScreenX(kf.time);

    // å„è¡¨ç¤ºãƒˆãƒ©ãƒƒã‚¯ä¸Šã§ã®Yåº§æ¨™ã‚’è¨ˆç®—
    float trackY = rulerHeight_;
    for (int t = 0; t < static_cast<int>(TrackType::COUNT); ++t) {
      if (trackVisible_[t]) {
        float kfY = trackY + trackHeight_ / 2;

        if (kfX >= left && kfX <= right && kfY >= top && kfY <= bottom) {
          if (std::find(selectedKeyframes_.begin(),
            selectedKeyframes_.end(),
            static_cast<int>(i)) == selectedKeyframes_.end()) {
            selectedKeyframes_.push_back(static_cast<int>(i));
          }
          break;
        }
        trackY += trackHeight_;
      }
    }
  }
}

void CameraAnimationTimeline::ProcessKeyframeDrag() {
  ImVec2 mousePos = ImGui::GetMousePos();
  float deltaX = mousePos.x - dragStartPos_.x;
  float deltaTime = deltaX / (100.0f * zoom_);

  for (size_t i = 0; i < selectedKeyframes_.size(); ++i) {
    int idx = selectedKeyframes_[i];
    if (idx >= 0 && idx < static_cast<int>(animation_->GetKeyframeCount()) &&
      i < dragStartTimes_.size()) {

      CameraKeyframe kf = animation_->GetKeyframe(idx);
      float newTime = dragStartTimes_[i] + deltaTime;

      // ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
      if (enableGridSnap_) {
        newTime = SnapToGrid(newTime);
      }

      // æ™‚é–“ç¯„å›²åˆ¶é™
      newTime = std::max<float>(0.0f, std::min<float>(newTime, animation_->GetDuration()));

      kf.time = newTime;
      animation_->EditKeyframe(idx, kf);

      // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã€ã“ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã®å ´åˆã¯æ™‚é–“ã‚’æ›´æ–°
      if (isPreviewModeEnabled_ && isKeyframePreviewActive_ && idx == previewKeyframeIndex_) {
        previewTime_ = newTime;
        animation_->SetCurrentTime(previewTime_);
      }
    }
  }
}

float CameraAnimationTimeline::SnapToGrid(float time) const {
  if (!enableGridSnap_) return time;
  return std::round(time / gridSnapInterval_) * gridSnapInterval_;
}

const char* CameraAnimationTimeline::GetTrackName(TrackType track) const {
  switch (track) {
  case TrackType::SUMMARY: return "Summary";
  case TrackType::POSITION_X: return "Pos X";
  case TrackType::POSITION_Y: return "Pos Y";
  case TrackType::POSITION_Z: return "Pos Z";
  case TrackType::ROTATION_X: return "Rot X";
  case TrackType::ROTATION_Y: return "Rot Y";
  case TrackType::ROTATION_Z: return "Rot Z";
  case TrackType::FOV: return "FOV";
  default: return "Unknown";
  }
}

ImU32 CameraAnimationTimeline::GetTrackColor(TrackType track) const {
  switch (track) {
  case TrackType::SUMMARY: return IM_COL32(200, 200, 200, 255);
  case TrackType::POSITION_X: return IM_COL32(255, 100, 100, 255);
  case TrackType::POSITION_Y: return IM_COL32(100, 255, 100, 255);
  case TrackType::POSITION_Z: return IM_COL32(100, 100, 255, 255);
  case TrackType::ROTATION_X: return IM_COL32(255, 200, 100, 255);
  case TrackType::ROTATION_Y: return IM_COL32(200, 255, 100, 255);
  case TrackType::ROTATION_Z: return IM_COL32(100, 200, 255, 255);
  case TrackType::FOV: return IM_COL32(255, 255, 100, 255);
  default: return IM_COL32(150, 150, 150, 255);
  }
}

void CameraAnimationTimeline::SetZoom(float zoom) {
  zoom_ = std::max<float>(minZoom_, std::min<float>(maxZoom_, zoom));
  ClampOffset();
}

void CameraAnimationTimeline::SetOffset(float offset) {
  offset_ = offset;
  ClampOffset();
}

void CameraAnimationTimeline::ClampOffset() {
  if (!animation_) return;

  // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’å–å¾—ï¼ˆç°¡æ˜“çš„ã«800ã¨ã—ã¦ä»®å®šã€å®Ÿéš›ã¯ImGuiã‹ã‚‰å–å¾—ï¼‰
  float visibleWidth = 800.0f - trackLabelWidth_;
  float visibleTime = visibleWidth / (100.0f * zoom_);
  float duration = animation_->GetDuration();

  // å·¦ç«¯åˆ¶é™ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ã‚ˆã‚Šå‰ã¯è¦‹ã›ãªã„ï¼‰
  offset_ = std::max<float>(-1.0f, offset_);

  // å³ç«¯åˆ¶é™
  if (visibleTime >= duration + 2.0f) {
    // å…¨ä½“ãŒè¦‹ãˆã‚‹å ´åˆã¯å·¦å¯„ã›
    offset_ = 0.0f;
  } else {
    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒå¿…è¦ãªå ´åˆã¯ã€çµ‚ç«¯ã‚ˆã‚Šå…ˆã‚’è¦‹ã›ã™ãŽãªã„
    offset_ = std::min<float>(offset_, duration - visibleTime + 1.0f);
  }
}

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraAnimationEditor/CameraAnimationTimeline.h
============================================================
#pragma once
#include "CameraAnimation/CameraAnimation.h"
#include "CameraAnimation/CameraKeyframe.h"
#include <vector>
#include "ImGuiManager.h"

#ifdef _DEBUG

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³UI
/// ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãªã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¡¨ç¤ºã¨ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
/// </summary>
class CameraAnimationTimeline {
public:
    /// <summary>
    /// ãƒˆãƒ©ãƒƒã‚¯ã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class TrackType {
        SUMMARY,        ///< ã‚µãƒžãƒªãƒ¼ãƒˆãƒ©ãƒƒã‚¯ï¼ˆå…¨ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºï¼‰
        POSITION_X,     ///< Xä½ç½®ãƒˆãƒ©ãƒƒã‚¯
        POSITION_Y,     ///< Yä½ç½®ãƒˆãƒ©ãƒƒã‚¯
        POSITION_Z,     ///< Zä½ç½®ãƒˆãƒ©ãƒƒã‚¯
        ROTATION_X,     ///< Xå›žè»¢ãƒˆãƒ©ãƒƒã‚¯
        ROTATION_Y,     ///< Yå›žè»¢ãƒˆãƒ©ãƒƒã‚¯
        ROTATION_Z,     ///< Zå›žè»¢ãƒˆãƒ©ãƒƒã‚¯
        FOV,            ///< FOVãƒˆãƒ©ãƒƒã‚¯
        COUNT
    };

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ«
    /// </summary>
    enum class KeyframeStyle {
        DIAMOND,        ///< ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰åž‹
        CIRCLE,         ///< å††å½¢
        SQUARE,         ///< å››è§’å½¢
        TRIANGLE        ///< ä¸‰è§’å½¢
    };

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    CameraAnimationTimeline();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~CameraAnimationTimeline();

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    /// <param name="animation">å¯¾è±¡ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</param>
    void Initialize(CameraAnimation* animation);

    /// <summary>
    /// ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã®æç”»
    /// </summary>
    void Draw();

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
    void Update(float deltaTime);

    /// <summary>
    /// é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—
    /// </summary>
    const std::vector<int>& GetSelectedKeyframes() const { return selectedKeyframes_; }

    /// <summary>
    /// ãƒ›ãƒãƒ¼ä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—
    /// </summary>
    int GetHoveredKeyframe() const { return hoveredKeyframe_; }

    /// <summary>
    /// ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‹ã©ã†ã‹
    /// </summary>
    bool IsDragging() const { return isDragging_; }

    /// <summary>
    /// ã‚¹ã‚¯ãƒ©ãƒ–ä¸­ã‹ã©ã†ã‹
    /// </summary>
    bool IsScrubbing() const { return isScrubbing_; }

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¹ã‚¿ã‚¤ãƒ«ã®è¨­å®š
    /// </summary>
    void SetKeyframeStyle(KeyframeStyle style) { keyframeStyle_ = style; }

    /// <summary>
    /// ãƒˆãƒ©ãƒƒã‚¯ã®å¯è¦–æ€§è¨­å®š
    /// </summary>
    void SetTrackVisible(TrackType track, bool visible);

    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—ã®æœ‰åŠ¹åŒ–
    /// </summary>
    void SetGridSnapEnabled(bool enable) { enableGridSnap_ = enable; }

    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—é–“éš”ã®è¨­å®š
    /// </summary>
    void SetGridSnapInterval(float interval) { gridSnapInterval_ = interval; }

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
    /// </summary>
    /// <param name="enabled">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã‹</param>
    void SetPreviewMode(bool enabled) {
        isPreviewModeEnabled_ = enabled;
        if (!enabled) {
            isKeyframePreviewActive_ = false;
            previewKeyframeIndex_ = -1;
        }
    }

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã‹ã©ã†ã‹
    /// </summary>
    bool IsKeyframePreviewActive() const { return isKeyframePreviewActive_; }

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å–å¾—
    /// </summary>
    int GetPreviewKeyframeIndex() const { return previewKeyframeIndex_; }

    /// <summary>
    /// ç¾åœ¨ã®ã‚ºãƒ¼ãƒ å€¤ã‚’å–å¾—
    /// </summary>
    float GetZoom() const { return zoom_; }

    /// <summary>
    /// ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆå€¤ã‚’å–å¾—
    /// </summary>
    float GetOffset() const { return offset_; }

    /// <summary>
    /// ã‚ºãƒ¼ãƒ å€¤ã‚’è¨­å®š
    /// </summary>
    void SetZoom(float zoom);

    /// <summary>
    /// ã‚ªãƒ•ã‚»ãƒƒãƒˆå€¤ã‚’è¨­å®š
    /// </summary>
    void SetOffset(float offset);

private:
    /// <summary>
    /// ã‚¿ã‚¤ãƒ ãƒ«ãƒ¼ãƒ©ãƒ¼ã®æç”»
    /// </summary>
    void DrawTimeRuler();

    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ã®æç”»
    /// </summary>
    void DrawGrid();

    /// <summary>
    /// å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®æç”»
    /// </summary>
    void DrawPlayhead();

    /// <summary>
    /// ãƒˆãƒ©ãƒƒã‚¯ã®æç”»
    /// </summary>
    /// <param name="trackType">ãƒˆãƒ©ãƒƒã‚¯ã‚¿ã‚¤ãƒ—</param>
    /// <param name="yPos">Yåº§æ¨™</param>
    void DrawTrack(TrackType trackType, float yPos);

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®æç”»
    /// </summary>
    /// <param name="index">ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    /// <param name="xPos">Xåº§æ¨™</param>
    /// <param name="yPos">Yåº§æ¨™</param>
    /// <param name="isSelected">é¸æŠžçŠ¶æ…‹</param>
    /// <param name="isHovered">ãƒ›ãƒãƒ¼çŠ¶æ…‹</param>
    void DrawKeyframe(int index, float xPos, float yPos, bool isSelected, bool isHovered);

    /// <summary>
    /// é¸æŠžçŸ©å½¢ã®æç”»
    /// </summary>
    void DrawSelectionRect();

    /// <summary>
    /// ãƒžã‚¦ã‚¹å…¥åŠ›ã®å‡¦ç†
    /// </summary>
    void HandleMouseInput();

    /// <summary>
    /// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã®å‡¦ç†
    /// </summary>
    void HandleKeyboardInput();

    /// <summary>
    /// æ™‚é–“ã‚’Xåº§æ¨™ã«å¤‰æ›
    /// </summary>
    float TimeToScreenX(float time) const;

    /// <summary>
    /// Xåº§æ¨™ã‚’æ™‚é–“ã«å¤‰æ›
    /// </summary>
    float ScreenXToTime(float x) const;

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
    /// </summary>
    /// <param name="x">Xåº§æ¨™</param>
    /// <param name="y">Yåº§æ¨™</param>
    /// <param name="trackType">ãƒˆãƒ©ãƒƒã‚¯ã‚¿ã‚¤ãƒ—</param>
    /// <returns>ãƒ’ãƒƒãƒˆã—ãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ-1ã§ãƒ’ãƒƒãƒˆãªã—ï¼‰</returns>
    int HitTestKeyframe(float x, float y, TrackType trackType) const;

    /// <summary>
    /// çŸ©å½¢é¸æŠžã®å‡¦ç†
    /// </summary>
    void ProcessRectSelection();

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ç§»å‹•å‡¦ç†
    /// </summary>
    void ProcessKeyframeDrag();

    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ã«ã‚¹ãƒŠãƒƒãƒ—
    /// </summary>
    float SnapToGrid(float time) const;

    /// <summary>
    /// ãƒˆãƒ©ãƒƒã‚¯åã®å–å¾—
    /// </summary>
    const char* GetTrackName(TrackType track) const;

    /// <summary>
    /// ãƒˆãƒ©ãƒƒã‚¯ã®è‰²ã‚’å–å¾—
    /// </summary>
    ImU32 GetTrackColor(TrackType track) const;

    /// <summary>
    /// ã‚ªãƒ•ã‚»ãƒƒãƒˆå€¤ã‚’åˆ¶é™
    /// </summary>
    void ClampOffset();

private:
    // å‚ç…§
    CameraAnimation* animation_ = nullptr;       ///< å¯¾è±¡ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

    // UIè¨­å®š
    float timelineHeight_ = 300.0f;              ///< ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³é«˜ã•
    float trackHeight_ = 30.0f;                  ///< ãƒˆãƒ©ãƒƒã‚¯é«˜ã•
    float rulerHeight_ = 25.0f;                  ///< ãƒ«ãƒ¼ãƒ©ãƒ¼é«˜ã•
    float trackLabelWidth_ = 100.0f;             ///< ãƒˆãƒ©ãƒƒã‚¯ãƒ©ãƒ™ãƒ«å¹…
    float keyframeSize_ = 10.0f;                 ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚µã‚¤ã‚º

    // ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
    KeyframeStyle keyframeStyle_ = KeyframeStyle::DIAMOND;  ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¹ã‚¿ã‚¤ãƒ«
    ImU32 gridColor_ = IM_COL32(60, 60, 60, 255);          ///< ã‚°ãƒªãƒƒãƒ‰è‰²
    ImU32 playheadColor_ = IM_COL32(255, 100, 100, 255);   ///< å†ç”Ÿãƒ˜ãƒƒãƒ‰è‰²
    ImU32 selectedColor_ = IM_COL32(255, 200, 100, 255);   ///< é¸æŠžè‰²
    ImU32 hoveredColor_ = IM_COL32(200, 200, 255, 255);    ///< ãƒ›ãƒãƒ¼è‰²

    // é¸æŠžçŠ¶æ…‹
    std::vector<int> selectedKeyframes_;         ///< é¸æŠžä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 
    int hoveredKeyframe_ = -1;                   ///< ãƒ›ãƒãƒ¼ä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 
    TrackType hoveredTrack_ = TrackType::SUMMARY; ///< ãƒ›ãƒãƒ¼ä¸­ã®ãƒˆãƒ©ãƒƒã‚¯

    // ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹
    bool isDragging_ = false;                    ///< ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‹
    bool isRectSelecting_ = false;               ///< çŸ©å½¢é¸æŠžä¸­ã‹
    ImVec2 dragStartPos_;                         ///< ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ä½ç½®
    ImVec2 dragCurrentPos_;                       ///< ç¾åœ¨ã®ãƒ‰ãƒ©ãƒƒã‚°ä½ç½®
    std::vector<float> dragStartTimes_;          ///< ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®æ™‚é–“

    // ã‚¹ã‚¯ãƒ©ãƒ–çŠ¶æ…‹
    bool isScrubbing_ = false;                   ///< ã‚¹ã‚¯ãƒ©ãƒ–ä¸­ã‹
    float scrubTime_ = 0.0f;                     ///< ã‚¹ã‚¯ãƒ©ãƒ–æ™‚é–“

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰åˆ¶å¾¡
    bool isPreviewModeEnabled_ = false;          ///< ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã‹
    bool isKeyframePreviewActive_ = false;       ///< ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã‹
    float previewTime_ = 0.0f;                   ///< ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚åˆ»
    int previewKeyframeIndex_ = -1;              ///< ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

    // ã‚ºãƒ¼ãƒ ãƒ»ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹
    float zoom_ = 1.0f;                          ///< ç¾åœ¨ã®ã‚ºãƒ¼ãƒ å€¤
    float offset_ = 0.0f;                        ///< ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ï¼‰
    float dragStartOffset_ = 0.0f;               ///< ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    bool isPanning_ = false;                     ///< ãƒ‘ãƒ³ï¼ˆä¸­ãƒœã‚¿ãƒ³ãƒ‰ãƒ©ãƒƒã‚°ï¼‰ä¸­ã‹

    // ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
    bool enableGridSnap_ = true;                 ///< ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—æœ‰åŠ¹
    float gridSnapInterval_ = 0.1f;              ///< ã‚¹ãƒŠãƒƒãƒ—é–“éš”

    // ãƒˆãƒ©ãƒƒã‚¯å¯è¦–æ€§
    bool trackVisible_[static_cast<int>(TrackType::COUNT)]; ///< ãƒˆãƒ©ãƒƒã‚¯å¯è¦–æ€§é…åˆ—

    // ã‚ºãƒ¼ãƒ è¨­å®š
    float minZoom_ = 0.1f;                       ///< æœ€å°ã‚ºãƒ¼ãƒ 
    float maxZoom_ = 10.0f;                      ///< æœ€å¤§ã‚ºãƒ¼ãƒ 

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    float hoverAnimTime_ = 0.0f;                 ///< ãƒ›ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“
};

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraConfig.h
============================================================
#pragma once
#include <DirectXMath.h>

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ ã®è¨­å®šå€¤ã‚’ç®¡ç†
/// ãƒžã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã‚’æ’²æ»…ã—ã€æ„å‘³ã‚’æ˜Žç¢ºåŒ–
/// </summary>
namespace CameraConfig {

    //==================== å…±é€šè¨­å®š ====================

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©è¿½å¾“ã®æ»‘ã‚‰ã‹ã•ï¼ˆ0.0-1.0ã€å€¤ãŒå¤§ãã„ã»ã©å³åº§ã«è¿½å¾“ï¼‰
    /// </summary>
    constexpr float FOLLOW_SMOOTHNESS = 0.18f;

    /// <summary>
    /// ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œé–“é€Ÿåº¦ï¼ˆ0.0-1.0ï¼‰
    /// </summary>
    constexpr float OFFSET_LERP_SPEED = 0.08f;

    /// <summary>
    /// å›žè»¢è£œé–“é€Ÿåº¦ï¼ˆ0.0-1.0ï¼‰
    /// </summary>
    constexpr float ROTATION_LERP_SPEED = 0.15f;

    /// <summary>
    /// æ¨™æº–FOVï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
    /// </summary>
    constexpr float STANDARD_FOV = 0.44999998807907104;

    /// <summary>
    /// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã¾ã æ¶ˆãˆãªã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒåˆ¥ã®ã‚·ãƒ¼ãƒ³ã§ã‚‚è¡¨ç¤ºã•ã‚Œã‚‹ã®ã‚’é˜²ããŸã‚ã€
    /// ã‚«ãƒ¡ãƒ©ã‚’ç”»é¢å¤–ã«ç§»å‹•ã•ã›ã‚‹éš›ã®Yåº§æ¨™
    /// ã‚·ãƒ¼ãƒ³é·ç§»æ™‚ãªã©ã§ä½¿ç”¨
    /// </summary>
    constexpr float HIDDEN_Y = -1000.0f;

    //==================== FirstPersonè¨­å®š ====================

    namespace FirstPerson {
        /// <summary>
        /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã‚ªãƒ•ã‚»ãƒƒãƒˆ
        /// </summary>
        constexpr float DEFAULT_OFFSET_X = 0.0f;
        constexpr float DEFAULT_OFFSET_Y = 2.0f;
        constexpr float DEFAULT_OFFSET_Z = -40.0f;

        /// <summary>
        /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆXè»¸è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
        /// </summary>
        constexpr float DEFAULT_ANGLE_X = DirectX::XMConvertToRadians(8.0f);

        /// <summary>
        /// å›žè»¢æ„Ÿåº¦
        /// </summary>
        constexpr float DEFAULT_ROTATE_SPEED = 0.05f;

        /// <summary>
        /// ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰å›žè»¢æ„Ÿåº¦å€çŽ‡
        /// </summary>
        constexpr float GAMEPAD_ROTATE_MULTIPLIER = 1.0f;
    }

    //==================== TopDownè¨­å®š ====================

    namespace TopDown {
        /// <summary>
        /// åŸºæº–ã‚«ãƒ¡ãƒ©é«˜ã•
        /// </summary>
        constexpr float BASE_HEIGHT = 10.0f;

        /// <summary>
        /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé–“è·é›¢ã«å¯¾ã™ã‚‹é«˜ã•å€çŽ‡
        /// </summary>
        constexpr float HEIGHT_MULTIPLIER = 0.6f;

        /// <summary>
        /// ã‚«ãƒ¡ãƒ©é«˜ã•ã®åˆ¶é™
        /// </summary>
        constexpr float MIN_HEIGHT = 26.0f;
        constexpr float MAX_HEIGHT = 500.0f;

        /// <summary>
        /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
        /// </summary>
        constexpr float DEFAULT_ANGLE_X = DirectX::XMConvertToRadians(25.0f);

        /// <summary>
        /// å¾Œæ–¹ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨­å®š
        /// </summary>
        constexpr float BASE_BACK_OFFSET = -10.0f;
        constexpr float BACK_OFFSET_MULTIPLIER = 1.5f;
        constexpr float MIN_BACK_OFFSET = -500.0f;
        constexpr float MAX_BACK_OFFSET = -52.0f;
    }

    //==================== ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š ====================

    namespace Animation {
        /// <summary>
        /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå†ç”Ÿé€Ÿåº¦
        /// </summary>
        constexpr float DEFAULT_PLAY_SPEED = 1.0f;

        /// <summary>
        /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ äºˆç´„æ•°
        /// </summary>
        constexpr size_t KEYFRAME_RESERVE_COUNT = 32;

        /// <summary>
        /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆFOVï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
        /// </summary>
        constexpr float DEFAULT_FOV = 0.45f;
    }
}

============================================================
File Path: GameProject/CameraSystem/CameraDebugUI.cpp
============================================================
#ifdef _DEBUG

#include "CameraDebugUI.h"
#include "CameraAnimationEditor/CameraAnimationEditor.h"
#include "Controller/CameraAnimationController.h"
#include "FrameTimer.h"
#include "ImGuiManager.h"
#include <sstream>

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
bool CameraDebugUI::showManagerInfo_ = true;
bool CameraDebugUI::showControllerInfo_ = true;
bool CameraDebugUI::showAnimationInfo_ = true;
std::unique_ptr<CameraAnimationEditor> CameraDebugUI::animationEditor_ = nullptr;
bool CameraDebugUI::useAdvancedEditor_ = false;

void CameraDebugUI::Draw() {
    if (!ImGui::Begin("Camera System Debug")) {
        ImGui::End();
        return;
    }

    // ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ–
    if (ImGui::BeginTabBar("CameraDebugTabs")) {
        // Manager ã‚¿ãƒ–
        if (ImGui::BeginTabItem("Manager")) {
            DrawManagerInfo();
            ImGui::EndTabItem();
        }

        // Controllers ã‚¿ãƒ–
        if (ImGui::BeginTabItem("Controllers")) {
            DrawControllerSwitcher();
            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }

    ImGui::End();
}

void CameraDebugUI::DrawManagerInfo() {
    CameraManager* manager = CameraManager::GetInstance();
    if (!manager) {
        ImGui::Text("CameraManager not initialized");
        return;
    }

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æƒ…å ±ã‚’ãƒœãƒƒã‚¯ã‚¹ã§å›²ã‚€
    ImGui::BeginChild("StatusBox", ImVec2(0, 80), true);
    {
        ImGui::Text("ðŸŽ¯ Active Controller:");
        ImGui::SameLine();
        ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.2f, 1.0f), "%s",
                          manager->GetActiveControllerName().c_str());

        ImGui::Text("ðŸ“Š Total Controllers:");
        ImGui::SameLine();
        ImGui::Text("%zu", manager->GetControllerCount());
    }
    ImGui::EndChild();

    ImGui::Spacing();
    ImGui::Text("Controller List:");
    ImGui::Separator();

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒªã‚¹ãƒˆã‚’ãƒ†ãƒ¼ãƒ–ãƒ«ã§è¡¨ç¤º
    if (ImGui::BeginTable("ControllerTable", 3,
                         ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable)) {

        // ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼
        ImGui::TableSetupColumn("Name", ImGuiTableColumnFlags_WidthFixed, 150.0f);
        ImGui::TableSetupColumn("Priority", ImGuiTableColumnFlags_WidthFixed, 80.0f);
        ImGui::TableSetupColumn("Status", ImGuiTableColumnFlags_WidthFixed, 80.0f);
        ImGui::TableHeadersRow();

        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦è¡¨ç¤ºï¼ˆç°¡æ˜“ç‰ˆï¼‰
        // å®Ÿéš›ã¯ CameraManager ã«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹APIãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã†
        std::string debugInfo = manager->GetDebugInfo();

        // å„è¡Œã‚’è§£æžã—ã¦è¡¨ç¤ºï¼ˆç°¡æ˜“çš„ãªå®Ÿè£…ï¼‰
        if (manager->GetControllerCount() > 0) {
            // FirstPerson
            ImGui::TableNextRow();
            ImGui::TableNextColumn();
            ImGui::Text("FirstPerson");
            ImGui::TableNextColumn();
            ImGui::Text("50");  // FOLLOW_DEFAULT priority
            ImGui::TableNextColumn();
            bool isFPActive = (manager->GetActiveControllerName() == "FirstPerson");
            ImGui::TextColored(isFPActive ? ImVec4(0.2f, 1.0f, 0.2f, 1.0f) : ImVec4(0.5f, 0.5f, 0.5f, 1.0f),
                             isFPActive ? "Active" : "Inactive");

            // TopDown
            ImGui::TableNextRow();
            ImGui::TableNextColumn();
            ImGui::Text("TopDown");
            ImGui::TableNextColumn();
            ImGui::Text("50");  // FOLLOW_DEFAULT priority
            ImGui::TableNextColumn();
            bool isTDActive = (manager->GetActiveControllerName() == "TopDown");
            ImGui::TextColored(isTDActive ? ImVec4(0.2f, 1.0f, 0.2f, 1.0f) : ImVec4(0.5f, 0.5f, 0.5f, 1.0f),
                             isTDActive ? "Active" : "Inactive");

            // Animation
            ImGui::TableNextRow();
            ImGui::TableNextColumn();
            ImGui::Text("Animation");
            ImGui::TableNextColumn();
            ImGui::Text("100");  // ANIMATION priority
            ImGui::TableNextColumn();
            bool isAnimActive = (manager->GetActiveControllerName() == "Animation");
            ImGui::TextColored(isAnimActive ? ImVec4(0.2f, 1.0f, 0.2f, 1.0f) : ImVec4(0.5f, 0.5f, 0.5f, 1.0f),
                             isAnimActive ? "Active" : "Inactive");
        }

        ImGui::EndTable();
    }
}

void CameraDebugUI::DrawFirstPersonControllerInfo(ThirdPersonController* controller) {
    if (!controller) {
        return;
    }

    ImGui::PushID("FirstPerson");  // ä¸€æ„ã®IDã‚¹ã‚³ãƒ¼ãƒ—é–‹å§‹

    ImGui::Text("=== FirstPerson Controller ===");
    ImGui::Text("Active: %s", controller->IsActive() ? "Yes" : "No");

    if (!controller->IsActive()) {
        if (ImGui::Button("Activate")) {
            controller->Activate();
        }
    } else {
        if (ImGui::Button("Deactivate")) {
            controller->Deactivate();
        }
    }

    ImGui::Separator();

    // ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨­å®š
    Vector3 offset = controller->GetOffset();
    float offsetArray[3] = { offset.x, offset.y, offset.z };
    if (ImGui::DragFloat3("Offset", offsetArray, 0.1f)) {
        controller->SetOffset(Vector3(offsetArray[0], offsetArray[1], offsetArray[2]));
    }

    // å›žè»¢é€Ÿåº¦ï¼ˆå¤‰æ•°åã‚’æ˜Žç¢ºã«ï¼‰
    static float fpRotateSpeed = CameraConfig::FirstPerson::DEFAULT_ROTATE_SPEED;
    if (ImGui::SliderFloat("Rotate Speed", &fpRotateSpeed, 0.01f, 0.2f)) {
        controller->SetRotateSpeed(fpRotateSpeed);
    }

    // è¿½å¾“ã®æ»‘ã‚‰ã‹ã•ï¼ˆå¤‰æ•°åã‚’æ˜Žç¢ºã«ï¼‰
    static float fpSmoothness = CameraConfig::FOLLOW_SMOOTHNESS;
    if (ImGui::SliderFloat("Follow Smoothness", &fpSmoothness, 0.01f, 1.0f)) {
        controller->SetSmoothness(fpSmoothness);
    }

    // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
    if (ImGui::Button("Reset Camera")) {
        controller->Reset();
    }

    ImGui::PopID();  // IDã‚¹ã‚³ãƒ¼ãƒ—çµ‚äº†
}

void CameraDebugUI::DrawTopDownControllerInfo(TopDownController* controller) {
    if (!controller) {
        return;
    }

    ImGui::PushID("TopDown");  // ä¸€æ„ã®IDã‚¹ã‚³ãƒ¼ãƒ—é–‹å§‹

    ImGui::Text("=== TopDown Controller ===");
    ImGui::Text("Active: %s", controller->IsActive() ? "Yes" : "No");

    if (!controller->IsActive()) {
        if (ImGui::Button("Activate")) {
            controller->Activate();
        }
    } else {
        if (ImGui::Button("Deactivate")) {
            controller->Deactivate();
        }
    }

    ImGui::Separator();

    // ã‚«ãƒ¡ãƒ©é«˜ã•è¨­å®šï¼ˆå¤‰æ•°åã‚’æ˜Žç¢ºã«ï¼‰
    static float tdBaseHeight = CameraConfig::TopDown::BASE_HEIGHT;
    if (ImGui::DragFloat("Base Height", &tdBaseHeight, 0.5f, 5.0f, 100.0f)) {
        controller->SetBaseHeight(tdBaseHeight);
    }

    // é«˜ã•å€çŽ‡ï¼ˆå¤‰æ•°åã‚’æ˜Žç¢ºã«ï¼‰
    static float tdHeightMultiplier = CameraConfig::TopDown::HEIGHT_MULTIPLIER;
    if (ImGui::SliderFloat("Height Multiplier", &tdHeightMultiplier, 0.0f, 2.0f)) {
        controller->SetHeightMultiplier(tdHeightMultiplier);
    }

    // ã‚«ãƒ¡ãƒ©è§’åº¦ï¼ˆå¤‰æ•°åã‚’æ˜Žç¢ºã«ï¼‰
    static float tdAngleXDegrees = CameraConfig::TopDown::DEFAULT_ANGLE_X * 57.2958f;
    if (ImGui::SliderFloat("Camera Angle (deg)", &tdAngleXDegrees, 0.0f, 90.0f)) {
        controller->SetCameraAngle(tdAngleXDegrees * 0.0174533f);
    }

    // è¿½å¾“ã®æ»‘ã‚‰ã‹ã•ï¼ˆå¤‰æ•°åã‚’æ˜Žç¢ºã«ï¼‰
    static float tdSmoothness = CameraConfig::FOLLOW_SMOOTHNESS;
    if (ImGui::SliderFloat("Follow Smoothness", &tdSmoothness, 0.01f, 1.0f)) {
        controller->SetSmoothness(tdSmoothness);
    }

    // ç¾åœ¨ã®é«˜ã•è¡¨ç¤º
    ImGui::Text("Current Height: %.2f", controller->GetCurrentHeight());

    // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
    if (ImGui::Button("Reset Camera")) {
        controller->Reset();
    }

    ImGui::PopID();  // IDã‚¹ã‚³ãƒ¼ãƒ—çµ‚äº†
}

void CameraDebugUI::DrawAnimationInfo(CameraAnimation* animation) {
    if (!animation) {
        return;
    }

    ImGui::PushID("AnimationInfo");  // ä¸€æ„ã®IDã‚¹ã‚³ãƒ¼ãƒ—é–‹å§‹

    ImGui::Text("=== Camera Animation ===");

    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼åˆ‡ã‚Šæ›¿ãˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
    ImGui::Checkbox("Use Advanced Editor", &useAdvancedEditor_);

    if (useAdvancedEditor_) {
        // é«˜åº¦ãªã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’ä½¿ç”¨
        if (!animationEditor_) {
            animationEditor_ = std::make_unique<CameraAnimationEditor>();
            CameraManager* manager = CameraManager::GetInstance();
            if (manager && manager->GetCamera()) {
                animationEditor_->Initialize(animation, manager->GetCamera());
            }
        }

        if (ImGui::Button("Open Animation Editor")) {
            animationEditor_->Open();
        }

        // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯æç”»
        if (animationEditor_ && animationEditor_->IsOpen()) {
            animationEditor_->Draw();
            animationEditor_->Update(0.016f); // ä»®ã® deltaTime
        }

        ImGui::PopID();
        return;
    }

    // å¾“æ¥ã®ã‚·ãƒ³ãƒ—ãƒ«ãªUI

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±
    ImGui::Text("Animation: %s", animation->GetAnimationName().c_str());
    ImGui::Text("Duration: %.2f seconds", animation->GetDuration());
    ImGui::Text("Current Time: %.2f", animation->GetPlaybackTime());
    ImGui::Text("Keyframes: %zu", animation->GetKeyframeCount());

    // å†ç”ŸçŠ¶æ…‹
    const char* stateStr = "STOPPED";
    auto playState = animation->GetPlayState();
    if (playState == CameraAnimation::PlayState::PLAYING) stateStr = "PLAYING";
    else if (playState == CameraAnimation::PlayState::PAUSED) stateStr = "PAUSED";
    ImGui::Text("State: %s", stateStr);

    ImGui::Separator();

    // å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    // CameraManagerã‹ã‚‰AnimationControllerã‚’å–å¾—
    auto* animController = dynamic_cast<CameraAnimationController*>(
        CameraManager::GetInstance()->GetController("Animation"));

    if (ImGui::Button("Play")) {
        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼çµŒç”±ã§å‘¼ã³å‡ºã—ï¼ˆisActive_ãƒ•ãƒ©ã‚°ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ï¼‰
        if (animController) {
            animController->Play();
        } else {
            animation->Play();
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Pause")) {
        if (animController) {
            animController->Pause();
        } else {
            animation->Pause();
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Stop")) {
        if (animController) {
            animController->Stop();
        } else {
            animation->Stop();
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Reset")) {
        if (animController) {
            animController->Reset();
        } else {
            animation->Reset();
        }
    }

    // ãƒ«ãƒ¼ãƒ—è¨­å®š
    bool isLooping = animation->IsLooping();
    if (ImGui::Checkbox("Loop", &isLooping)) {
        animation->SetLooping(isLooping);
    }

    // å†ç”Ÿé€Ÿåº¦
    static float playSpeed = 1.0f;
    if (ImGui::SliderFloat("Play Speed", &playSpeed, -2.0f, 2.0f, "%.2f")) {
        animation->SetPlaySpeed(playSpeed);
    }

    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
    float currentTime = animation->GetPlaybackTime();
    if (ImGui::SliderFloat("Timeline", &currentTime, 0.0f,
                          animation->GetDuration(), "%.2f")) {
        animation->SetCurrentTime(currentTime);
    }

    ImGui::PopID();  // IDã‚¹ã‚³ãƒ¼ãƒ—çµ‚äº†
}

void CameraDebugUI::DrawControllerSwitcher() {
    CameraManager* manager = CameraManager::GetInstance();
    if (!manager) {
        return;
    }

    ImGui::Text("=== Controller Switcher ===");

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’è¡¨ç¤º
    std::string activeName = manager->GetActiveControllerName();
    ImGui::Text("Current Active: %s",
               activeName.empty() ? "None" : activeName.c_str());

    ImGui::Separator();

    // FirstPerson/TopDownã®ç°¡å˜åˆ‡ã‚Šæ›¿ãˆ
    if (ImGui::Button("Activate FirstPerson")) {
        manager->DeactivateAllControllers();
        manager->ActivateController("FirstPerson");
    }
    ImGui::SameLine();
    if (ImGui::Button("Activate TopDown")) {
        manager->DeactivateAllControllers();
        manager->ActivateController("TopDown");
    }

    ImGui::Separator();

    // å„ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®è©³ç´°æƒ…å ±
    if (ImGui::CollapsingHeader("FirstPerson Controller Details")) {
        auto* fpController = dynamic_cast<ThirdPersonController*>(
            manager->GetController("FirstPerson"));
        DrawFirstPersonControllerInfo(fpController);
    }

    if (ImGui::CollapsingHeader("TopDown Controller Details")) {
        auto* tdController = dynamic_cast<TopDownController*>(
            manager->GetController("TopDown"));
        DrawTopDownControllerInfo(tdController);
    }
}

void CameraDebugUI::DrawCameraState() {
    CameraManager* manager = CameraManager::GetInstance();
    if (!manager || !manager->GetCamera()) {
        return;
    }

    Camera* camera = manager->GetCamera();

    ImGui::Text("=== Camera State ===");

    // ä½ç½®
    Vector3 pos = camera->GetTranslate();
    ImGui::Text("Position: (%.2f, %.2f, %.2f)", pos.x, pos.y, pos.z);

    // å›žè»¢ï¼ˆåº¦å˜ä½ï¼‰
    Vector3 rot = camera->GetRotate();
    ImGui::Text("Rotation: (%.1fÂ°, %.1fÂ°, %.1fÂ°)",
               rot.x * 57.2958f, rot.y * 57.2958f, rot.z * 57.2958f);

    // FOVï¼ˆåº¦å˜ä½ï¼‰
    float fov = camera->GetFovY() * 57.2958f;
    ImGui::Text("FOV: %.1fÂ°", fov);

    // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
    ImGui::Text("Aspect Ratio: %.3f", camera->GetAspect());

    // ãƒ‹ã‚¢ãƒ»ãƒ•ã‚¡ãƒ¼
    ImGui::Text("Near/Far: %.2f / %.1f",
               camera->GetNearClip(), camera->GetFarClip());
}

void CameraDebugUI::DrawAnimationEditorOnly() {
    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒæœªåˆæœŸåŒ–ã®å ´åˆã¯åˆæœŸåŒ–ã‚’è©¦ã¿ã‚‹
    if (!animationEditor_) {
        InitializeAnimationEditor();
    }

    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚Œã°æç”»
    if (animationEditor_) {
        // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒé–‰ã˜ã¦ã„ã‚Œã°é–‹ã
        if (!animationEditor_->IsOpen()) {
            animationEditor_->Open();
        }

        // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®æç”»
        animationEditor_->Draw();
    } else {
        // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒåˆæœŸåŒ–ã§ããªã„å ´åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        if (ImGui::Begin("Camera Animation Editor")) {
            ImGui::Text("âš ï¸ Animation Editor not available");
            ImGui::TextWrapped("Make sure AnimationController is registered and initialized with a valid CameraAnimation.");

            // å†åˆæœŸåŒ–ãƒœã‚¿ãƒ³
            if (ImGui::Button("Try Initialize")) {
                InitializeAnimationEditor();
            }
            ImGui::End();
        }
    }
}

void CameraDebugUI::InitializeAnimationEditor() {

  animationEditor_.reset();

    CameraManager* manager = CameraManager::GetInstance();
    if (!manager) return;

    // AnimationControllerã‚’å–å¾—
    auto* animController = dynamic_cast<CameraAnimationController*>(
        manager->GetController("Animation"));
    if (!animController) return;

    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®åˆæœŸåŒ–ï¼ˆCameraAnimationControllerã‚’æ¸¡ã™ï¼‰
    animationEditor_ = std::make_unique<CameraAnimationEditor>();
    animationEditor_->Initialize(animController, manager->GetCamera());
}

void CameraDebugUI::CleanupAnimationEditor()
{
  animationEditor_.reset();
}

void CameraDebugUI::UpdateAnimationEditor(float deltaTime) {
    if (animationEditor_ && animationEditor_->IsOpen()) {
        animationEditor_->Update(deltaTime);
    }
}

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraDebugUI.h
============================================================
#pragma once
#include "CameraManager.h"
#include "Controller/ThirdPersonController.h"
#include "Controller/TopDownController.h"
#include "CameraAnimation/CameraAnimation.h"
#include "CameraAnimationEditor/CameraAnimationEditor.h"
#include <memory>

#ifdef _DEBUG

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒãƒƒã‚°UI
/// ImGuiã‚’ä½¿ç”¨ã—ãŸãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã‚’æä¾›
/// </summary>
class CameraDebugUI {
public:
    /// <summary>
    /// ãƒ‡ãƒãƒƒã‚°UIã‚’æç”»
    /// </summary>
    static void Draw();

    /// <summary>
    /// CameraManagerã®ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’æç”»
    /// </summary>
    static void DrawManagerInfo();

    /// <summary>
    /// FirstPersonControllerã®ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’æç”»
    /// </summary>
    /// <param name="controller">å¯¾è±¡ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼</param>
    static void DrawFirstPersonControllerInfo(ThirdPersonController* controller);

    /// <summary>
    /// TopDownControllerã®ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’æç”»
    /// </summary>
    /// <param name="controller">å¯¾è±¡ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼</param>
    static void DrawTopDownControllerInfo(TopDownController* controller);

    /// <summary>
    /// CameraAnimationã®ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’æç”»
    /// </summary>
    /// <param name="animation">å¯¾è±¡ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</param>
    static void DrawAnimationInfo(CameraAnimation* animation);

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®ã¿ã‚’æç”»
    /// ï¼ˆDebugUIManagerç”¨ã®ç‹¬ç«‹ã—ãŸæç”»é–¢æ•°ï¼‰
    /// </summary>
    static void DrawAnimationEditorOnly();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®åˆæœŸåŒ–
    /// </summary>
    static void InitializeAnimationEditor();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    /// </summary>
    static void CleanupAnimationEditor();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®æ›´æ–°
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
    static void UpdateAnimationEditor(float deltaTime);

private:
    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åˆ‡ã‚Šæ›¿ãˆUIã‚’æç”»
    /// </summary>
    static void DrawControllerSwitcher();

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©çŠ¶æ…‹æƒ…å ±ã‚’æç”»
    /// </summary>
    static void DrawCameraState();

    // UIè¡¨ç¤ºãƒ•ãƒ©ã‚°
    static bool showManagerInfo_;
    static bool showControllerInfo_;
    static bool showAnimationInfo_;

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
    static std::unique_ptr<CameraAnimationEditor> animationEditor_;
    static bool useAdvancedEditor_;
};

#endif // _DEBUG

============================================================
File Path: GameProject/CameraSystem/CameraManager.cpp
============================================================
#include "CameraManager.h"
#include <algorithm>
#include <sstream>
#include "RandomEngine.h"
#include "GlobalVariables.h"

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
CameraManager* CameraManager::instance_ = nullptr;

CameraManager* CameraManager::GetInstance() {
    if (!instance_) {
        instance_ = new CameraManager();
    }
    return instance_;
}

void CameraManager::Initialize(Camera* camera) {
    camera_ = camera;
    controllers_.clear();
    nameToIndex_.clear();
    needsSort_ = false;

    // ã‚·ã‚§ã‚¤ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
    LoadShakeParameters();
}

void CameraManager::Finalize() {
    DeactivateAllControllers();
    controllers_.clear();
    nameToIndex_.clear();
    camera_ = nullptr;

    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å‰Šé™¤
    if (instance_) {
        delete instance_;
        instance_ = nullptr;
    }
}

void CameraManager::Update(float deltaTime) {
    if (!camera_) {
        return;
    }

    // ã‚½ãƒ¼ãƒˆãŒå¿…è¦ãªå ´åˆã¯å®Ÿè¡Œ
    if (needsSort_) {
        SortControllersByPriority();
    }

    // æœ€é«˜å„ªå…ˆåº¦ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å–å¾—
    ICameraController* activeController = GetActiveController();
    if (activeController) {
        activeController->Update(deltaTime);
    }

    // ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
    UpdateShake(deltaTime);

    // ã‚·ã‚§ã‚¤ã‚¯ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ã‚«ãƒ¡ãƒ©ä½ç½®ã«é©ç”¨
    ApplyShakeOffset();
}

void CameraManager::RegisterController(const std::string& name,
                                      std::unique_ptr<ICameraController> controller) {
    if (!controller) {
        return;
    }

    // æ—¢å­˜ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å‰Šé™¤
    RemoveController(name);

    // ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    controller->SetCamera(camera_);

    // æ–°ã—ã„ã‚¨ãƒ³ãƒˆãƒªã‚’è¿½åŠ 
    size_t newIndex = controllers_.size();
    controllers_.push_back({name, std::move(controller)});
    nameToIndex_[name] = newIndex;

    // ã‚½ãƒ¼ãƒˆãŒå¿…è¦
    needsSort_ = true;
}

ICameraController* CameraManager::GetController(const std::string& name) {
    auto it = nameToIndex_.find(name);
    if (it != nameToIndex_.end() && it->second < controllers_.size()) {
        return controllers_[it->second].controller.get();
    }
    return nullptr;
}

bool CameraManager::RemoveController(const std::string& name) {
    auto it = nameToIndex_.find(name);
    if (it == nameToIndex_.end()) {
        return false;
    }

    size_t indexToRemove = it->second;

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å‰Šé™¤
    controllers_.erase(controllers_.begin() + indexToRemove);
    nameToIndex_.erase(it);

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒžãƒƒãƒ—ã‚’æ›´æ–°
    nameToIndex_.clear();
    for (size_t i = 0; i < controllers_.size(); ++i) {
        nameToIndex_[controllers_[i].name] = i;
    }

    return true;
}

bool CameraManager::ActivateController(const std::string& name) {
    if (GetActiveControllerName() == name) {
        // æ—¢ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã®ã§ä½•ã‚‚ã—ãªã„
        return true;
    }

    DeactivateAllControllers();
    ICameraController* controller = GetController(name);
    if (controller) {
        controller->Activate();
            return true;
    }
    return false;
}

bool CameraManager::DeactivateController(const std::string& name) {
    ICameraController* controller = GetController(name);
    if (controller) {
        controller->Deactivate();
            return true;
    }
    return false;
}

void CameraManager::DeactivateAllControllers() {
    for (auto& entry : controllers_) {
        entry.controller->Deactivate();
    }
}

ICameraController* CameraManager::GetActiveController() const {
    int activeIndex = FindHighestPriorityActiveController();
    if (activeIndex >= 0 && activeIndex < static_cast<int>(controllers_.size())) {
        return controllers_[activeIndex].controller.get();
    }
    return nullptr;
}

std::string CameraManager::GetActiveControllerName() const {
    int activeIndex = FindHighestPriorityActiveController();
    if (activeIndex >= 0 && activeIndex < static_cast<int>(controllers_.size())) {
        return controllers_[activeIndex].name;
    }
    return "";
}

std::string CameraManager::GetDebugInfo() const {
    std::stringstream ss;
    ss << "=== Camera Manager Debug Info ===" << '\n';
    ss << "Total Controllers: " << controllers_.size() << '\n';
    ss << "Active Controller: " << GetActiveControllerName() << '\n';
    ss << '\n';

    ss << "Controller List (Priority Order):" << '\n';
    for (const auto& entry : controllers_) {
        ss << "  - " << entry.name;
        ss << " [Priority: " << static_cast<int>(entry.controller->GetPriority()) << "]";
        ss << " [Active: " << (entry.controller->IsActive() ? "Yes" : "No") << "]";
        ss << '\n';
    }

    return ss.str();
}

void CameraManager::SortControllersByPriority() {
    // å„ªå…ˆåº¦ã§ã‚½ãƒ¼ãƒˆï¼ˆé™é †ï¼‰
    std::sort(controllers_.begin(), controllers_.end());

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒžãƒƒãƒ—ã‚’å†æ§‹ç¯‰
    nameToIndex_.clear();
    for (size_t i = 0; i < controllers_.size(); ++i) {
        nameToIndex_[controllers_[i].name] = i;
    }

    needsSort_ = false;
}

int CameraManager::FindHighestPriorityActiveController() const {
    // æ—¢ã«ã‚½ãƒ¼ãƒˆæ¸ˆã¿ãªã®ã§ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒæœ€é«˜å„ªå…ˆåº¦
    for (size_t i = 0; i < controllers_.size(); ++i) {
        if (controllers_[i].controller->IsActive()) {
            return static_cast<int>(i);
        }
    }
    return -1;
}

void CameraManager::StartShake(float intensity) {
    isShaking_ = true;
    shakeTimer_ = 0.0f;
    currentShakeIntensity_ = (intensity > 0.0f) ? intensity : shakeIntensity_;
}

void CameraManager::UpdateShake(float deltaTime) {
    if (!isShaking_) {
        shakeOffset_ = { 0.0f, 0.0f, 0.0f };
        return;
    }

    shakeTimer_ += deltaTime;

    if (shakeTimer_ >= shakeDuration_) {
        isShaking_ = false;
        shakeTimer_ = 0.0f;
        shakeOffset_ = { 0.0f, 0.0f, 0.0f };
        return;
    }

    // æ¸›è¡°ä¿‚æ•°ï¼ˆ1.0â†’0.0ã¸ç·šå½¢æ¸›è¡°ï¼‰
    float decay = 1.0f - (shakeTimer_ / shakeDuration_);

    // ãƒ©ãƒ³ãƒ€ãƒ ã‚ªãƒ•ã‚»ãƒƒãƒˆç”Ÿæˆ
    RandomEngine* rng = RandomEngine::GetInstance();
    shakeOffset_.x = rng->GetFloat(-currentShakeIntensity_, currentShakeIntensity_) * decay;
    shakeOffset_.y = rng->GetFloat(-currentShakeIntensity_, currentShakeIntensity_) * decay;
    shakeOffset_.z = rng->GetFloat(-currentShakeIntensity_, currentShakeIntensity_) * decay;
}

void CameraManager::ApplyShakeOffset() {
    if (!camera_) return;

    Vector3 currentPos = camera_->GetTranslate();
    camera_->SetTranslate(currentPos + shakeOffset_);
}

void CameraManager::LoadShakeParameters() {
    GlobalVariables* gv = GlobalVariables::GetInstance();
    shakeDuration_ = gv->GetValueFloat("CameraShake", "Duration");
    shakeIntensity_ = gv->GetValueFloat("CameraShake", "Intensity");
}

============================================================
File Path: GameProject/CameraSystem/CameraManager.h
============================================================
#pragma once
#include "Controller/ICameraController.h"
#include "Camera.h"
#include "Vector3.h"
#include <vector>
#include <memory>
#include <string>
#include <unordered_map>

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ çµ±åˆç®¡ç†ã‚¯ãƒ©ã‚¹
/// å„ªå…ˆåº¦ãƒ™ãƒ¼ã‚¹ã®æ¨©é™ç®¡ç†ã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼èª¿åœã‚’æ‹…å½“
/// </summary>
class CameraManager {
public:
    /// <summary>
    /// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—
    /// </summary>
    /// <returns>CameraManagerã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</returns>
    static CameraManager* GetInstance();

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    /// <param name="camera">ç®¡ç†å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©</param>
    void Initialize(Camera* camera);

    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize();

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// æœ€é«˜å„ªå…ˆåº¦ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã¿ã‚’å®Ÿè¡Œ
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“ï¼ˆç§’ï¼‰</param>
    void Update(float deltaTime);

    //==================== ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ç®¡ç† ====================

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ç™»éŒ²
    /// </summary>
    /// <param name="name">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼è­˜åˆ¥å</param>
    /// <param name="controller">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
    void RegisterController(const std::string& name,
                           std::unique_ptr<ICameraController> controller);

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å–å¾—
    /// </summary>
    /// <param name="name">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼è­˜åˆ¥å</param>
    /// <returns>ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆnullptrï¼‰</returns>
    ICameraController* GetController(const std::string& name);

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å‰Šé™¤
    /// </summary>
    /// <param name="name">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼è­˜åˆ¥å</param>
    /// <returns>å‰Šé™¤æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool RemoveController(const std::string& name);

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    /// </summary>
    /// <param name="name">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼è­˜åˆ¥å</param>
    /// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool ActivateController(const std::string& name);

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    /// </summary>
    /// <param name="name">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼è­˜åˆ¥å</param>
    /// <returns>éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool DeactivateController(const std::string& name);

    /// <summary>
    /// å…¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    /// </summary>
    void DeactivateAllControllers();

    //==================== çŠ¶æ…‹å–å¾— ====================

    /// <summary>
    /// ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªæœ€é«˜å„ªå…ˆåº¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å–å¾—
    /// </summary>
    /// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆnullptrï¼‰</returns>
    ICameraController* GetActiveController() const;

    /// <summary>
    /// ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªæœ€é«˜å„ªå…ˆåº¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®åå‰ã‚’å–å¾—
    /// </summary>
    /// <returns>ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åï¼ˆå­˜åœ¨ã—ãªã„å ´åˆç©ºæ–‡å­—åˆ—ï¼‰</returns>
    std::string GetActiveControllerName() const;

    /// <summary>
    /// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æ•°ã‚’å–å¾—
    /// </summary>
    /// <returns>ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æ•°</returns>
    size_t GetControllerCount() const { return controllers_.size(); }

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã‚’å–å¾—
    /// </summary>
    /// <returns>ç®¡ç†å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©</returns>
    Camera* GetCamera() const { return camera_; }

    //==================== ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ ====================

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ã‚’é–‹å§‹
    /// </summary>
    /// <param name="intensity">ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦ï¼ˆ0ä»¥ä¸‹ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä½¿ç”¨ï¼‰</param>
    void StartShake(float intensity = 0.0f);

    //==================== ãƒ‡ãƒãƒƒã‚° ====================

    /// <summary>
    /// ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ–‡å­—åˆ—</returns>
    std::string GetDebugInfo() const;

private:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ï¼‰
    /// </summary>
    CameraManager() = default;

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~CameraManager() = default;

    // ã‚³ãƒ”ãƒ¼ãƒ»ãƒ ãƒ¼ãƒ–ç¦æ­¢
    CameraManager(const CameraManager&) = delete;
    CameraManager& operator=(const CameraManager&) = delete;
    CameraManager(CameraManager&&) = delete;
    CameraManager& operator=(CameraManager&&) = delete;

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å„ªå…ˆåº¦é †ã«ã‚½ãƒ¼ãƒˆ
    /// </summary>
    void SortControllersByPriority();

    /// <summary>
    /// æœ€é«˜å„ªå…ˆåº¦ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’æ¤œç´¢
    /// </summary>
    /// <returns>è¦‹ã¤ã‹ã£ãŸã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ-1 = è¦‹ã¤ã‹ã‚‰ãªã„ï¼‰</returns>
    int FindHighestPriorityActiveController() const;

    /// <summary>
    /// ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
    /// </summary>
    /// <param name="deltaTime">ãƒ•ãƒ¬ãƒ¼ãƒ é–“éš”ï¼ˆç§’ï¼‰</param>
    void UpdateShake(float deltaTime);

    /// <summary>
    /// ã‚·ã‚§ã‚¤ã‚¯ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ã‚«ãƒ¡ãƒ©ã«é©ç”¨
    /// </summary>
    void ApplyShakeOffset();

    /// <summary>
    /// GlobalVariablesã‹ã‚‰ã‚·ã‚§ã‚¤ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
    /// </summary>
    void LoadShakeParameters();

private:
    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ç®¡ç†ã‚¨ãƒ³ãƒˆãƒª
    /// </summary>
    struct ControllerEntry {
        std::string name;                               ///< è­˜åˆ¥å
        std::unique_ptr<ICameraController> controller;  ///< ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å®Ÿä½“

        /// <summary>
        /// å„ªå…ˆåº¦ã«ã‚ˆã‚‹æ¯”è¼ƒæ¼”ç®—å­
        /// </summary>
        bool operator<(const ControllerEntry& other) const {
            return static_cast<int>(controller->GetPriority()) >
                   static_cast<int>(other.controller->GetPriority());
        }
    };

    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    static CameraManager* instance_;

    // ç®¡ç†å¯¾è±¡ã‚«ãƒ¡ãƒ©
    Camera* camera_ = nullptr;

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒªã‚¹ãƒˆï¼ˆå„ªå…ˆåº¦é †ï¼‰
    std::vector<ControllerEntry> controllers_;

    // åå‰ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¸ã®ãƒžãƒƒãƒ—ï¼ˆé«˜é€Ÿæ¤œç´¢ç”¨ï¼‰
    std::unordered_map<std::string, size_t> nameToIndex_;

    // ã‚½ãƒ¼ãƒˆãŒå¿…è¦ã‹ã®ãƒ•ãƒ©ã‚°
    bool needsSort_ = false;

    //==================== ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ ====================
    /// ã‚·ã‚§ã‚¤ã‚¯ä¸­ãƒ•ãƒ©ã‚°
    bool isShaking_ = false;
    /// ã‚·ã‚§ã‚¤ã‚¯ã‚¿ã‚¤ãƒžãƒ¼ï¼ˆçµŒéŽæ™‚é–“ï¼‰
    float shakeTimer_ = 0.0f;
    /// ã‚·ã‚§ã‚¤ã‚¯æŒç¶šæ™‚é–“
    float shakeDuration_ = 0.3f;
    /// ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
    float shakeIntensity_ = 0.5f;
    /// ç¾åœ¨ã®ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦ï¼ˆå®Ÿè¡Œæ™‚ï¼‰
    float currentShakeIntensity_ = 0.0f;
    /// æç”»ç”¨ã‚·ã‚§ã‚¤ã‚¯ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    Vector3 shakeOffset_ = { 0.0f, 0.0f, 0.0f };
};

============================================================
File Path: GameProject/CameraSystem/Controller/CameraAnimationController.cpp
============================================================
#include "CameraAnimationController.h"

CameraAnimationController::CameraAnimationController() {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
    animations_["Default"] = std::make_unique<CameraAnimation>();
    animations_["Default"]->SetAnimationName("Default");
    currentAnimationName_ = "Default";
}

void CameraAnimationController::Update(float deltaTime) {
    auto* animation = GetCurrentAnimation();
    if (!animation || !camera_) {
        return;
    }

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
    animation->Update(deltaTime);

    // å†ç”Ÿå®Œäº†æ™‚ã®è‡ªå‹•éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    if (autoDeactivateOnComplete_) {
        auto state = animation->GetPlayState();
        if (state == CameraAnimation::PlayState::STOPPED &&
            !animation->IsLooping()) {
            // ãƒ¯ãƒ³ã‚·ãƒ§ãƒƒãƒˆå†ç”ŸãŒå®Œäº†ã—ãŸã‚‰è‡ªå‹•çš„ã«éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
            isActive_ = false;
        }
    }
}

bool CameraAnimationController::IsActive() const {
    // isActive_ãŒtrueãªã‚‰ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æœ‰ç„¡ã«é–¢ã‚ã‚‰ãšã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã¨ã™ã‚‹
    // ã“ã‚Œã«ã‚ˆã‚Šãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰æ™‚ã«ç¢ºå®Ÿã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ãªã‚‹
    if (isActive_) {
        return true;
    }

    auto* animation = const_cast<CameraAnimationController*>(this)->GetCurrentAnimation();
    if (!animation) {
        return false;
    }

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿä¸­ã¾ãŸã¯ç·¨é›†ä¸­ã®å ´åˆã‚‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ–
    return animation->GetPlayState() == CameraAnimation::PlayState::PLAYING ||
        animation->IsEditingKeyframe();
}

void CameraAnimationController::Activate() {
    isActive_ = true;
    //auto* animation = GetCurrentAnimation();
    //if (animation) {
    //    animation->Play();
    //}
}

void CameraAnimationController::Deactivate() {
    isActive_ = false;
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->Stop();
    }
}

void CameraAnimationController::SetCamera(Camera* camera) {
    ICameraController::SetCamera(camera);

    // å…¨ã¦ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    for (auto& pair : animations_) {
        pair.second->SetCamera(camera);
    }
}

void CameraAnimationController::SetAnimationTarget(const Transform* target, bool applyToAll) {
    if (applyToAll) {
        // å…¨ã¦ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
        for (auto& pair : animations_) {
            pair.second->SetTarget(target);
        }
    }
    else {
        // ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¿ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
        auto* animation = GetCurrentAnimation();
        if (animation) {
            animation->SetTarget(target);
        }
    }
}

void CameraAnimationController::SetAnimationTargetByName(const std::string& animationName, const Transform* target) {
    auto it = animations_.find(animationName);
    if (it != animations_.end()) {
        it->second->SetTarget(target);
    }
}

void CameraAnimationController::SetCurrentAnimationTarget(const Transform* target) {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->SetTarget(target);
    }
}

bool CameraAnimationController::LoadAnimation(const std::string& name) {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«èª­ã¿è¾¼ã‚€ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ï¼‰
    auto* animation = GetCurrentAnimation();
    if (!animation) {
        return false;
    }
    return animation->LoadFromJson(name);
}

void CameraAnimationController::Play() {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->Play();
        isActive_ = true;
    }
}

void CameraAnimationController::Pause() {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->Pause();
    }
}

void CameraAnimationController::Stop() {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->Stop();
        isActive_ = false;
    }
}

void CameraAnimationController::Reset() {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->Reset();
    }
}

void CameraAnimationController::SetAnimationStartMode(CameraAnimation::StartMode mode, float blendDuration) {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->SetStartMode(mode);
        animation->SetBlendDuration(blendDuration);
    }
}

void CameraAnimationController::SetAnimationStartModeByName(const std::string& animationName,
    CameraAnimation::StartMode mode, float blendDuration) {
    auto it = animations_.find(animationName);
    if (it != animations_.end()) {
        it->second->SetStartMode(mode);
        it->second->SetBlendDuration(blendDuration);
    }
}

void CameraAnimationController::AddKeyframe(const CameraKeyframe& keyframe) {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->AddKeyframe(keyframe);
    }
}

void CameraAnimationController::AddKeyframeFromCurrentCamera(float time,
    CameraKeyframe::InterpolationType interpolation) {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->AddKeyframeFromCurrentCamera(time, interpolation);
    }
}

void CameraAnimationController::RemoveKeyframe(size_t index) {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->RemoveKeyframe(index);
    }
}

void CameraAnimationController::ClearKeyframes() {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->ClearKeyframes();
    }
}

void CameraAnimationController::SetLooping(bool loop) {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->SetLooping(loop);
    }
}

void CameraAnimationController::SetPlaySpeed(float speed) {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->SetPlaySpeed(speed);
    }
}

void CameraAnimationController::SetAnimationName(const std::string& name) {
    auto* animation = GetCurrentAnimation();
    if (animation) {
        animation->SetAnimationName(name);
    }
}

CameraAnimation::PlayState CameraAnimationController::GetPlayState() const {
    auto* animation = const_cast<CameraAnimationController*>(this)->GetCurrentAnimation();
    if (animation) {
        return animation->GetPlayState();
    }
    return CameraAnimation::PlayState::STOPPED;
}

float CameraAnimationController::GetDuration() const {
    auto* animation = const_cast<CameraAnimationController*>(this)->GetCurrentAnimation();
    if (animation) {
        return animation->GetDuration();
    }
    return 0.0f;
}

float CameraAnimationController::GetCurrentTime() const {
    auto* animation = const_cast<CameraAnimationController*>(this)->GetCurrentAnimation();
    if (animation) {
        return animation->GetPlaybackTime();
    }
    return 0.0f;
}

bool CameraAnimationController::IsEditingKeyframe() const {
    auto* anim = const_cast<CameraAnimationController*>(this)->GetCurrentAnimation();
    if (anim) {
        return anim->IsEditingKeyframe();
    }
    return false;
}

const Transform* CameraAnimationController::GetAnimationTarget() const {
    auto* anim = const_cast<CameraAnimationController*>(this)->GetCurrentAnimation();
    if (anim) {
        return anim->GetTarget();
    }
    return nullptr;
}

//==================== ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ã®å®Ÿè£… ====================

CameraAnimation* CameraAnimationController::GetCurrentAnimation() {
    auto it = animations_.find(currentAnimationName_);
    if (it != animations_.end()) {
        return it->second.get();
    }
    return nullptr;
}

CameraAnimation* CameraAnimationController::GetAnimation(const std::string& name) {
    auto it = animations_.find(name);
    if (it != animations_.end()) {
        return it->second.get();
    }
    return nullptr;
}

bool CameraAnimationController::CreateAnimation(const std::string& name) {
    // æ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯å¤±æ•—
    if (animations_.find(name) != animations_.end()) {
        return false;
    }

    // æ–°è¦ä½œæˆ
    animations_[name] = std::make_unique<CameraAnimation>();
    animations_[name]->SetAnimationName(name);

    // ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    if (camera_) {
        animations_[name]->SetCamera(camera_);
    }

    return true;
}

bool CameraAnimationController::SwitchAnimation(const std::string& name) {
    // å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    if (animations_.find(name) == animations_.end()) {
        return false;
    }

    // ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢ï¼ˆFOVå¾©å…ƒãªã—ï¼‰
    auto* current = GetCurrentAnimation();
    if (current) {
        current->StopWithoutRestore();
    }

    // åˆ‡ã‚Šæ›¿ãˆ
    currentAnimationName_ = name;

    // ã‚«ãƒ¡ãƒ©ã‚’å†è¨­å®š
    auto* newAnim = GetCurrentAnimation();
    if (newAnim && camera_) {
        newAnim->SetCamera(camera_);
    }

    return true;
}

bool CameraAnimationController::DeleteAnimation(const std::string& name) {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯å‰Šé™¤ä¸å¯
    if (name == "Default") {
        return false;
    }

    // å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    auto it = animations_.find(name);
    if (it == animations_.end()) {
        return false;
    }

    // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å ´åˆ
    if (name == currentAnimationName_) {
        // Defaultã«åˆ‡ã‚Šæ›¿ãˆ
        currentAnimationName_ = "Default";
    }

    // å‰Šé™¤
    animations_.erase(it);
    return true;
}

bool CameraAnimationController::RenameAnimation(const std::string& oldName, const std::string& newName) {
    // Defaultã¯ãƒªãƒãƒ¼ãƒ ä¸å¯
    if (oldName == "Default") {
        return false;
    }

    // å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    auto it = animations_.find(oldName);
    if (it == animations_.end()) {
        return false;
    }

    // æ–°ã—ã„åå‰ãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯å¤±æ•—
    if (animations_.find(newName) != animations_.end()) {
        return false;
    }

    // ç§»å‹•
    auto animation = std::move(it->second);
    animation->SetAnimationName(newName);
    animations_.erase(it);
    animations_[newName] = std::move(animation);

    // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å ´åˆã¯åå‰ã‚’æ›´æ–°
    if (oldName == currentAnimationName_) {
        currentAnimationName_ = newName;
    }

    return true;
}

bool CameraAnimationController::DuplicateAnimation(const std::string& sourceName, const std::string& newName) {
    // ã‚½ãƒ¼ã‚¹å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    auto* source = GetAnimation(sourceName);
    if (!source) {
        return false;
    }

    // æ–°ã—ã„åå‰ãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯å¤±æ•—
    if (animations_.find(newName) != animations_.end()) {
        return false;
    }

    // æ–°è¦ä½œæˆ
    animations_[newName] = std::make_unique<CameraAnimation>();
    animations_[newName]->SetAnimationName(newName);

    // ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    if (camera_) {
        animations_[newName]->SetCamera(camera_);
    }

    // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚³ãƒ”ãƒ¼
    for (size_t i = 0; i < source->GetKeyframeCount(); ++i) {
        animations_[newName]->AddKeyframe(source->GetKeyframe(i));
    }

    // è¨­å®šã‚’ã‚³ãƒ”ãƒ¼
    animations_[newName]->SetLooping(source->IsLooping());

    return true;
}

bool CameraAnimationController::LoadAnimationFromFile(const std::string& name) {
    // æ–°è¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
    if (!CreateAnimation(name)) {
        // æ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ä¸Šæ›¸ãç¢ºèªãŒå¿…è¦ã ãŒã€ã“ã“ã§ã¯å˜ç´”ã«å¤±æ•—ã¨ã™ã‚‹
        return false;
    }

    // JSONã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆfilepathã‚’æ­£ã—ãæ¸¡ã™ï¼‰
    auto* anim = GetAnimation(name);
    if (!anim || !anim->LoadFromJson(name)) {
        // å¤±æ•—ã—ãŸå ´åˆã¯å‰Šé™¤
        DeleteAnimation(name);
        return false;
    }

    return true;
}

bool CameraAnimationController::SaveAnimationToFile(const std::string& name) {
    auto* anim = GetAnimation(name);
    if (!anim) {
        return false;
    }

    return anim->SaveToJson(name);
}

std::vector<std::string> CameraAnimationController::GetAnimationList() const {
    std::vector<std::string> names;
    names.reserve(animations_.size());

    for (const auto& pair : animations_) {
        names.push_back(pair.first);
    }

    return names;
}

============================================================
File Path: GameProject/CameraSystem/Controller/CameraAnimationController.h
============================================================
#pragma once
#include "ICameraController.h"
#include "CameraAnimation/CameraAnimation.h"
#include <memory>
#include <string>

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿã‚’å„ªå…ˆåº¦ã‚·ã‚¹ãƒ†ãƒ ã§ç®¡ç†
/// </summary>
class CameraAnimationController : public ICameraController {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    CameraAnimationController();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~CameraAnimationController() override = default;

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“ï¼ˆç§’ï¼‰</param>
    void Update(float deltaTime) override;

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿé–‹å§‹ï¼‰
    /// </summary>
    void Activate() override;

    /// <summary>
    /// éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢ï¼‰
    /// </summary>
    void Deactivate() override;

    //==================== ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ ====================

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èª­ã¿è¾¼ã¿
    /// </summary>
    /// <param name="name">JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <returns>èª­ã¿è¾¼ã¿æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool LoadAnimation(const std::string& name);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ
    /// </summary>
    void Play();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸€æ™‚åœæ­¢
    /// </summary>
    void Pause();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢
    /// </summary>
    void Stop();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset();

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
    /// </summary>
    /// <param name="mode">é–‹å§‹ãƒ¢ãƒ¼ãƒ‰</param>
    /// <param name="blendDuration">ãƒ–ãƒ¬ãƒ³ãƒ‰æ™‚é–“ï¼ˆç§’ï¼‰</param>
    void SetAnimationStartMode(CameraAnimation::StartMode mode, float blendDuration = 0.5f);

    /// <summary>
    /// ç‰¹å®šã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹å§‹ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
    /// </summary>
    /// <param name="animationName">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <param name="mode">é–‹å§‹ãƒ¢ãƒ¼ãƒ‰</param>
    /// <param name="blendDuration">ãƒ–ãƒ¬ãƒ³ãƒ‰æ™‚é–“ï¼ˆç§’ï¼‰</param>
    void SetAnimationStartModeByName(const std::string& animationName,
                                      CameraAnimation::StartMode mode, float blendDuration = 0.5f);

    //==================== ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç† ====================

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿½åŠ 
    /// </summary>
    /// <param name="keyframe">è¿½åŠ ã™ã‚‹ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ </param>
    void AddKeyframe(const CameraKeyframe& keyframe);

    /// <summary>
    /// ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©çŠ¶æ…‹ã‹ã‚‰ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿½åŠ 
    /// </summary>
    /// <param name="time">ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚åˆ»</param>
    /// <param name="interpolation">è£œé–“ã‚¿ã‚¤ãƒ—</param>
    void AddKeyframeFromCurrentCamera(float time,
        CameraKeyframe::InterpolationType interpolation =
            CameraKeyframe::InterpolationType::LINEAR);

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å‰Šé™¤
    /// </summary>
    /// <param name="index">å‰Šé™¤ã™ã‚‹ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    void RemoveKeyframe(size_t index);

    /// <summary>
    /// ã™ã¹ã¦ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
    /// </summary>
    void ClearKeyframes();

    //==================== ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç† ====================

    /// <summary>
    /// æ–°è¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
    /// </summary>
    /// <param name="name">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <returns>ä½œæˆæˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool CreateAnimation(const std::string& name);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆ‡ã‚Šæ›¿ãˆ
    /// </summary>
    /// <param name="name">åˆ‡ã‚Šæ›¿ãˆå…ˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <returns>åˆ‡ã‚Šæ›¿ãˆæˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool SwitchAnimation(const std::string& name);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤
    /// </summary>
    /// <param name="name">å‰Šé™¤ã™ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <returns>å‰Šé™¤æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool DeleteAnimation(const std::string& name);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªãƒãƒ¼ãƒ 
    /// </summary>
    /// <param name="oldName">ç¾åœ¨ã®åå‰</param>
    /// <param name="newName">æ–°ã—ã„åå‰</param>
    /// <returns>ãƒªãƒãƒ¼ãƒ æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool RenameAnimation(const std::string& oldName, const std::string& newName);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¤‡è£½
    /// </summary>
    /// <param name="sourceName">è¤‡è£½å…ƒã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <param name="newName">è¤‡è£½å…ˆã®åå‰</param>
    /// <returns>è¤‡è£½æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool DuplicateAnimation(const std::string& sourceName, const std::string& newName);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
    /// </summary>
    /// <param name="filepath">JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <param name="name">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <returns>èª­ã¿è¾¼ã¿æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool LoadAnimationFromFile(const std::string& name);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    /// </summary>
    /// <param name="name">ä¿å­˜ã™ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <param name="filepath">ä¿å­˜å…ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <returns>ä¿å­˜æˆåŠŸã—ãŸå ´åˆtrue</returns>
    bool SaveAnimationToFile(const std::string& name);

    //==================== Setter ====================

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    /// </summary>
    /// <param name="camera">åˆ¶å¾¡å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©</param>
    void SetCamera(Camera* camera) override;

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    /// </summary>
    /// <param name="target">ç›¸å¯¾åº§æ¨™ã®åŸºæº–ã¨ãªã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆnullptrã§è§£é™¤ï¼‰</param>
    /// <param name="applyToAll">å…¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«é©ç”¨ã™ã‚‹å ´åˆtrueï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯falseï¼‰</param>
    void SetAnimationTarget(const Transform* target, bool applyToAll = false);

    /// <summary>
    /// ç‰¹å®šã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    /// </summary>
    /// <param name="animationName">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <param name="target">ç›¸å¯¾åº§æ¨™ã®åŸºæº–ã¨ãªã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆnullptrã§è§£é™¤ï¼‰</param>
    void SetAnimationTargetByName(const std::string& animationName, const Transform* target);

    /// <summary>
    /// ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¿ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    /// </summary>
    /// <param name="target">ç›¸å¯¾åº§æ¨™ã®åŸºæº–ã¨ãªã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆnullptrã§è§£é™¤ï¼‰</param>
    void SetCurrentAnimationTarget(const Transform* target);

    /// <summary>
    /// ãƒ«ãƒ¼ãƒ—è¨­å®š
    /// </summary>
    /// <param name="loop">ãƒ«ãƒ¼ãƒ—ã™ã‚‹å ´åˆtrue</param>
    void SetLooping(bool loop);

    /// <summary>
    /// å†ç”Ÿé€Ÿåº¦è¨­å®š
    /// </summary>
    /// <param name="speed">å†ç”Ÿé€Ÿåº¦ï¼ˆ1.0ãŒæ¨™æº–ï¼‰</param>
    void SetPlaySpeed(float speed);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åè¨­å®š
    /// </summary>
    /// <param name="name">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    void SetAnimationName(const std::string& name);

    //==================== Getter ====================

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’åˆ¤å®š
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿä¸­ã®ã¿ã‚¢ã‚¯ãƒ†ã‚£ãƒ–
    /// </summary>
    /// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå ´åˆtrue</returns>
    bool IsActive() const override;

    /// <summary>
    /// å„ªå…ˆåº¦ã‚’å–å¾—
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯æœ€é«˜å„ªå…ˆåº¦
    /// </summary>
    /// <returns>ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å„ªå…ˆåº¦</returns>
    CameraControlPriority GetPriority() const override {
        return CameraControlPriority::ANIMATION;
    }

    /// <summary>
    /// ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</returns>
    CameraAnimation* GetCurrentAnimation();

    /// <summary>
    /// æŒ‡å®šã—ãŸåå‰ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å–å¾—
    /// </summary>
    /// <param name="name">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</param>
    /// <returns>ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆå­˜åœ¨ã—ãªã„å ´åˆnullptrï¼‰</returns>
    CameraAnimation* GetAnimation(const std::string& name);

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åã®ãƒªã‚¹ãƒˆã‚’å–å¾—
    /// </summary>
    /// <returns>å…¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åã®ãƒªã‚¹ãƒˆ</returns>
    std::vector<std::string> GetAnimationList() const;

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ•°ã‚’å–å¾—
    /// </summary>
    /// <returns>ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ•°</returns>
    size_t GetAnimationCount() const { return animations_.size(); }

    /// <summary>
    /// ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å</returns>
    const std::string& GetCurrentAnimationName() const { return currentAnimationName_; }

    /// <summary>
    /// å†ç”ŸçŠ¶æ…‹ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®å†ç”ŸçŠ¶æ…‹</returns>
    CameraAnimation::PlayState GetPlayState() const;

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ç·æ™‚é–“ã‚’å–å¾—
    /// </summary>
    /// <returns>ç·æ™‚é–“ï¼ˆç§’ï¼‰</returns>
    float GetDuration() const;

    /// <summary>
    /// ç¾åœ¨ã®å†ç”Ÿæ™‚é–“ã‚’å–å¾—
    /// </summary>
    /// <returns>å†ç”Ÿæ™‚é–“ï¼ˆç§’ï¼‰</returns>
    float GetCurrentTime() const;

    /// <summary>
    /// ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç·¨é›†ä¸­ã‹ã‚’åˆ¤å®š
    /// </summary>
    /// <returns>ç·¨é›†ä¸­ã®å ´åˆtrue</returns>
    bool IsEditingKeyframe() const;

    /// <summary>
    /// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆnullptrï¼‰</returns>
    const Transform* GetAnimationTarget() const;

private:
    // ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆè¤‡æ•°ç®¡ç†ï¼‰
    std::map<std::string, std::unique_ptr<CameraAnimation>> animations_;

    // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å
    std::string currentAnimationName_ = "Default";

    // å†ç”Ÿå®Œäº†æ™‚ã«è‡ªå‹•ã§éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã™ã‚‹ã‹ã®ãƒ•ãƒ©ã‚°
    bool autoDeactivateOnComplete_ = true;
};

============================================================
File Path: GameProject/CameraSystem/Controller/ICameraController.h
============================================================
#pragma once
#include "Camera.h"
#include "Transform.h"
#include <memory>
#include <vector>

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å„ªå…ˆåº¦å®šç¾©
/// æ•°å€¤ãŒå¤§ãã„ã»ã©å„ªå…ˆåº¦ãŒé«˜ã„
/// </summary>
enum class CameraControlPriority {
    USER_INPUT = 0,        ///< ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ï¼ˆæœ€ä½Žå„ªå…ˆåº¦ï¼‰
    FOLLOW_DEFAULT = 50,   ///< ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¿½å¾“
    SCRIPTED_EVENT = 75,   ///< ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¤ãƒ™ãƒ³ãƒˆ
    ANIMATION = 100,       ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿï¼ˆæœ€é«˜å„ªå…ˆåº¦ï¼‰
    DEBUG_OVERRIDE = 999   ///< ãƒ‡ãƒãƒƒã‚°ç”¨å¼·åˆ¶ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
};

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
/// å˜ä¸€è²¬ä»»åŽŸå‰‡ã«åŸºã¥ãè¨­è¨ˆ
/// </summary>
class ICameraController {
public:
    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~ICameraController() = default;

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“ï¼ˆç§’ï¼‰</param>
    virtual void Update(float deltaTime) = 0;

    /// <summary>
    /// ã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã‚’åˆ¤å®š
    /// </summary>
    /// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå ´åˆtrue</returns>
    virtual bool IsActive() const = 0;

    /// <summary>
    /// å„ªå…ˆåº¦ã‚’å–å¾—
    /// </summary>
    /// <returns>ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å„ªå…ˆåº¦</returns>
    virtual CameraControlPriority GetPriority() const = 0;

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    /// </summary>
    virtual void Activate() = 0;

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    /// </summary>
    virtual void Deactivate() = 0;

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    /// </summary>
    /// <param name="camera">åˆ¶å¾¡å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©</param>
    virtual void SetCamera(Camera* camera) { camera_ = camera; }

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã‚’å–å¾—
    /// </summary>
    /// <returns>åˆ¶å¾¡å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©</returns>
    Camera* GetCamera() const { return camera_; }

protected:
    Camera* camera_ = nullptr;  ///< åˆ¶å¾¡å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©
    bool isActive_ = false;     ///< ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹
};

/// <summary>
/// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¿½å¾“åž‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class TargetedCameraController : public ICameraController {
public:
    /// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    /// </summary>
    /// <param name="target">è¿½å¾“å¯¾è±¡ã®Transform</param>
    virtual void SetTarget(const Transform* target) {
        primaryTarget_ = target;
    }

    /// <summary>
    /// è¿½åŠ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®šï¼ˆãƒžãƒ«ãƒã‚¿ãƒ¼ã‚²ãƒƒãƒˆå¯¾å¿œï¼‰
    /// </summary>
    /// <param name="targets">è¿½å¾“å¯¾è±¡ã®Transformé…åˆ—</param>
    virtual void SetAdditionalTargets(const std::vector<const Transform*>& targets) {
        additionalTargets_ = targets;
    }

protected:
    const Transform* primaryTarget_ = nullptr;              ///< ä¸»è¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
    std::vector<const Transform*> additionalTargets_;       ///< è¿½åŠ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé…åˆ—
};

============================================================
File Path: GameProject/CameraSystem/Controller/ThirdPersonController.cpp
============================================================
#include "ThirdPersonController.h"
#include "Vec3Func.h"
#include "Mat4x4Func.h"
#include <cmath>
#include <DirectXMath.h>

ThirdPersonController::ThirdPersonController() {
  input_ = Input::GetInstance();
}

void ThirdPersonController::Update(float deltaTime) {
  if (!isActive_ || !camera_ || !primaryTarget_) {
    return;
  }

  // æ¨™æº–FOVã‚’è¨­å®š
  if (camera_) {
    camera_->SetFovY(standardFov_);
  }

  ProcessInput(deltaTime);
  UpdateRotation();
  UpdatePosition();
}

void ThirdPersonController::Activate() {
  isActive_ = true;

  // æ¨™æº–FOVã‚’è¨­å®š
  if (camera_) {
    camera_->SetFovY(standardFov_);
  }

  if (primaryTarget_) {
    Reset();
  }
}

void ThirdPersonController::Reset() {
  if (!primaryTarget_ || !camera_) {
    return;
  }

  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã«å³åº§ã«ç§»å‹•
  interpolatedTargetPos_ = primaryTarget_->translate;

  // ã‚«ãƒ¡ãƒ©ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å‘ãã«åˆã‚ã›ã‚‹ï¼ˆå›žè»¢ã¯ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ï¼‰
  camera_->SetRotate(Vector3(0.0f, primaryTarget_->rotate.y, 0.0f));
  destinationAngleY_ = primaryTarget_->rotate.y;
  // CameraConfig::FirstPerson::DEFAULT_ANGLE_Xã¯ã™ã§ã«ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½
  destinationAngleX_ = CameraConfig::FirstPerson::DEFAULT_ANGLE_X;
  destinationAngleZ_ = 0.0f;

  // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
  offset_ = offsetOrigin_;

  // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’æ›´æ–°
  Vector3 offset = CalculateOffset();
  camera_->SetTranslate(interpolatedTargetPos_ + offset);
}

void ThirdPersonController::ProcessInput(float deltaTime) {
  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ³¨è¦–ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯æ‰‹å‹•å›žè»¢ã‚’ç„¡åŠ¹åŒ–
  if (enableLookAtTarget_ && secondaryTarget_) {
    isRotating_ = false;
    return;
  }

  // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰å…¥åŠ›
  if (!input_->RStickInDeadZone()) {
    isRotating_ = true;
    float rotateX = input_->GetRightStick().x;
    // rotateSpeed_ã¯ãƒ©ã‚¸ã‚¢ãƒ³/ãƒ•ãƒ¬ãƒ¼ãƒ å˜ä½ï¼ˆç´„0.00087ãƒ©ã‚¸ã‚¢ãƒ³ = ç´„0.05åº¦/ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
    destinationAngleY_ += rotateX * rotateSpeed_ *
      CameraConfig::FirstPerson::GAMEPAD_ROTATE_MULTIPLIER;
  } else {
    isRotating_ = false;
  }

  // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯æŠ¼ã—è¾¼ã¿ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å¾Œã‚ã«ãƒªã‚»ãƒƒãƒˆ
  if (input_->TriggerButton(XButtons.R_Thumbstick)) {
    destinationAngleY_ = primaryTarget_->rotate.y;
  }

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ã§ã‚«ãƒ¡ãƒ©å›žè»¢ï¼‰
  if (input_->PushKey(DIK_LEFT)) {
    destinationAngleY_ -= rotateSpeed_;
  }
  if (input_->PushKey(DIK_RIGHT)) {
    destinationAngleY_ += rotateSpeed_;
  }
}

void ThirdPersonController::UpdateRotation() {
  // ç¾åœ¨ã®å›žè»¢è§’åº¦ã‚’å–å¾—
  Vector3 currentRotation = camera_->GetRotate();

  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ³¨è¦–ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆ
  if (enableLookAtTarget_ && secondaryTarget_) {
    // ãƒœã‚¹ã¸ã®æ³¨è¦–å›žè»¢ã‚’è¨ˆç®—
    Vector3 lookAtRotation = CalculateLookAtRotation();

    // æ³¨è¦–å›žè»¢ã‚’ç›®æ¨™è§’åº¦ã¨ã—ã¦è¨­å®š
    destinationAngleX_ = lookAtRotation.x;
    destinationAngleY_ = lookAtRotation.y;
    destinationAngleZ_ = lookAtRotation.z;
  }

  // ç›®æ¨™è§’åº¦ã«å‘ã‘ã¦è£œé–“
  float angleY = Vec3::LerpShortAngle(currentRotation.y, destinationAngleY_, rotationLerpSpeed_);
  float angleX = Vec3::LerpShortAngle(currentRotation.x, destinationAngleX_, rotationLerpSpeed_);
  float angleZ = Vec3::LerpShortAngle(currentRotation.z, destinationAngleZ_, rotationLerpSpeed_);

  // ã‚«ãƒ¡ãƒ©ã«é©ç”¨
  camera_->SetRotate(Vector3(angleX, angleY, angleZ));
}

void ThirdPersonController::UpdatePosition() {
  // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å…¨è»¸ã§è£œé–“ï¼ˆã‚ˆã‚Šæ»‘ã‚‰ã‹ãªã‚«ãƒ¡ãƒ©å‹•ä½œã®ãŸã‚ï¼‰
  offset_.x = Vec3::Lerp(offset_.x, offsetOrigin_.x, offsetLerpSpeed_);
  offset_.y = Vec3::Lerp(offset_.y, offsetOrigin_.y, offsetLerpSpeed_);
  offset_.z = Vec3::Lerp(offset_.z, offsetOrigin_.z, offsetLerpSpeed_);

  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã«è£œé–“ã—ã¦è¿½å¾“
  interpolatedTargetPos_ = Vec3::Lerp(interpolatedTargetPos_,
    primaryTarget_->translate,
    followSmoothness_);

  // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’æ›´æ–°
  Vector3 offset = CalculateOffset();
  camera_->SetTranslate(interpolatedTargetPos_ + offset);
}

Vector3 ThirdPersonController::CalculateOffset() const {
  Vector3 offset = offset_;

  // ã‚«ãƒ¡ãƒ©ã®å›žè»¢è¡Œåˆ—ã‚’ç”Ÿæˆ
  Matrix4x4 rotationMatrix = Mat4x4::MakeRotateXYZ(camera_->GetRotate());

  // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›žè»¢å¤‰æ›
  offset = Mat4x4::TransformNormal(rotationMatrix, offset);

  return offset;
}

Vector3 ThirdPersonController::CalculateLookAtRotation() const {
  // ã‚»ã‚«ãƒ³ãƒ€ãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒç„¡åŠ¹ãªå ´åˆã¯ç¾åœ¨ã®å›žè»¢ã‚’è¿”ã™
  if (!secondaryTarget_ || !primaryTarget_) {
    return camera_->GetRotate();
  }

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ãƒœã‚¹ã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
  Vector3 direction = secondaryTarget_->translate - primaryTarget_->translate;

  // æ°´å¹³é¢ã§ã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆYè»¸å›žè»¢ã€ãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
  float angleY = std::atan2(direction.x, direction.z);

  // åž‚ç›´æ–¹å‘ã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆXè»¸å›žè»¢ã€ãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
  float horizontalDistance = std::sqrt(direction.x * direction.x + direction.z * direction.z);
  float angleX = -std::atan2(direction.y, horizontalDistance);

  // ä¸‰äººç§°è¦–ç‚¹ç”¨ã®è¦‹ä¸‹ã‚ã—è§’åº¦ã‚’è¿½åŠ ï¼ˆ15åº¦ã‚’ãƒ©ã‚¸ã‚¢ãƒ³ã§ï¼‰
  const float THIRD_PERSON_LOOK_DOWN_ANGLE = DirectX::XMConvertToRadians(15.0f);
  angleX += THIRD_PERSON_LOOK_DOWN_ANGLE;

  // ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ã®ã¾ã¾è¿”ã™ï¼ˆUpdateRotationã‚‚ãƒ©ã‚¸ã‚¢ãƒ³ã§å‡¦ç†ï¼‰
  return Vector3(angleX, angleY, 0.0f);
}

============================================================
File Path: GameProject/CameraSystem/Controller/ThirdPersonController.h
============================================================
#pragma once
#include "ICameraController.h"
#include "../CameraConfig.h"
#include "Vector3.h"
#include "Input.h"

/// <summary>
/// ä¸‰äººç§°è¦–ç‚¹ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¾Œæ–¹ã‹ã‚‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¿½å¾“ã—ã€ãƒœã‚¹æ³¨è¦–æ©Ÿèƒ½ã‚’æŒã¤
/// </summary>
class ThirdPersonController : public TargetedCameraController {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ThirdPersonController();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~ThirdPersonController() override = default;

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“ï¼ˆç§’ï¼‰</param>
    void Update(float deltaTime) override;

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’åˆ¤å®š
    /// </summary>
    /// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå ´åˆtrue</returns>
    bool IsActive() const override { return isActive_; }

    /// <summary>
    /// å„ªå…ˆåº¦ã‚’å–å¾—
    /// </summary>
    /// <returns>ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å„ªå…ˆåº¦</returns>
    CameraControlPriority GetPriority() const override {
        return CameraControlPriority::FOLLOW_DEFAULT;
    }

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    /// </summary>
    void Activate() override;

    /// <summary>
    /// éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    /// </summary>
    void Deactivate() override { isActive_ = false; }

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset();

    //==================== Setter ====================

    /// <summary>
    /// ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨­å®š
    /// </summary>
    /// <param name="offset">ã‚«ãƒ¡ãƒ©ã‚ªãƒ•ã‚»ãƒƒãƒˆ</param>
    void SetOffset(const Vector3& offset) {
        offset_ = offset;
        offsetOrigin_ = offset;
    }

    /// <summary>
    /// å›žè»¢é€Ÿåº¦ã‚’è¨­å®š
    /// </summary>
    /// <param name="speed">å›žè»¢é€Ÿåº¦</param>
    void SetRotateSpeed(float speed) {
        rotateSpeed_ = speed;
    }

    /// <summary>
    /// è¿½å¾“ã®æ»‘ã‚‰ã‹ã•ã‚’è¨­å®š
    /// </summary>
    /// <param name="smoothness">æ»‘ã‚‰ã‹ã•ï¼ˆ0.0-1.0ï¼‰</param>
    void SetSmoothness(float smoothness) {
        followSmoothness_ = smoothness;
    }

    /// <summary>
    /// ã‚»ã‚«ãƒ³ãƒ€ãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆãƒœã‚¹ãªã©ï¼‰ã‚’è¨­å®š
    /// </summary>
    /// <param name="target">æ³¨è¦–å¯¾è±¡ã®Transform</param>
    void SetSecondaryTarget(const Transform* target) {
        secondaryTarget_ = target;
    }

    /// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ³¨è¦–æ©Ÿèƒ½ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’è¨­å®š
    /// </summary>
    /// <param name="enable">æœ‰åŠ¹ã«ã™ã‚‹å ´åˆtrue</param>
    void EnableLookAtTarget(bool enable) {
        enableLookAtTarget_ = enable;
    }

    //==================== Getter ====================

    /// <summary>
    /// ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å–å¾—
    /// </summary>
    /// <returns>ã‚ªãƒ•ã‚»ãƒƒãƒˆå€¤</returns>
    const Vector3& GetOffset() const { return offset_; }

    /// <summary>
    /// è£œé–“ã•ã‚ŒãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’å–å¾—
    /// </summary>
    /// <returns>è£œé–“ä½ç½®</returns>
    const Vector3& GetInterpolatedTargetPosition() const {
        return interpolatedTargetPos_;
    }

private:
    /// <summary>
    /// å…¥åŠ›å‡¦ç†
    /// </summary>
    /// <param name="deltaTime">ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ </param>
    void ProcessInput(float deltaTime);

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©å›žè»¢ã‚’æ›´æ–°
    /// </summary>
    void UpdateRotation();

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’æ›´æ–°
    /// </summary>
    void UpdatePosition();

    /// <summary>
    /// ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ï¼ˆå›žè»¢ã‚’è€ƒæ…®ï¼‰
    /// </summary>
    /// <returns>è¨ˆç®—ã•ã‚ŒãŸã‚ªãƒ•ã‚»ãƒƒãƒˆ</returns>
    Vector3 CalculateOffset() const;

    /// <summary>
    /// ã‚»ã‚«ãƒ³ãƒ€ãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®æ³¨è¦–å›žè»¢ã‚’è¨ˆç®—
    /// </summary>
    /// <returns>æ³¨è¦–æ–¹å‘ã®å›žè»¢è§’åº¦</returns>
    Vector3 CalculateLookAtRotation() const;

private:
    // å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ 
    Input* input_ = nullptr;

    // ä½ç½®é–¢é€£
    Vector3 interpolatedTargetPos_ = {};
    // CameraConfig::FirstPersonã¯å®Ÿéš›ã«ã¯ThirdPersonç”¨ã®è¨­å®š
    Vector3 offset_ = {
        CameraConfig::FirstPerson::DEFAULT_OFFSET_X,
        CameraConfig::FirstPerson::DEFAULT_OFFSET_Y,
        CameraConfig::FirstPerson::DEFAULT_OFFSET_Z
    };
    Vector3 offsetOrigin_ = offset_;

    // å›žè»¢é–¢é€£ï¼ˆã™ã¹ã¦ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ï¼‰
    // CameraConfig::FirstPerson::DEFAULT_ANGLE_Xã¯ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ï¼ˆç´„8åº¦ï¼‰
    float destinationAngleX_ = CameraConfig::FirstPerson::DEFAULT_ANGLE_X;  // ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½
    float destinationAngleY_ = 0.0f;  // ãƒ©ã‚¸ã‚¢ãƒ³
    float destinationAngleZ_ = 0.0f;  // ãƒ©ã‚¸ã‚¢ãƒ³

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    // CameraConfig::FirstPersonã¯å®Ÿéš›ã«ã¯ThirdPersonç”¨ã®è¨­å®š
    // å›žè»¢é€Ÿåº¦ã‚’ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ã«å¤‰æ›ï¼ˆ0.05åº¦ â‰ˆ 0.00087ãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
    float rotateSpeed_ = CameraConfig::FirstPerson::DEFAULT_ROTATE_SPEED * (3.14159265359f / 180.0f);
    float followSmoothness_ = CameraConfig::FOLLOW_SMOOTHNESS;
    float offsetLerpSpeed_ = CameraConfig::OFFSET_LERP_SPEED;
    float rotationLerpSpeed_ = CameraConfig::ROTATION_LERP_SPEED;
    float standardFov_ = CameraConfig::STANDARD_FOV;

    // çŠ¶æ…‹
    bool isRotating_ = false;

    // ã‚»ã‚«ãƒ³ãƒ€ãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ©Ÿèƒ½
    const Transform* secondaryTarget_ = nullptr;  // æ³¨è¦–å¯¾è±¡ï¼ˆãƒœã‚¹ãªã©ï¼‰
    bool enableLookAtTarget_ = false;             // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ³¨è¦–æ©Ÿèƒ½ã®æœ‰åŠ¹/ç„¡åŠ¹
};

============================================================
File Path: GameProject/CameraSystem/Controller/TopDownController.cpp
============================================================
#include "TopDownController.h"
#include "Vec3Func.h"
#include <algorithm>
#include <numeric>

TopDownController::TopDownController() {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤è¨­å®š
    currentHeight_ = 88.f;
    currentBackOffset_ = -205.f;
}

void TopDownController::Update(float deltaTime) {
    if (!isActive_ || !camera_ || !primaryTarget_) {
        return;
    }

    // æ¨™æº–FOVã‚’è¨­å®š
    if (camera_) {
      camera_->SetFovY(standardFov_);
    }

    UpdateCameraPosition();
}

void TopDownController::Activate() {
    isActive_ = true;

    // æ¨™æº–FOVã‚’è¨­å®š
    if (camera_) {
      camera_->SetFovY(standardFov_);
    }

    if (primaryTarget_) {
        Reset();
    }
}

void TopDownController::Reset() {
    if (!primaryTarget_ || !camera_) {
        return;
    }

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã«å³åº§ã«ç§»å‹•
    interpolatedTargetPos_ = CalculateFocusPoint();

    // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã¨è§’åº¦ã‚’è¨­å®š
    UpdateCameraPosition();
}

Vector3 TopDownController::CalculateFocusPoint() const {
    if (!primaryTarget_) {
        return Vector3{};
    }

    // å…¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä¸­å¿ƒã‚’è¨ˆç®—
    std::vector<Vector3> allPositions;
    allPositions.push_back(primaryTarget_->translate);

    for (const auto* target : additionalTargets_) {
        if (target) {
            allPositions.push_back(target->translate);
        }
    }

    // å¹³å‡ä½ç½®ã‚’è¨ˆç®—
    if (!allPositions.empty()) {
        Vector3 sum = std::accumulate(allPositions.begin(), allPositions.end(),
                                    Vector3{0.0f, 0.0f, 0.0f},
                                    [](const Vector3& a, const Vector3& b) {
                                        return Vec3::Add(a, b);
                                    });
        return Vec3::Multiply(sum, 1.0f / static_cast<float>(allPositions.size()));
    }

    return primaryTarget_->translate;
}

float TopDownController::CalculateMaxTargetDistance() const {
    if (!primaryTarget_ || additionalTargets_.empty()) {
        return 0.0f;
    }

    float maxDistance = 0.0f;

    // ãƒ—ãƒ©ã‚¤ãƒžãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨å„è¿½åŠ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé–“ã®è·é›¢ã‚’è¨ˆç®—
    for (const auto* target : additionalTargets_) {
        if (target) {
            Vector3 diff = Vec3::Subtract(primaryTarget_->translate, target->translate);
            float distance = static_cast<float>(Vec3::Length(diff));
            maxDistance = std::max(maxDistance, distance);
        }
    }

    // è¿½åŠ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåŒå£«ã®è·é›¢ã‚‚è€ƒæ…®
    for (size_t i = 0; i < additionalTargets_.size(); ++i) {
        for (size_t j = i + 1; j < additionalTargets_.size(); ++j) {
            if (additionalTargets_[i] && additionalTargets_[j]) {
                Vector3 diff = Vec3::Subtract(additionalTargets_[i]->translate,
                                            additionalTargets_[j]->translate);
                float distance = static_cast<float>(Vec3::Length(diff));
                maxDistance = std::max(maxDistance, distance);
            }
        }
    }

    return maxDistance;
}

void TopDownController::CalculateCameraParameters(float targetDistance,
                                                 float& outHeight,
                                                 float& outBackOffset) const {
    // è·é›¢ã«å¿œã˜ã¦é«˜åº¦ã‚’èª¿æ•´
    outHeight = baseHeight_ + targetDistance * heightMultiplier_;
    outHeight = std::clamp(outHeight, minHeight_, maxHeight_);

    // è·é›¢ã«å¿œã˜ã¦å¾Œæ–¹ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚‚èª¿æ•´
    outBackOffset = baseBackOffset_ - targetDistance * backOffsetMultiplier_;
    outBackOffset = std::clamp(outBackOffset, minBackOffset_, maxBackOffset_);
}

void TopDownController::UpdateCameraPosition() {
    // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãƒã‚¤ãƒ³ãƒˆã‚’è¨ˆç®—
    Vector3 focusPoint = CalculateFocusPoint();

    // æ»‘ã‚‰ã‹ã«è¿½å¾“
    interpolatedTargetPos_ = Vec3::Lerp(interpolatedTargetPos_, focusPoint, followSmoothness_);

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé–“ã®è·é›¢ã‚’è¨ˆç®—
    float targetDistance = CalculateMaxTargetDistance();

    // ã‚«ãƒ¡ãƒ©ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¨ˆç®—
    float targetHeight = baseHeight_;
    float targetBackOffset = baseBackOffset_;

    if (targetDistance > 0.0f) {
        CalculateCameraParameters(targetDistance, targetHeight, targetBackOffset);
    }

    // ç¾åœ¨ã®å€¤ã‚’æ»‘ã‚‰ã‹ã«æ›´æ–°
    currentHeight_ = Vec3::Lerp(currentHeight_, targetHeight, followSmoothness_);
    currentBackOffset_ = Vec3::Lerp(currentBackOffset_, targetBackOffset, followSmoothness_);

    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’è¨­å®š
    Vector3 cameraPos = interpolatedTargetPos_;
    cameraPos.y = currentHeight_;
    cameraPos.z += currentBackOffset_;

    camera_->SetTranslate(cameraPos);

    // ã‚«ãƒ¡ãƒ©ã®å›žè»¢ã‚’å›ºå®šï¼ˆä¿¯çž°è§’åº¦ï¼‰
    camera_->SetRotate(Vector3(cameraAngleX_, 0.0f, 0.0f));
}

============================================================
File Path: GameProject/CameraSystem/Controller/TopDownController.h
============================================================
#pragma once
#include "ICameraController.h"
#include "../CameraConfig.h"
#include "Vector3.h"

/// <summary>
/// ãƒˆãƒƒãƒ—ãƒ€ã‚¦ãƒ³è¦–ç‚¹ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
/// ä¿¯çž°è¦–ç‚¹ã§ã®å›ºå®šè§’åº¦ã‚«ãƒ¡ãƒ©åˆ¶å¾¡
/// </summary>
class TopDownController : public TargetedCameraController {
public:
  /// <summary>
  /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
  /// </summary>
  TopDownController();

  /// <summary>
  /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
  /// </summary>
  ~TopDownController() override = default;

  /// <summary>
  /// æ›´æ–°å‡¦ç†
  /// </summary>
  /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“ï¼ˆç§’ï¼‰</param>
  void Update(float deltaTime) override;

  /// <summary>
  /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’åˆ¤å®š
  /// </summary>
  /// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå ´åˆtrue</returns>
  bool IsActive() const override { return isActive_; }

  /// <summary>
  /// å„ªå…ˆåº¦ã‚’å–å¾—
  /// </summary>
  /// <returns>ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å„ªå…ˆåº¦</returns>
  CameraControlPriority GetPriority() const override {
    return CameraControlPriority::FOLLOW_DEFAULT;
  }

  /// <summary>
  /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
  /// </summary>
  void Activate() override;

  /// <summary>
  /// éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
  /// </summary>
  void Deactivate() override { isActive_ = false; }

  /// <summary>
  /// ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ
  /// </summary>
  void Reset();

  //==================== Setter ====================

  /// <summary>
  /// åŸºæº–é«˜ã•ã‚’è¨­å®š
  /// </summary>
  /// <param name="height">ã‚«ãƒ¡ãƒ©é«˜ã•</param>
  void SetBaseHeight(float height) {
    baseHeight_ = height;
  }

  /// <summary>
  /// ã‚«ãƒ¡ãƒ©è§’åº¦ã‚’è¨­å®š
  /// </summary>
  /// <param name="angleX">Xè»¸è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</param>
  void SetCameraAngle(float angleX) {
    cameraAngleX_ = angleX;
  }

  /// <summary>
  /// é«˜ã•å€çŽ‡ã‚’è¨­å®š
  /// </summary>
  /// <param name="multiplier">è·é›¢ã«å¿œã˜ãŸé«˜ã•å€çŽ‡</param>
  void SetHeightMultiplier(float multiplier) {
    heightMultiplier_ = multiplier;
  }

  /// <summary>
  /// è¿½å¾“ã®æ»‘ã‚‰ã‹ã•ã‚’è¨­å®š
  /// </summary>
  /// <param name="smoothness">æ»‘ã‚‰ã‹ã•ï¼ˆ0.0-1.0ï¼‰</param>
  void SetSmoothness(float smoothness) {
    followSmoothness_ = smoothness;
  }

  //==================== Getter ====================

  /// <summary>
  /// ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©é«˜ã•ã‚’å–å¾—
  /// </summary>
  /// <returns>ã‚«ãƒ¡ãƒ©é«˜ã•</returns>
  float GetCurrentHeight() const { return currentHeight_; }

  /// <summary>
  /// è£œé–“ã•ã‚ŒãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’å–å¾—
  /// </summary>
  /// <returns>è£œé–“ä½ç½®</returns>
  const Vector3& GetInterpolatedTargetPosition() const {
    return interpolatedTargetPos_;
  }

private:
  /// <summary>
  /// ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãƒã‚¤ãƒ³ãƒˆã‚’è¨ˆç®—
  /// è¤‡æ•°ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä¸­å¿ƒç‚¹ã‚’ç®—å‡º
  /// </summary>
  /// <returns>ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãƒã‚¤ãƒ³ãƒˆ</returns>
  Vector3 CalculateFocusPoint() const;

  /// <summary>
  /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé–“ã®æœ€å¤§è·é›¢ã‚’è¨ˆç®—
  /// </summary>
  /// <returns>æœ€å¤§è·é›¢</returns>
  float CalculateMaxTargetDistance() const;

  /// <summary>
  /// ã‚«ãƒ¡ãƒ©é«˜ã•ã¨å¾Œæ–¹ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
  /// </summary>
  /// <param name="targetDistance">ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé–“è·é›¢</param>
  /// <param name="outHeight">è¨ˆç®—ã•ã‚ŒãŸé«˜ã•ï¼ˆå‡ºåŠ›ï¼‰</param>
  /// <param name="outBackOffset">è¨ˆç®—ã•ã‚ŒãŸå¾Œæ–¹ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆå‡ºåŠ›ï¼‰</param>
  void CalculateCameraParameters(float targetDistance,
    float& outHeight,
    float& outBackOffset) const;

  /// <summary>
  /// ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’æ›´æ–°
  /// </summary>
  void UpdateCameraPosition();

private:
  // ä½ç½®é–¢é€£
  Vector3 interpolatedTargetPos_ = {};
  float currentHeight_ = CameraConfig::TopDown::BASE_HEIGHT;
  float currentBackOffset_ = CameraConfig::TopDown::BASE_BACK_OFFSET;

  // è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
  float baseHeight_ = CameraConfig::TopDown::BASE_HEIGHT;
  float heightMultiplier_ = CameraConfig::TopDown::HEIGHT_MULTIPLIER;
  float minHeight_ = CameraConfig::TopDown::MIN_HEIGHT;
  float maxHeight_ = CameraConfig::TopDown::MAX_HEIGHT;

  float cameraAngleX_ = CameraConfig::TopDown::DEFAULT_ANGLE_X;

  float baseBackOffset_ = CameraConfig::TopDown::BASE_BACK_OFFSET;
  float backOffsetMultiplier_ = CameraConfig::TopDown::BACK_OFFSET_MULTIPLIER;
  float minBackOffset_ = CameraConfig::TopDown::MIN_BACK_OFFSET;
  float maxBackOffset_ = CameraConfig::TopDown::MAX_BACK_OFFSET;

  float followSmoothness_ = CameraConfig::FOLLOW_SMOOTHNESS;

  float standardFov_ = CameraConfig::STANDARD_FOV;
};

============================================================
File Path: GameProject/Collision/BossBulletCollider.cpp
============================================================
#include "BossBulletCollider.h"
#include "../Object/Player/Player.h"
#include "CollisionTypeIdDef.h"
#include "CollisionManager.h"

BossBulletCollider::BossBulletCollider(BossBullet* owner)
    : owner_(owner) {
}

void BossBulletCollider::OnCollisionEnter(Collider* other) {
    if (!owner_ || !owner_->IsActive()) {
        return;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çªåˆ¤å®š
    if (other->GetTypeID() == static_cast<uint32_t>(CollisionTypeId::PLAYER)) {
        // å¤šé‡ãƒ’ãƒƒãƒˆé˜²æ­¢ãƒã‚§ãƒƒã‚¯
        void* targetPtr = other->GetOwner();
        if (hitTargets_.find(targetPtr) != hitTargets_.end()) {
            return;  // æ—¢ã«ãƒ’ãƒƒãƒˆæ¸ˆã¿
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å–å¾—
        Player* player = static_cast<Player*>(other->GetOwner());
        if (player) {
            hitPlayer_ = player;
            hitTargets_.insert(targetPtr);

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸Žãˆã‚‹
            player->OnHit(owner_->GetDamage());
            hasDealtDamage_ = true;

            // å¼¾ã‚’éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
            owner_->SetActive(false);

            // TODO: ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”Ÿæˆ
        }
    }
}

void BossBulletCollider::OnCollisionStay(Collider* other) {

}

void BossBulletCollider::OnCollisionExit(Collider* other) {
    // è¡çªçµ‚äº†å‡¦ç†
    if (other->GetOwner() == hitPlayer_) {
        hitPlayer_ = nullptr;
    }
}

void BossBulletCollider::Reset() {
    hitTargets_.clear();
    hitPlayer_ = nullptr;
    hasDealtDamage_ = false;
}

============================================================
File Path: GameProject/Collision/BossBulletCollider.h
============================================================
#pragma once

#include "SphereCollider.h"
#include "../Object/Projectile/BossBullet.h"
#include <unordered_set>

class BossBullet;
class Player;

/// <summary>
/// ãƒœã‚¹ã®å¼¾å°‚ç”¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
/// MeleeAttackColliderã¨åŒã˜è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã§å®Ÿè£…
/// </summary>
class BossBulletCollider : public SphereCollider {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    /// <param name="owner">æ‰€æœ‰è€…ï¼ˆBossBulletï¼‰</param>
    BossBulletCollider(BossBullet* owner);

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~BossBulletCollider() override = default;

    /// <summary>
    /// è¡çªé–‹å§‹æ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    void OnCollisionEnter(Collider* other) override;

    /// <summary>
    /// è¡çªç¶™ç¶šæ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    void OnCollisionStay(Collider* other) override;

    /// <summary>
    /// è¡çªçµ‚äº†æ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    void OnCollisionExit(Collider* other) override;

    /// <summary>
    /// ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset();

    /// <summary>
    /// ãƒ’ãƒƒãƒˆã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—
    /// </summary>
    Player* GetHitPlayer() const { return hitPlayer_; }

private:
    // æ‰€æœ‰è€…ï¼ˆBossBulletï¼‰ã¸ã®å‚ç…§
    BossBullet* owner_ = nullptr;

    // ãƒ’ãƒƒãƒˆæ¸ˆã¿ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆå¤šé‡ãƒ’ãƒƒãƒˆé˜²æ­¢ç”¨ï¼‰
    std::unordered_set<void*> hitTargets_;

    // ç¾åœ¨ãƒ’ãƒƒãƒˆã—ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    Player* hitPlayer_ = nullptr;

    // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ŽãˆãŸã‹ã©ã†ã‹
    bool hasDealtDamage_ = false;
};

============================================================
File Path: GameProject/Collision/BossMeleeAttackCollider.cpp
============================================================
#include "BossMeleeAttackCollider.h"
#include "../Object/Boss/Boss.h"
#include "../Object/Player/Player.h"
#include "CollisionTypeIdDef.h"
#include "GlobalVariables.h"

BossMeleeAttackCollider::BossMeleeAttackCollider(Boss* boss)
    : boss_(boss) {
    // GlobalVariablesã‹ã‚‰å€¤ã‚’å–å¾—
    GlobalVariables* gv = GlobalVariables::GetInstance();
    damage_ = gv->GetValueFloat("BossMeleeAttackCollider", "Damage");

    SetTypeID(static_cast<uint32_t>(CollisionTypeId::BOSS_ATTACK));
    SetActive(false);
}

void BossMeleeAttackCollider::OnCollisionEnter(Collider* other) {
    if (!other || hasHitPlayer_) return;

    uint32_t typeID = other->GetTypeID();

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çªåˆ¤å®š
    if (typeID == static_cast<uint32_t>(CollisionTypeId::PLAYER)) {
        Player* player = static_cast<Player*>(other->GetOwner());
        player->OnHit(damage_);
        hasHitPlayer_ = true;  // å¤šé‡ãƒ’ãƒƒãƒˆé˜²æ­¢
    }
}

void BossMeleeAttackCollider::OnCollisionStay(Collider* other) {
    // ç¶™ç¶šãƒ’ãƒƒãƒˆã¯è¡Œã‚ãªã„ï¼ˆ1å›žã®ã¿ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
    (void)other;
}

void BossMeleeAttackCollider::Reset() {
    hasHitPlayer_ = false;
}


============================================================
File Path: GameProject/Collision/BossMeleeAttackCollider.h
============================================================
#pragma once
#include "OBBCollider.h"

class Boss;
class Player;

/// <summary>
/// ãƒœã‚¹è¿‘æŽ¥æ”»æ’ƒç”¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¯ãƒ©ã‚¹
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã‚’ç®¡ç†
/// </summary>
class BossMeleeAttackCollider : public OBBCollider {
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="boss">ã“ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ‰€æœ‰ã™ã‚‹ãƒœã‚¹</param>
	BossMeleeAttackCollider(Boss* boss);

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	virtual ~BossMeleeAttackCollider() = default;

	/// <summary>
	/// è¡çªé–‹å§‹æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æŽ¥è§¦ã—ãŸå ´åˆãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸Žãˆã‚‹
	/// </summary>
	/// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionEnter(Collider* other) override;

	/// <summary>
	/// è¡çªç¶™ç¶šä¸­ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
	/// </summary>
	/// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionStay(Collider* other) override;

	/// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
	/// æ¬¡ã®æ”»æ’ƒã«å‚™ãˆã¦ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢
	/// </summary>
	void Reset();

	/// <summary>
	/// ãƒ€ãƒ¡ãƒ¼ã‚¸é‡ã‚’è¨­å®š
	/// </summary>
	/// <param name="damage">è¨­å®šã™ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸é‡</param>
	void SetDamage(float damage) { damage_ = damage; }

	/// <summary>
	/// ãƒ€ãƒ¡ãƒ¼ã‚¸é‡ã‚’å–å¾—
	/// </summary>
	/// <returns>ç¾åœ¨ã®ãƒ€ãƒ¡ãƒ¼ã‚¸é‡</returns>
	float GetDamage() const { return damage_; }

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ’ãƒƒãƒˆã—ãŸã‹ã©ã†ã‹ã‚’å–å¾—
	/// </summary>
	/// <returns>ãƒ’ãƒƒãƒˆæ¸ˆã¿ãªã‚‰true</returns>
	bool HasHitPlayer() const { return hasHitPlayer_; }

private:
	Boss* boss_ = nullptr;           ///< ã“ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ‰€æœ‰ã™ã‚‹ãƒœã‚¹
	float damage_ = 10.0f;           ///< æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸é‡
	bool hasHitPlayer_ = false;      ///< å¤šé‡ãƒ’ãƒƒãƒˆé˜²æ­¢ãƒ•ãƒ©ã‚°
};


============================================================
File Path: GameProject/Collision/CollisionTypeIdDef.h
============================================================
#pragma once
#include <cstdint>

/// <summary>
/// è¡çªåˆ¤å®šã‚¿ã‚¤ãƒ—IDå®šç¾©
/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚«ãƒ†ã‚´ãƒªã‚’è­˜åˆ¥ã—ã¦è¡çªå‡¦ç†ã‚’åˆ¶å¾¡
/// </summary>
enum class CollisionTypeId : uint32_t {
	DEFAULT,                /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¤ãƒ—
	PLAYER,                 /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“
	PLAYER_ATTACK,          /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¿‘æŽ¥æ”»æ’ƒ
	BOSS,                   /// æ•µã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
	BOSS_ATTACK,            /// æ•µã®æ”»æ’ƒ
	ENVIRONMENT,            /// ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
};

============================================================
File Path: GameProject/Collision/MeleeAttackCollider.cpp
============================================================
#include "MeleeAttackCollider.h"
#include "../Object/Player/Player.h"
#include "../Object/Boss/Boss.h"
#include "CollisionTypeIdDef.h"
#include "GlobalVariables.h"
#include "../CameraSystem/CameraManager.h"

MeleeAttackCollider::MeleeAttackCollider(Player* player)
    : player_(player) {
    // GlobalVariablesã‹ã‚‰å€¤ã‚’å–å¾—
    GlobalVariables* gv = GlobalVariables::GetInstance();
    attackDamage_ = gv->GetValueFloat("MeleeAttack", "AttackDamage");

    SetTypeID(static_cast<uint32_t>(CollisionTypeId::PLAYER_ATTACK));
    SetActive(false);
}

void MeleeAttackCollider::OnCollisionEnter(Collider* other) {
    if (!other) return;

    uint32_t typeID = other->GetTypeID();

    if (typeID == static_cast<uint32_t>(CollisionTypeId::BOSS)) {
        Boss* enemy = static_cast<Boss*>(other->GetOwner());
        if (enemy) {

            enemy->OnHit(attackDamage_, 1.0f);

            // ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ç™ºå‹•ï¼ˆæ”»æ’ƒãƒ’ãƒƒãƒˆæ™‚ã¯è»½ã‚ã«ï¼‰
            CameraManager::GetInstance()->StartShake(0.3f);

            if (!detectedEnemy_) {
                detectedEnemy_ = enemy;
            }
        }
    }
}

void MeleeAttackCollider::OnCollisionStay(Collider* other) {
    if (!other) return;

#ifdef _DEBUG
    collisionCount_++;
#endif

    uint32_t typeID = other->GetTypeID();

    if (typeID == static_cast<uint32_t>(CollisionTypeId::BOSS)) {
        Boss* enemy = static_cast<Boss*>(other->GetOwner());
        if (enemy && !detectedEnemy_) {
            detectedEnemy_ = enemy;
            if (canDamage)
            {
                enemy->OnHit(attackDamage_, 1.0f);

                // ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ç™ºå‹•ï¼ˆæ”»æ’ƒãƒ’ãƒƒãƒˆæ™‚ã¯è»½ã‚ã«ï¼‰
                CameraManager::GetInstance()->StartShake(0.3f);

                canDamage = false;
            }
        }
    }
}

void MeleeAttackCollider::Reset() {
    hitEnemies_.clear();
    detectedEnemy_ = nullptr;
#ifdef _DEBUG
    collisionCount_ = 0;
#endif
}

void MeleeAttackCollider::Damage()
{
    canDamage = true;
}

bool MeleeAttackCollider::HasHitEnemy(uint32_t enemyId) const {
    return hitEnemies_.find(enemyId) != hitEnemies_.end();
}

============================================================
File Path: GameProject/Collision/MeleeAttackCollider.h
============================================================
#pragma once
#include "OBBCollider.h"
#include <vector>
#include <unordered_set>

class Player;
class Boss;

/// <summary>
/// è¿‘æŽ¥æ”»æ’ƒç”¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¯ãƒ©ã‚¹
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¿‘æŽ¥æ”»æ’ƒåˆ¤å®šã¨æ•µã¸ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã‚’ç®¡ç†
/// </summary>
class MeleeAttackCollider : public OBBCollider {
private:
	Player* player_ = nullptr;  ///< ã“ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ‰€æœ‰ã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	std::unordered_set<uint32_t> hitEnemies_;  ///< ã“ã®æ”»æ’ƒã§æ—¢ã«ãƒ’ãƒƒãƒˆã—ãŸæ•µã®IDã‚»ãƒƒãƒˆï¼ˆå¤šé‡ãƒ’ãƒƒãƒˆé˜²æ­¢ç”¨ï¼‰
	Boss* detectedEnemy_ = nullptr;  ///< ç¾åœ¨æ¤œå‡ºã•ã‚Œã¦ã„ã‚‹æ•µã¸ã®å‚ç…§
	bool canDamage = false;  ///< ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸Žãˆã‚‰ã‚Œã‚‹çŠ¶æ…‹ã‹ã©ã†ã‹
	float attackDamage_ = 10.0f;  ///< æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸é‡ï¼ˆGlobalVariablesã‹ã‚‰å–å¾—ï¼‰

#ifdef _DEBUG
	int collisionCount_ = 0;  ///< ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šè¡çªæ¤œå‡ºå›žæ•°
#endif
	
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="player">ã“ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ‰€æœ‰ã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</param>
	MeleeAttackCollider(Player* player);

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	virtual ~MeleeAttackCollider() = default;

	/// <summary>
	/// è¡çªé–‹å§‹æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæ•µã‚’æ¤œå‡ºã—ã¦ãƒªã‚¹ãƒˆã«è¿½åŠ ï¼‰
	/// </summary>
	/// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionEnter(Collider* other) override;

	/// <summary>
	/// è¡çªç¶™ç¶šä¸­ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
	/// </summary>
	/// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionStay(Collider* other) override;

	/// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæ–°ã—ã„æ”»æ’ƒã®é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã™ï¼‰
	/// hitEnemiesãƒªã‚¹ãƒˆã¨detectedEnemyã‚’ã‚¯ãƒªã‚¢
	/// </summary>
	void Reset();

	/// <summary>
	/// æ¤œå‡ºã•ã‚ŒãŸæ•µå…¨å“¡ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸Žãˆã‚‹
	/// canDamageãƒ•ãƒ©ã‚°ãŒtrueã®æ™‚ã®ã¿å®Ÿè¡Œå¯èƒ½
	/// </summary>
	void Damage();

	/// <summary>
	/// ç¾åœ¨æ¤œå‡ºã•ã‚Œã¦ã„ã‚‹æ•µã‚’å–å¾—
	/// </summary>
	/// <returns>æ¤œå‡ºã•ã‚ŒãŸæ•µã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆã„ãªã„å ´åˆã¯nullptrï¼‰</returns>
	Boss* GetDetectedEnemy() const { return detectedEnemy_; }

	/// <summary>
	/// æŒ‡å®šã—ãŸæ•µIDãŒæ—¢ã«ãƒ’ãƒƒãƒˆæ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="enemyId">ãƒã‚§ãƒƒã‚¯ã™ã‚‹æ•µã®ID</param>
	/// <returns>ãƒ’ãƒƒãƒˆæ¸ˆã¿ãªã‚‰true</returns>
	bool HasHitEnemy(uint32_t enemyId) const;

#ifdef _DEBUG
	/// <summary>
	/// ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šè¡çªæ¤œå‡ºå›žæ•°ã‚’å–å¾—
	/// </summary>
	/// <returns>è¡çªæ¤œå‡ºå›žæ•°</returns>
	int GetCollisionCount() const { return collisionCount_; }
#endif
};

============================================================
File Path: GameProject/Collision/PlayerBulletCollider.cpp
============================================================
#include "PlayerBulletCollider.h"
#include "../Object/Projectile/PlayerBullet.h"
#include "../Object/Boss/Boss.h"
#include "CollisionTypeIdDef.h"
#include "CollisionManager.h"

PlayerBulletCollider::PlayerBulletCollider(PlayerBullet* owner)
    : owner_(owner) {
}

void PlayerBulletCollider::OnCollisionEnter(Collider* other) {
    if (!owner_ || !owner_->IsActive()) {
        return;
    }

    // ãƒœã‚¹ã¨ã®è¡çªåˆ¤å®š
    if (other->GetTypeID() == static_cast<uint32_t>(CollisionTypeId::BOSS)) {
        // å¤šé‡ãƒ’ãƒƒãƒˆé˜²æ­¢ãƒã‚§ãƒƒã‚¯
        void* targetPtr = other->GetOwner();
        if (hitTargets_.find(targetPtr) != hitTargets_.end()) {
            return;  // æ—¢ã«ãƒ’ãƒƒãƒˆæ¸ˆã¿
        }

        // ãƒœã‚¹ã®å–å¾—
        Boss* boss = static_cast<Boss*>(other->GetOwner());
        if (boss) {
            hitBoss_ = boss;
            hitTargets_.insert(targetPtr);

            // ãƒœã‚¹ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸Žãˆã‚‹
            boss->OnHit(owner_->GetDamage(), 0.5f);
            hasDealtDamage_ = true;

            // å¼¾ã‚’éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
            owner_->SetActive(false);
        }
    }
}

void PlayerBulletCollider::OnCollisionStay(Collider* other) {
    // ç¶™ç¶šå‡¦ç†ãªã—
}

void PlayerBulletCollider::OnCollisionExit(Collider* other) {
    // è¡çªçµ‚äº†å‡¦ç†
    if (other->GetOwner() == hitBoss_) {
        hitBoss_ = nullptr;
    }
}

void PlayerBulletCollider::Reset() {
    hitTargets_.clear();
    hitBoss_ = nullptr;
    hasDealtDamage_ = false;
}


============================================================
File Path: GameProject/Collision/PlayerBulletCollider.h
============================================================
#pragma once

#include "SphereCollider.h"
#include <unordered_set>

class PlayerBullet;
class Boss;

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾å°‚ç”¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
/// BossBulletColliderã¨å¯¾ç§°ã®è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³
/// </summary>
class PlayerBulletCollider : public SphereCollider {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    /// <param name="owner">æ‰€æœ‰è€…ï¼ˆPlayerBulletï¼‰</param>
    PlayerBulletCollider(PlayerBullet* owner);

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~PlayerBulletCollider() override = default;

    /// <summary>
    /// è¡çªé–‹å§‹æ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    void OnCollisionEnter(Collider* other) override;

    /// <summary>
    /// è¡çªç¶™ç¶šæ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    void OnCollisionStay(Collider* other) override;

    /// <summary>
    /// è¡çªçµ‚äº†æ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    void OnCollisionExit(Collider* other) override;

    /// <summary>
    /// ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset();

    /// <summary>
    /// ãƒ’ãƒƒãƒˆã—ãŸãƒœã‚¹ã‚’å–å¾—
    /// </summary>
    Boss* GetHitBoss() const { return hitBoss_; }

private:
    // æ‰€æœ‰è€…ï¼ˆPlayerBulletï¼‰ã¸ã®å‚ç…§
    PlayerBullet* owner_ = nullptr;

    // ãƒ’ãƒƒãƒˆæ¸ˆã¿ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆå¤šé‡ãƒ’ãƒƒãƒˆé˜²æ­¢ç”¨ï¼‰
    std::unordered_set<void*> hitTargets_;

    // ç¾åœ¨ãƒ’ãƒƒãƒˆã—ã¦ã„ã‚‹ãƒœã‚¹
    Boss* hitBoss_ = nullptr;

    // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ŽãˆãŸã‹ã©ã†ã‹
    bool hasDealtDamage_ = false;
};


============================================================
File Path: GameProject/Common/GameConst.h
============================================================
#pragma once

/// <summary>
/// ã‚²ãƒ¼ãƒ å…¨ä½“ã§ä½¿ç”¨ã™ã‚‹å®šæ•°å®šç¾©
/// å¤‰æ›´é »åº¦ãŒæ¥µã‚ã¦ä½Žã„å›ºå®šå€¤ã®ã¿ã‚’å®šç¾©
/// èª¿æ•´ãŒå¿…è¦ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯GlobalVariablesã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨
/// </summary>
namespace GameConst {

    /// <summary>
    /// ã‚¹ãƒ†ãƒ¼ã‚¸ã®ã®ç¯„å›²
    /// </summary>
    inline constexpr float kStageXMin = -100.0f;
    inline constexpr float kStageXMax = 100.0f;
    inline constexpr float kStageZMin = -140.0f;
    inline constexpr float kStageZMax = 60.0f;

    /// <summary>
    /// æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã®æœ‰åŠ¹åˆ¤å®šé–¾å€¤
    /// ã“ã‚Œã‚ˆã‚Šå°ã•ã„é•·ã•ã®ãƒ™ã‚¯ãƒˆãƒ«ã¯ç„¡åŠ¹ã¨ã¿ãªã™
    /// </summary>
    constexpr float kDirectionEpsilon = 0.01f;

    /// <summary>
    /// ã‚¨ãƒªã‚¢å¢ƒç•Œã‹ã‚‰ã®ãƒžãƒ¼ã‚¸ãƒ³
    /// ãƒœã‚¹ãŒã‚¹ãƒ†ãƒ¼ã‚¸ç«¯ã«è¿‘ã¥ãã™ãŽãªã„ãŸã‚ã®è·é›¢
    /// </summary>
    inline constexpr float kAreaMargin = 5.0f;

}


============================================================
File Path: GameProject/Input/InputHandler.cpp
============================================================
#include "InputHandler.h"
#include "Object/Player/Player.h"
#include "Input.h"
#include "Vector2.h"
#include "GlobalVariables.h"

InputHandler::InputHandler()
{
}

InputHandler::~InputHandler()
{
}

void InputHandler::Initialize()
{
  isMoving_ = false;
  isDashing_ = false;
  isAttacking_ = false;
  isShooting_ = false;
  isParrying_ = false;
  isPaused_ = false;
  moveDirection_ = Vector2(0.0f, 0.0f);
}

void InputHandler::Update()
{
  Input* input = Input::GetInstance();

  moveDirection_ = Vector2(0.0f, 0.0f); // åˆæœŸåŒ–
  aimDirection_ = Vector2(0.0f, 0.0f); // åˆæœŸåŒ–

  // ç§»å‹•å…¥åŠ›ï¼ˆå·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ + ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼‰
  if (input->IsConnect()) moveDirection_ += input->GetLeftStick();

  moveDirection_ += {static_cast<float>(input->PushKey(DIK_D) - input->PushKey(DIK_A)), static_cast<float>(input->PushKey(DIK_W) - input->PushKey(DIK_S)) };

  // ç…§æº–å…¥åŠ›ï¼ˆå³ã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼‰
  bool hasRightStickInput = false;
  if (input->IsConnect()) {
    hasRightStickInput = !input->RStickInDeadZone();
    if (hasRightStickInput) {
      Vector2 rightStick = input->GetRightStick();
      aimDirection_ = rightStick.Normalize();
    }
  }

  // å„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å…¥åŠ›çŠ¶æ…‹ã‚’æ›´æ–°
  isMoving_ = !input->LStickInDeadZone() || moveDirection_.Length() > 0.0f;
  isDashing_ = input->TriggerKey(DIK_SPACE) || input->TriggerButton(XButtons.A);
  isAttacking_ = input->TriggerKey(DIK_Z) || input->TriggerButton(XButtons.X);
  isShooting_ = hasRightStickInput;  // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ã§å°„æ’ƒåˆ¤å®š
  isParrying_ = input->TriggerKey(DIK_F) || input->TriggerButton(XButtons.B);
  isPaused_ = input->TriggerKey(DIK_ESCAPE) || input->TriggerButton(XButtons.Start);
}

void InputHandler::ResetInputs()
{
    moveDirection_ = Vector2(0.0f, 0.0f);
    isMoving_ = false;
    isDashing_ = false;
    isAttacking_ = false;
    isShooting_ = false;
    isParrying_ = false;
    isPaused_ = false;
}

bool InputHandler::IsMoving() const
{
  return isMoving_;
}

bool InputHandler::IsDashing() const
{
  return isDashing_;
}

bool InputHandler::IsAttacking() const
{
  return isAttacking_;
}

bool InputHandler::IsShooting() const
{
  return isShooting_;
}

bool InputHandler::IsParrying() const
{
  return isParrying_;
}

bool InputHandler::IsPaused() const
{
  return isPaused_;
}

Vector2 InputHandler::GetMoveDirection() const
{
  return moveDirection_;
}

Vector2 InputHandler::GetAimDirection() const
{
  return aimDirection_;
}

============================================================
File Path: GameProject/Input/InputHandler.h
============================================================
#pragma once
#include <memory>
#include "dinput.h"
#include "vector2.h"
#include "Xinput.h"

class Player;

/// <summary>
/// å…¥åŠ›å‡¦ç†ã‚¯ãƒ©ã‚¹
/// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã€ãƒžã‚¦ã‚¹ã€ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã‹ã‚‰ã®å…¥åŠ›ã‚’çµ±åˆç®¡ç†
/// </summary>
class InputHandler
{
public:
	InputHandler();
	~InputHandler();

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

    /// <summary>
    /// å…¨ã¦ã®å…¥åŠ›çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void ResetInputs();

	/// <summary>
	/// ç§»å‹•å…¥åŠ›ãŒã‚ã‚‹ã‹åˆ¤å®š
	/// </summary>
	/// <returns>ç§»å‹•å…¥åŠ›ä¸­ã®å ´åˆtrue</returns>
	bool IsMoving() const;

	/// <summary>
	/// ãƒ€ãƒƒã‚·ãƒ¥å…¥åŠ›ãŒã‚ã‚‹ã‹åˆ¤å®š
	/// </summary>
	/// <returns>ãƒ€ãƒƒã‚·ãƒ¥ãƒœã‚¿ãƒ³æŠ¼ä¸‹ä¸­ã®å ´åˆtrue</returns>
	bool IsDashing() const;

	/// <summary>
	/// æ”»æ’ƒå…¥åŠ›ãŒã‚ã‚‹ã‹åˆ¤å®š
	/// </summary>
	/// <returns>æ”»æ’ƒãƒœã‚¿ãƒ³æŠ¼ä¸‹ä¸­ã®å ´åˆtrue</returns>
	bool IsAttacking() const;

	/// <summary>
	/// å°„æ’ƒå…¥åŠ›ãŒã‚ã‚‹ã‹åˆ¤å®š
	/// </summary>
	/// <returns>å°„æ’ƒãƒœã‚¿ãƒ³æŠ¼ä¸‹ä¸­ã®å ´åˆtrue</returns>
	bool IsShooting() const;

	/// <summary>
	/// ãƒ‘ãƒªã‚£å…¥åŠ›ãŒã‚ã‚‹ã‹åˆ¤å®š
	/// </summary>
	/// <returns>ãƒ‘ãƒªã‚£ãƒœã‚¿ãƒ³æŠ¼ä¸‹ä¸­ã®å ´åˆtrue</returns>
	bool IsParrying() const;

	/// <summary>
	/// ãƒãƒ¼ã‚ºå…¥åŠ›ãŒã‚ã‚‹ã‹åˆ¤å®š
	/// </summary>
	/// <returns>ãƒãƒ¼ã‚ºãƒœã‚¿ãƒ³æŠ¼ä¸‹ä¸­ã®å ´åˆtrue</returns>
	bool IsPaused() const;

	/// <summary>
	/// ç§»å‹•æ–¹å‘ã‚’å–å¾—
	/// </summary>
	/// <returns>æ­£è¦åŒ–ã•ã‚ŒãŸç§»å‹•æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«</returns>
	Vector2 GetMoveDirection() const;

	/// <summary>
	/// ç…§æº–æ–¹å‘ã‚’å–å¾—ï¼ˆå³ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ï¼‰
	/// </summary>
	/// <returns>æ­£è¦åŒ–ã•ã‚ŒãŸç…§æº–æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«</returns>
	Vector2 GetAimDirection() const;

private:

	// ç§»å‹•å…¥åŠ›ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ãƒ©ã‚°ï¼ˆæ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ï¼‰
	bool isMoving_ = false;

	// ãƒ€ãƒƒã‚·ãƒ¥å…¥åŠ›ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ãƒ©ã‚°ï¼ˆæ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ï¼‰
	bool isDashing_ = false;

	// æ”»æ’ƒå…¥åŠ›ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ãƒ©ã‚°ï¼ˆæ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ï¼‰
	bool isAttacking_ = false;

	// å°„æ’ƒå…¥åŠ›ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ãƒ©ã‚°ï¼ˆæ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ï¼‰
	bool isShooting_ = false;

	// ãƒ‘ãƒªã‚£å…¥åŠ›ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ãƒ©ã‚°ï¼ˆæ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ï¼‰
	bool isParrying_ = false;

	// ãƒãƒ¼ã‚ºå…¥åŠ›ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ãƒ©ã‚°ï¼ˆæ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ï¼‰
	bool isPaused_ = false;

	// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸç§»å‹•æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆæ­£è¦åŒ–æ¸ˆã¿ã€æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ï¼‰
	Vector2 moveDirection_;

	// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸç…§æº–æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå³ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã€æ­£è¦åŒ–æ¸ˆã¿ã€æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ï¼‰
	Vector2 aimDirection_;
};

============================================================
File Path: GameProject/MyGame/MyGame.cpp
============================================================
#include "MyGame.h"
#include"Audio.h"
#include"Input.h"
#include "scene/SceneFactory.h"
#include "SceneManager.h"
#include "TextureManager.h"
#include "Draw2D.h"
#include "Object3dBasic.h"
#include "PostEffectManager.h"
#include "FrameTimer.h"
#include "GlobalVariables.h"
#include "ModelManager.h"
#include "GPUParticle.h"
#include "SpriteBasic.h"
#include "TransitionManager.h"

void MyGame::Initialize()
{
    winApp_->SetWindowSize(1920, 1080);

    winApp_->SetWindowTitle(L"LE3B_12_ã‚­ãƒ§ã‚¦_ã‚²ãƒ³ã‚½_Slash");

    TakoFramework::Initialize();

#pragma region æ±Žç”¨æ©Ÿèƒ½åˆæœŸåŒ–-------------------------------------------------------------------------------------------------------------------
    // å…¥åŠ›ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–
    Input::GetInstance()->Initialize(winApp_);

    // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®åˆæœŸåŒ–
    Audio::GetInstance()->Initialize("resources/Sound/");

#pragma endregion

    // ã‚·ãƒ¼ãƒ³ã®åˆæœŸåŒ–
    sceneFactory_ = std::make_unique<SceneFactory>();
    SceneManager::GetInstance()->SetSceneFactory(sceneFactory_.get());
    SceneManager::GetInstance()->ChangeScene("title", 0.0f);

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿
    TextureManager::GetInstance()->LoadTexture("white.png");
    TextureManager::GetInstance()->LoadTexture("black.png");
    TextureManager::GetInstance()->LoadTexture("circle.png");
    TextureManager::GetInstance()->LoadTexture("my_skybox.dds");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_1.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_2.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_3.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_4.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_5.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_6.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_7.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_8.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_9.png");
    TextureManager::GetInstance()->LoadTexture("title_text/title_text_10.png");
    TextureManager::GetInstance()->LoadTexture("title_button.png");
    TextureManager::GetInstance()->LoadTexture("game_button_text.png");
    TextureManager::GetInstance()->LoadTexture("gameClear_Text.png");
    TextureManager::GetInstance()->LoadTexture("gameOver_Text.png");

    // GlobalVariablesã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç™»éŒ²
    RegisterGlobalVariables();

    // GlobalVariablesã®Jsonãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
    GlobalVariables::GetInstance()->LoadFiles();

    // SpriteBasicã®ãƒªã‚µã‚¤ã‚ºã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ç™»éŒ²
    spriteBasicOnresizeId_ = winApp_->RegisterOnResizeFunc(std::bind(&SpriteBasic::OnResize, SpriteBasic::GetInstance(), std::placeholders::_1));

    // GPUãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åˆæœŸåŒ–
    GPUParticle::GetInstance()->Initialize(dx12_.get(), defaultCamera_.get());
}

void MyGame::Finalize()
{
    winApp_->UnregisterOnResizeFunc(spriteBasicOnresizeId_);

    // GPUãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è§£æ”¾
    GPUParticle::GetInstance()->Finalize();

    // Audioã®è§£æ”¾
    Audio::GetInstance()->Finalize();

    // å…¥åŠ›ã‚¯ãƒ©ã‚¹ã®è§£æ”¾
    Input::GetInstance()->Finalize();

    TakoFramework::Finalize();
}

void MyGame::Update()
{
    // ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
    defaultCamera_->Update();

    // å…¥åŠ›æƒ…å ±ã®æ›´æ–°
    Input::GetInstance()->Update();

    // F11ã‚­ãƒ¼ã§ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
    if (Input::GetInstance()->TriggerKey(DIK_F11)) {
        ToggleFullScreen();
    }

    // GPUãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°
    GPUParticle::GetInstance()->Update();

    TakoFramework::Update();

    //ã€€ã‚µã‚¦ãƒ³ãƒ‰ã®æ›´æ–°
    Audio::GetInstance()->Update();

    // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã®çŠ¶æ…‹ã‚’ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
    Input::GetInstance()->RefreshGamePadState();
}

void MyGame::Draw()
{
    /// ============================================= ///
    /// ------------------ã‚·ãƒ¼ãƒ³æç”»-------------------///
    /// ============================================= ///

    //ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆé©ç”¨å¯¾è±¡ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æç”»å…ˆã«è¨­å®š
    dx12_->SetEffectRenderTexture();

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ã®srvãƒ’ãƒ¼ãƒ—ã®è¨­å®š
    SrvManager::GetInstance()->BeginDraw();

    SceneManager::GetInstance()->Draw();

    GPUParticle::GetInstance()->Draw();

    Draw2D::GetInstance()->Draw();

    /// ===================================================== ///
    /// ------------------ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»-------------------///
    /// ===================================================== ///

      // ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æç”»
    PostEffectManager::GetInstance()->Draw();

    /// ===================================================== ///
    /// ------------ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆéžé©ç”¨å¯¾è±¡ã®æç”»---------------///
    /// ===================================================== ///
    // ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆéžé©ç”¨å¯¾è±¡ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æç”»å…ˆã«è¨­å®š
    dx12_->SetNonEffectRenderTexture();

    // ã‚·ãƒ¼ãƒ³ã®æç”»
    SceneManager::GetInstance()->DrawWithoutEffect();

    TransitionManager::GetInstance()->Draw();

    Draw2D::GetInstance()->Reset();

    /// ============================================= ///
    /// ---------æœ€çµ‚çµæžœã‚’ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã«æç”»---------///
    /// ============================================= ///
    bool isDrawToSwapChain = true;

#ifdef _DEBUG
    isDrawToSwapChain = !DebugUIManager::GetInstance()->IsWindowVisible("GameViewport");
#endif

    PostEffectManager::GetInstance()->DrawFinalResult(isDrawToSwapChain);


    /// ========================================= ///
    ///-------------------ImGui-------------------///
    /// ========================================= ///
#ifdef _DEBUG

    imguiManager_->Begin();

    TakoFramework::Draw();

    //SceneManager::GetInstance()->DrawImGui();

    Draw2D::GetInstance()->ImGui();

    imguiManager_->End();

    //imguiã®æç”»
    imguiManager_->Draw();
#endif


    // æç”»å¾Œã®å‡¦ç†
    dx12_->EndDraw();
}

void MyGame::RegisterGlobalVariables()
{
    GlobalVariables* gv = GlobalVariables::GetInstance();

    // === Input === //
    gv->CreateGroup("Input");
    gv->AddItem("Input", "TriggerThreshold", 0.5f);

    // === Player === //
    gv->CreateGroup("Player");
    gv->AddItem("Player", "BodyColliderSize", 3.2f);
    gv->AddItem("Player", "MeleeColliderX", 5.0f);
    gv->AddItem("Player", "MeleeColliderY", 2.0f);
    gv->AddItem("Player", "MeleeColliderZ", 17.0f);
    gv->AddItem("Player", "MeleeColliderOffsetZ", 10.0f);
    gv->AddItem("Player", "MoveInputDeadzone", 0.1f);
    gv->AddItem("Player", "RotationLerpSpeed", 0.2f);
    gv->AddItem("Player", "Speed", 0.5f);
    gv->AddItem("Player", "InitialY", 2.5f);
    gv->AddItem("Player", "InitialZ", -120.0f);
    gv->AddItem("Player", "AttackStartDistance", 5.0f);
    gv->AddItem("Player", "AttackMoveRotationLerp", 0.3f);
    gv->AddItem("Player", "BossLookatLerp", 1.15f);
    gv->AddItem("Player", "AttackMoveSpeed", 50.0f);

    // === MeleeAttack === //
    gv->CreateGroup("MeleeAttack");
    gv->AddItem("MeleeAttack", "AttackDamage", 10.0f);

    // === Boss === //
    gv->CreateGroup("Boss");
    gv->AddItem("Boss", "BodyColliderSize", 3.2f);
    gv->AddItem("Boss", "HitEffectDuration", 0.1f);
    gv->AddItem("Boss", "ShakeDuration", 0.3f);
    gv->AddItem("Boss", "ShakeIntensity", 0.2f);

    // === BossBullet === //
    gv->CreateGroup("BossBullet");
    gv->AddItem("BossBullet", "ColliderRadius", 1.0f);
    gv->AddItem("BossBullet", "Damage", 10.0f);
    gv->AddItem("BossBullet", "Lifetime", 5.0f);

    // === CameraShake === //
    gv->CreateGroup("CameraShake");
    gv->AddItem("CameraShake", "Duration", 0.3f);
    gv->AddItem("CameraShake", "Intensity", 0.5f);

    // === PlayerBullet === //
    gv->CreateGroup("PlayerBullet");
    gv->AddItem("PlayerBullet", "Damage", 10.0f);
    gv->AddItem("PlayerBullet", "Lifetime", 3.0f);
    gv->AddItem("PlayerBullet", "ColliderRadius", 0.5f);
    gv->AddItem("PlayerBullet", "Speed", 30.0f);

    // === AttackState === //
    gv->CreateGroup("AttackState");
    gv->AddItem("AttackState", "SearchTime", 0.1f);
    gv->AddItem("AttackState", "MoveTime", 0.1f);
    gv->AddItem("AttackState", "AttackDuration", 0.1f);
    gv->AddItem("AttackState", "MaxCombo", 2);
    gv->AddItem("AttackState", "ComboWindow", 1.0f);
    gv->AddItem("AttackState", "BlockRadius", 4.0f);
    gv->AddItem("AttackState", "BlockScale", 0.5f);

    // === DashState === //
    gv->CreateGroup("DashState");
    gv->AddItem("DashState", "Duration", 0.05f);
    gv->AddItem("DashState", "Speed", 10.0f);

    // === ParryState === //
    gv->CreateGroup("ParryState");
    gv->AddItem("ParryState", "ParryWindow", 0.2f);
    gv->AddItem("ParryState", "ParryDuration", 0.5f);

    // === ShootState === //
    gv->CreateGroup("ShootState");
    gv->AddItem("ShootState", "FireRate", 0.2f);
    gv->AddItem("ShootState", "MoveSpeedMultiplier", 0.5f);
    gv->AddItem("ShootState", "AimRotationLerp", 0.3f);

    // === BossMeleeAttackCollider === //
    gv->CreateGroup("BossMeleeAttackCollider");
    gv->AddItem("BossMeleeAttackCollider", "Damage", 10.0f);
    gv->AddItem("BossMeleeAttackCollider", "ColliderSizeX", 2.0f);
    gv->AddItem("BossMeleeAttackCollider", "ColliderSizeY", 2.0f);
    gv->AddItem("BossMeleeAttackCollider", "ColliderSizeZ", 2.0f);
    gv->AddItem("BossMeleeAttackCollider", "OffsetZ", 3.0f);
}


============================================================
File Path: GameProject/MyGame/MyGame.h
============================================================
#pragma once
#include"TakoFramework.h"
#include"Vector2.h"

/// <summary>
/// 3Dã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ã®ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹
/// ã‚²ãƒ¼ãƒ å…¨ä½“ã®åˆæœŸåŒ–ã€æ›´æ–°ã€æç”»å‡¦ç†ã‚’ç®¡ç†ã™ã‚‹
/// </summary>
class MyGame : public TakoFramework
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

  /// <summary>
  /// åˆæœŸåŒ–
  /// </summary>
  void Initialize() override;

  /// <summary>
  /// çµ‚äº†å‡¦ç†
  /// </summary>
  void Finalize() override;

  /// <summary>
  /// æ›´æ–°
  /// </summary>
  void Update() override;

  /// <summary>
  /// æç”»
  /// </summary>
  void Draw() override;

private: // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ãƒ³ãƒé–¢æ•°

  /// <summary>
  /// GlobalVariablesã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç™»éŒ²
  /// </summary>
  void RegisterGlobalVariables();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

  uint32_t spriteBasicOnresizeId_ = 0;
};

============================================================
File Path: GameProject/Object/Boss/Boss.cpp
============================================================
#include "Boss.h"

#include <algorithm>
#include "Object3d.h"
#include "OBBCollider.h"
#include "CollisionManager.h"
#include "../../Collision/CollisionTypeIdDef.h"
#include "../../Collision/BossMeleeAttackCollider.h"
#include "FrameTimer.h"
#include "Sprite.h"
#include "WinApp.h"
#include "BossBehaviorTree/BossBehaviorTree.h"
#include "GlobalVariables.h"
#include "EmitterManager.h"
#include "RandomEngine.h"

#ifdef _DEBUG
#include "ImGuiManager.h"
#include "BossNodeEditor/BossNodeEditor.h"
#endif

Boss::Boss()
{
}

Boss::~Boss()
{
}

void Boss::Initialize()
{
    // GlobalVariablesã‹ã‚‰å€¤ã‚’å–å¾—
    GlobalVariables* gv = GlobalVariables::GetInstance();

    model_ = std::make_unique<Object3d>();
    model_->Initialize();
    model_->SetModel("white_cube.gltf");
    model_->SetMaterialColor(Vector4(1.0f, 0.0f, 0.0f, 1.0f));

    transform_.translate = Vector3(0.0f, initialY_, initialZ_);
    transform_.rotate = Vector3(0.0f, 0.0f, 0.0f);
    transform_.scale = Vector3(1.0f, 1.0f, 1.0f);

    model_->SetTransform(transform_);

    // HPãƒãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
    hpBarSprite1_ = std::make_unique<Sprite>();
    hpBarSprite1_->Initialize("white.png");
    hpBarSize1_ = Vector2(500.0f, 30.0f);
    hpBarSprite1_->SetSize(hpBarSize1_);
    hpBarSprite1_->SetColor({ 0.5f, 0.5f, 1.0f, 1.0f });
    hpBarSprite1_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));

    hpBarSprite2_ = std::make_unique<Sprite>();
    hpBarSprite2_->Initialize("white.png");
    hpBarSize2_ = Vector2(500.0f, 30.0f);
    hpBarSprite2_->SetSize(hpBarSize2_);
    hpBarSprite2_->SetColor({ 1.0f, 0.3f, 0.3f, 1.0f });
    hpBarSprite2_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));

    hpBarBGSprite_ = std::make_unique<Sprite>();
    hpBarBGSprite_->Initialize("white.png");
    hpBarBGSprite_->SetSize(hpBarSize1_);
    hpBarBGSprite_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));

    // Colliderã®åˆæœŸåŒ–
    float bodySize = gv->GetValueFloat("Boss", "BodyColliderSize");
    bodyCollider_ = std::make_unique<OBBCollider>();
    bodyCollider_->SetTransform(&transform_);
    bodyCollider_->SetSize(Vector3(bodySize, bodySize, bodySize));
    bodyCollider_->SetOffset(Vector3(0.0f, 0.0f, 0.0f));
    bodyCollider_->SetTypeID(static_cast<uint32_t>(CollisionTypeId::BOSS));
    bodyCollider_->SetOwner(this);

    // CollisionManagerã«ç™»éŒ²
    CollisionManager::GetInstance()->AddCollider(bodyCollider_.get());

    // è¿‘æŽ¥æ”»æ’ƒç”¨ãƒ–ãƒ­ãƒƒã‚¯ã®åˆæœŸåŒ–
    meleeAttackBlock_ = std::make_unique<Object3d>();
    meleeAttackBlock_->Initialize();
    meleeAttackBlock_->SetModel("white_cube.gltf");
    meleeAttackBlock_->SetMaterialColor(Vector4(1.0f, 0.0f, 0.0f, 1.0f));  // ã‚ªãƒ¬ãƒ³ã‚¸è‰²

    // è¿‘æŽ¥æ”»æ’ƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®åˆæœŸåŒ–
    float meleeColliderSizeX = gv->GetValueFloat("BossMeleeAttackCollider", "ColliderSizeX");
    float meleeColliderSizeY = gv->GetValueFloat("BossMeleeAttackCollider", "ColliderSizeY");
    float meleeColliderSizeZ = gv->GetValueFloat("BossMeleeAttackCollider", "ColliderSizeZ");
    float meleeOffsetZ = gv->GetValueFloat("BossMeleeAttackCollider", "OffsetZ");
    meleeAttackCollider_ = std::make_unique<BossMeleeAttackCollider>(this);
    meleeAttackCollider_->SetTransform(&transform_);
    meleeAttackCollider_->SetSize(Vector3(meleeColliderSizeX, meleeColliderSizeY, meleeColliderSizeZ));
    meleeAttackCollider_->SetOffset(Vector3(0.0f, 0.0f, meleeOffsetZ));
    meleeAttackCollider_->SetOwner(this);


    // è¿‘æŽ¥æ”»æ’ƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’CollisionManagerã«ç™»éŒ²
    CollisionManager::GetInstance()->AddCollider(meleeAttackCollider_.get());

    // ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
    shakeDuration_ = gv->GetValueFloat("Boss", "ShakeDuration");
    shakeIntensity_ = gv->GetValueFloat("Boss", "ShakeIntensity");

    // ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã®åˆæœŸåŒ–
    behaviorTree_ = std::make_unique<BossBehaviorTree>(this, player_);

#ifdef _DEBUG
    // ãƒŽãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿ã®åˆæœŸåŒ–
    nodeEditor_ = std::make_unique<BossNodeEditor>();
    nodeEditor_->Initialize();
    BTNodePtr runtimeTree = nodeEditor_->BuildRuntimeTree();
    if (runtimeTree && behaviorTree_) {
        behaviorTree_->SetRootNode(runtimeTree);
    }
#endif

}

void Boss::Finalize()
{
    // Colliderã‚’å‰Šé™¤
    if (bodyCollider_) {
        CollisionManager::GetInstance()->RemoveCollider(bodyCollider_.get());
    }
    if (meleeAttackCollider_) {
        CollisionManager::GetInstance()->RemoveCollider(meleeAttackCollider_.get());
    }
}

void Boss::Update(float deltaTime)
{
    // HPãƒãƒ¼ã®æ›´æ–°
    if (phase_ == 1) {
        hpBarSprite1_->SetSize(Vector2(hpBarSize1_.x * (hp_ - kPhase2InitialHp) / kPhase2InitialHp, hpBarSize1_.y));
        hpBarSprite2_->SetSize(Vector2(hpBarSize2_.x, hpBarSize2_.y));
    }
    else if (phase_ == 2) {
        hpBarSprite1_->SetSize(Vector2(0.0f, hpBarSize1_.y));
        hpBarSprite2_->SetSize(Vector2(hpBarSize2_.x * (hp_ / kPhase2InitialHp), hpBarSize2_.y));
    }
    hpBarSprite1_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));
    hpBarSprite2_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));
    hpBarBGSprite_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));

    hpBarSprite1_->Update();
    hpBarSprite2_->Update();
    hpBarBGSprite_->Update();

    // ãƒ•ã‚§ãƒ¼ã‚ºã¨ãƒ©ã‚¤ãƒ•ã®æ›´æ–°
    UpdatePhaseAndLive();

    // AIã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
    if (!isDead_ && !isPause_) {
        if (behaviorTree_) {
            // ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã®æ›´æ–°
            behaviorTree_->Update(deltaTime);

#ifdef _DEBUG
            // ã‚¨ãƒ‡ã‚£ã‚¿ãŒæœ‰åŠ¹ãªå ´åˆã€å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            if (nodeEditor_ && showNodeEditor_) {
                BTNodePtr currentNode = behaviorTree_->GetCurrentRunningNode();
                if (currentNode) {
                    nodeEditor_->HighlightRunningNode(currentNode);
                }
            }
#endif
        }
    }

    // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
    float hitEffectDuration = GlobalVariables::GetInstance()->GetValueFloat("Boss", "HitEffectDuration");
    UpdateHitEffect(Vector4(1.0f, 1.0f, 1.0f, 1.0f), hitEffectDuration);

    // ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
    UpdateShake(deltaTime);

    // ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°ï¼ˆã‚·ã‚§ã‚¤ã‚¯ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨ï¼‰
    Transform renderTransform = transform_;
    renderTransform.translate += shakeOffset_;
    model_->SetTransform(renderTransform);
    model_->Update();
}

void Boss::Draw()
{
    model_->Draw();

    // æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã®æç”»ï¼ˆè¡¨ç¤ºãƒ•ãƒ©ã‚°ãŒtrueã®æ™‚ã®ã¿ï¼‰
    if (meleeAttackBlockVisible_ && meleeAttackBlock_) {
        meleeAttackBlock_->Draw();
    }
}

void Boss::DrawSprite()
{
    hpBarBGSprite_->Draw();
    hpBarSprite2_->Draw();
    hpBarSprite1_->Draw();
}

void Boss::OnHit(float damage, float shakeIntensityOverride)
{
    if (isReadyToChangePhase_) {
        phase_ = 2;
        isReadyToChangePhase_ = false;
    }

    hp_ -= damage;
    hp_ = std::max<float>(hp_, 0.0f);

    hitEffectTimer_ = 0.f;
    isPlayHitEffect_ = true;

    // ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹
    StartShake(shakeIntensityOverride);
}

void Boss::UpdateHitEffect(const Vector4& color, float duration)
{
    if (!isPlayHitEffect_)  return;

    hitEffectTimer_ += FrameTimer::GetInstance()->GetDeltaTime();

    if (hitEffectTimer_ <= duration) {
        model_->SetMaterialColor(color);
    }
    else {
        isPlayHitEffect_ = false;
        model_->SetMaterialColor(Vector4(1.0f, 0.0f, 0.0f, 1.0f));
    }
}

void Boss::UpdateShake(float deltaTime)
{
    if (!isShaking_) {
        shakeOffset_ = { 0.0f, 0.0f, 0.0f };
        return;
    }

    shakeTimer_ += deltaTime;

    if (shakeTimer_ >= shakeDuration_) {
        isShaking_ = false;
        shakeTimer_ = 0.0f;
        shakeOffset_ = { 0.0f, 0.0f, 0.0f };
        return;
    }

    // æ¸›è¡°ä¿‚æ•°ï¼ˆ1.0â†’0.0ã¸ç·šå½¢æ¸›è¡°ï¼‰
    float decay = 1.0f - (shakeTimer_ / shakeDuration_);

    // ãƒ©ãƒ³ãƒ€ãƒ ã‚ªãƒ•ã‚»ãƒƒãƒˆç”Ÿæˆ
    RandomEngine* rng = RandomEngine::GetInstance();
    shakeOffset_.x = rng->GetFloat(-currentShakeIntensity_, currentShakeIntensity_) * decay;
    shakeOffset_.y = rng->GetFloat(-currentShakeIntensity_, currentShakeIntensity_) * decay;
    shakeOffset_.z = rng->GetFloat(-currentShakeIntensity_, currentShakeIntensity_) * decay;
}

void Boss::StartShake(float intensity)
{
    isShaking_ = true;
    shakeTimer_ = 0.0f;
    // 0ä»¥ä¸‹ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨
    currentShakeIntensity_ = (intensity > 0.0f) ? intensity : shakeIntensity_;
}

void Boss::UpdatePhaseAndLive()
{
    if (hp_ <= kPhase2Threshold) {
        isReadyToChangePhase_ = true;
    }

    if (hp_ <= 0.0f && life_ > 0) {
        life_--;

        if (life_ == 0) {
            isDead_ = true;
            return;
        }

        isReadyToChangePhase_ = false;
        hp_ = kMaxHp;
        phase_ = 1;
    }
}

void Boss::DrawImGui()
{
#ifdef _DEBUG

    // ===== åŸºæœ¬ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ =====
    ImGui::SeparatorText("Basic Status");

    // HPè¡¨ç¤ºï¼ˆæ•°å€¤ + ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ï¼‰
    ImGui::Text("HP: %.1f / %.1f (%.1f%%)", hp_, kMaxHp, (hp_ / kMaxHp) * 100.0f);
    ImGui::ProgressBar(hp_ / kMaxHp, ImVec2(-1.0f, 0.0f), "");

    // ãƒ©ã‚¤ãƒ•ã€ãƒ•ã‚§ãƒ¼ã‚º
    ImGui::Text("Life: %d", life_);
    ImGui::Text("Phase: %d", phase_);

    // çŠ¶æ…‹ãƒ•ãƒ©ã‚°ï¼ˆè­¦å‘Šã¯èµ¤è‰²ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰
    if (isDead_) {
        ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Dead: YES");
    }
    else {
        ImGui::Text("Dead: NO");
    }
    ImGui::SameLine();
    if (isPause_) {
        ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Paused: YES");
    }
    else {
        ImGui::Text("Paused: NO");
    }

    ImGui::Text("Ready to Change Phase: %s", isReadyToChangePhase_ ? "YES" : "NO");

    // ===== åº§æ¨™æƒ…å ±ï¼ˆæŠ˜ã‚ŠãŸãŸã¿å¯èƒ½ï¼‰ =====
    if (ImGui::CollapsingHeader("Transform")) {
        ImGui::Text("Position: (%.2f, %.2f, %.2f)",
            transform_.translate.x, transform_.translate.y, transform_.translate.z);
        ImGui::Text("Rotation: (%.2f, %.2f, %.2f)",
            transform_.rotate.x, transform_.rotate.y, transform_.rotate.z);
        ImGui::Text("Scale: (%.2f, %.2f, %.2f)",
            transform_.scale.x, transform_.scale.y, transform_.scale.z);

        // åˆæœŸä½ç½®ã®èª¿æ•´
        ImGui::Separator();
        ImGui::Text("Initial Position (for respawn):");
        ImGui::DragFloat("Initial Y", &initialY_, 0.1f, 0.0f, 10.0f);
        ImGui::DragFloat("Initial Z", &initialZ_, 1.0f, -50.0f, 50.0f);
    }

    // ===== ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆæŠ˜ã‚ŠãŸãŸã¿å¯èƒ½ï¼‰ =====
    if (ImGui::CollapsingHeader("Shake Effect")) {
        ImGui::Text("Is Shaking: %s", isShaking_ ? "YES" : "NO");
        ImGui::Text("Timer: %.3f / %.3f", shakeTimer_, shakeDuration_);
        ImGui::Text("Offset: (%.3f, %.3f, %.3f)",
            shakeOffset_.x, shakeOffset_.y, shakeOffset_.z);

        ImGui::Separator();
        if (ImGui::DragFloat("Duration", &shakeDuration_, 0.01f, 0.0f, 2.0f)) {
            GlobalVariables::GetInstance()->SetValue("Boss", "ShakeDuration", shakeDuration_);
        }
        if (ImGui::DragFloat("Intensity", &shakeIntensity_, 0.01f, 0.0f, 1.0f)) {
            GlobalVariables::GetInstance()->SetValue("Boss", "ShakeIntensity", shakeIntensity_);
        }

        if (ImGui::Button("Test Shake")) {
            StartShake();
        }
    }

    // ===== ã‚»ã‚¯ã‚·ãƒ§ãƒ³6: ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆæŠ˜ã‚ŠãŸãŸã¿å¯èƒ½ï¼‰ =====
    if (ImGui::CollapsingHeader("Collider")) {
        if (bodyCollider_) {
            ImGui::Text("Active: %s", bodyCollider_->IsActive() ? "Yes" : "No");
            ImGui::Text("Type ID: %d (Enemy)", bodyCollider_->GetTypeID());

            Vector3 offset = bodyCollider_->GetOffset();
            ImGui::Text("Offset: (%.2f, %.2f, %.2f)", offset.x, offset.y, offset.z);

            Vector3 size = bodyCollider_->GetSize();
            ImGui::Text("Size: (%.2f, %.2f, %.2f)", size.x, size.y, size.z);

            Vector3 center = bodyCollider_->GetCenter();
            ImGui::Text("Center: (%.2f, %.2f, %.2f)", center.x, center.y, center.z);
        }
    }

    // ===== ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ =====
    ImGui::SeparatorText("Behavior Tree");

    // ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã®åˆ¶å¾¡
    if (behaviorTree_) {
        // JSONã‹ã‚‰ç›´æŽ¥ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã«èª­ã¿è¾¼ã¿ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ»ãƒªãƒªãƒ¼ã‚¹å…±é€šï¼‰
        ImGui::SameLine();
        if (ImGui::Button("Load Tree from JSON")) {
            if (behaviorTree_->LoadFromJSON("resources/Json/BossTree.json")) {
                ImGui::Text("Tree loaded successfully!");
            }
        }

        // ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰å°‚ç”¨ï¼šãƒŽãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿æ©Ÿèƒ½
        if (nodeEditor_) {
            ImGui::SameLine();
            if (ImGui::Button("Node Editor")) {
                showNodeEditor_ = !showNodeEditor_;
                nodeEditor_->SetVisible(showNodeEditor_);
            }

            // ã‚¨ãƒ‡ã‚£ã‚¿ã®ãƒ„ãƒªãƒ¼ã‚’BehaviorTreeã«é©ç”¨
            ImGui::SameLine();
            if (ImGui::Button("Apply Editor Tree")) {
                BTNodePtr runtimeTree = nodeEditor_->BuildRuntimeTree();
                if (runtimeTree && behaviorTree_) {
                    behaviorTree_->SetRootNode(runtimeTree);
                }
            }

            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ„ãƒªãƒ¼ç”Ÿæˆ
            ImGui::SameLine();
            if (ImGui::Button("Create Default Tree")) {
                nodeEditor_->CreateDefaultTree();
                ImGui::Text("Default tree created!");
            }
        }
    }

    // HPæ“ä½œ
    float tempHp = hp_;
    if (ImGui::SliderFloat("Set HP", &tempHp, 0.0f, kMaxHp)) {
        hp_ = std::clamp(tempHp, 0.0f, kMaxHp);
    }

    // ãƒ•ã‚§ãƒ¼ã‚ºåˆ‡ã‚Šæ›¿ãˆ
    ImVec2 buttonSize(ImGui::GetContentRegionAvail().x * 0.48f, 0);
    if (ImGui::Button("Set Phase 1", buttonSize)) {
        SetPhase(1);
        hp_ = kMaxHp;
        isReadyToChangePhase_ = false;
    }
    ImGui::SameLine();
    if (ImGui::Button("Set Phase 2", buttonSize)) {
        SetPhase(2);
        hp_ = kPhase2InitialHp;
    }

    // ä¸€æ™‚åœæ­¢ãƒˆã‚°ãƒ«
    ImGui::Spacing();
    ImGui::Checkbox("Pause Boss", &isPause_);

    // æ­»äº¡/å¾©æ´»ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    ImGui::Spacing();
    ImVec2 fullButtonSize(ImGui::GetContentRegionAvail().x * 0.48f, 0);

    // Killãƒœã‚¿ãƒ³ï¼ˆèµ¤è‰²ï¼‰
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(1.0f, 0.3f, 0.3f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.6f, 0.1f, 0.1f, 1.0f));
    if (ImGui::Button("Kill Boss", fullButtonSize)) {
        isDead_ = true;
    }
    ImGui::PopStyleColor(3);

    ImGui::SameLine();

    // Reviveãƒœã‚¿ãƒ³ï¼ˆç·‘è‰²ï¼‰
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.8f, 0.2f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 1.0f, 0.3f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.1f, 0.6f, 0.1f, 1.0f));
    if (ImGui::Button("Revive Boss", fullButtonSize)) {
        isDead_ = false;
        hp_ = kMaxHp;
        life_ = 1;
        SetPhase(1);
    }
    ImGui::PopStyleColor(3);

    // ãƒŽãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿ã®æ›´æ–°
    if (nodeEditor_ && showNodeEditor_) {
        nodeEditor_->Update();
    }

#endif
}

void Boss::RequestBulletSpawn(const Vector3& position, const Vector3& velocity) {
    pendingBullets_.push_back({ position, velocity });
}

std::vector<Boss::BulletSpawnRequest> Boss::ConsumePendingBullets() {
    auto result = std::move(pendingBullets_);
    pendingBullets_.clear();
    return result;
}

void Boss::SetPlayer(Player* player) {
    player_ = player;
    if (behaviorTree_) {
        behaviorTree_->SetPlayer(player);
    }
}

void Boss::SetAttackSignEmitterActive(bool active) {
    if (emitterManager_) {
        emitterManager_->SetEmitterActive(attackSignEmitterName_, active);
    }
}

void Boss::SetAttackSignEmitterPosition(const Vector3& position) {
    if (emitterManager_) {
        emitterManager_->SetEmitterPosition(attackSignEmitterName_, position);
    }
}

============================================================
File Path: GameProject/Object/Boss/Boss.h
============================================================
#pragma once
#include <memory>
#include <string>
#include <vector>

#include "Transform.h"
#include "vector2.h"
#include "Vector4.h"
#include "Vector3.h"

class Sprite;
class OBBCollider;
class Object3d;
class BossStateMachine;
class BossBehaviorTree;
class BossNodeEditor;
class Player;
class BossShootState;
class BossMeleeAttackCollider;
class EmitterManager;

/// <summary>
/// ãƒœã‚¹ã‚¨ãƒãƒŸãƒ¼ã‚¯ãƒ©ã‚¹
/// HPã¨ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†ã€ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã‚’åˆ¶å¾¡
/// </summary>
class Boss
{
    // å®šæ•°
private:
    // æœ€å¤§HP
    static constexpr float kMaxHp = 200.0f;

    // ãƒ•ã‚§ãƒ¼ã‚º2é–‹å§‹HPé–¾å€¤
    static constexpr float kPhase2Threshold = 105.0f;

    // ãƒ•ã‚§ãƒ¼ã‚º2é–‹å§‹æ™‚ã®HP
    static constexpr float kPhase2InitialHp = 100.0f;

public:
    /// <summary>
    /// å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆæ§‹é€ ä½“
    /// </summary>
    struct BulletSpawnRequest {
        Vector3 position;  // ç™ºå°„ä½ç½®
        Vector3 velocity;  // å¼¾ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
    };

public:
    Boss();
    ~Boss();

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    void Initialize();

    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize();

    /// <summary>
    /// æ›´æ–°ï¼ˆdeltaTimeç‰ˆï¼‰
    /// </summary>
    void Update(float deltaTime);

    /// <summary>
    /// æç”»
    /// </summary>
    void Draw();

    /// <summary>
    /// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    /// </summary>
    void DrawSprite();

    /// <summary>
    /// ImGuiã®æç”»
    /// </summary>
    void DrawImGui();

    /// <summary>
    /// ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
    /// </summary>
    /// <param name="damage">å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸é‡</param>
    /// <param name="shakeIntensityOverride">ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦ï¼ˆ0ä»¥ä¸‹ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä½¿ç”¨ï¼‰</param>
    void OnHit(float damage, float shakeIntensityOverride = 0.0f);

    /// <summary>
    /// ãƒ€ãƒ¡ãƒ¼ã‚¸ã•ã‚Œã‚‹ã¨ãè‰²å¤‰ã‚ã‚‹æ¼”å‡ºã®æ›´æ–°å‡¦ç†
    /// </summary>
    /// <param name="color">å¤‰åŒ–å¾Œã®è‰²</param>
    /// <param name="duration">å¤‰åŒ–æ™‚é–“</param>
    void UpdateHitEffect(const Vector4& color, float duration);

    /// <summary>
    /// ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
    /// </summary>
    /// <param name="deltaTime">ãƒ•ãƒ¬ãƒ¼ãƒ é–“éš”ï¼ˆç§’ï¼‰</param>
    void UpdateShake(float deltaTime);

    /// <summary>
    /// ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’é–‹å§‹
    /// </summary>
    /// <param name="intensity">ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦ï¼ˆ0ä»¥ä¸‹ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä½¿ç”¨ï¼‰</param>
    void StartShake(float intensity = 0.0f);

    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ã‚ºã¨lifeã®æ›´æ–°å‡¦ç†
    /// </summary>
    void UpdatePhaseAndLive();

    /// <summary>
    /// å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¿½åŠ 
    /// </summary>
    /// <param name="position">å¼¾ã®ç™ºå°„ä½ç½®</param>
    /// <param name="velocity">å¼¾ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«</param>
    void RequestBulletSpawn(const Vector3& position, const Vector3& velocity);

    /// <summary>
    /// ä¿ç•™ä¸­ã®å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å–å¾—ã—ã¦æ¶ˆè²»
    /// </summary>
    /// <returns>å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒªã‚¹ãƒˆï¼ˆmoveã§è¿”ã•ã‚Œã‚‹ï¼‰</returns>
    std::vector<BulletSpawnRequest> ConsumePendingBullets();

    //-----------------------------Getters/Setters------------------------------//
    /// <summary>
    /// åº§æ¨™å¤‰æ›æƒ…å ±ã‚’è¨­å®š
    /// </summary>
    /// <param name="transform">æ–°ã—ã„åº§æ¨™å¤‰æ›æƒ…å ±</param>
    void SetTransform(const Transform& transform) { transform_ = transform; }

    /// <summary>
    /// å¹³è¡Œç§»å‹•æƒ…å ±ã‚’è¨­å®š
    /// </summary>
    /// <param name="translate">æ–°ã—ã„ä½ç½®æƒ…å ±</param>
    void SetTranslate(const Vector3& translate) { transform_.translate = translate; }

    /// <summary>
    /// å›žè»¢æƒ…å ±ã‚’è¨­å®š
    /// </summary>
    /// <param name="rotate">æ–°ã—ã„å›žè»¢æƒ…å ±ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</param>
    void SetRotate(const Vector3& rotate) { transform_.rotate = rotate; }

    /// <summary>
    /// ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’è¨­å®š
    /// </summary>
    /// <param name="scale">æ–°ã—ã„ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±</param>
    void SetScale(const Vector3& scale) { transform_.scale = scale; }

    /// <summary>
    /// HPã‚’è¨­å®š
    /// </summary>
    /// <param name="hp">æ–°ã—ã„HPå€¤</param>
    void SetHp(float hp) { hp_ = hp; }

    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ã‚ºã‚’è¨­å®š
    /// </summary>
    /// <param name="phase">æ–°ã—ã„ãƒ•ã‚§ãƒ¼ã‚ºç•ªå·</param>
    void SetPhase(uint32_t phase) { if (phase <= 2 && phase > 0) phase_ = phase; }

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‚ç…§ã‚’è¨­å®š
    /// </summary>
    /// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetPlayer(Player* player);

    /// <summary>
    /// ä¸€æ™‚è¡Œå‹•åœæ­¢ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
    /// </summary>
    /// <param name="isPause">ä¸€æ™‚è¡Œå‹•åœæ­¢ãƒ•ãƒ©ã‚°ã®å€¤</param>
    void SetIsPause(bool isPause) { isPause_ = isPause; }

    /// <summary>
    /// åº§æ¨™å¤‰æ›æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®åº§æ¨™å¤‰æ›æƒ…å ±ã®å‚ç…§</returns>
    const Transform& GetTransform() const { return transform_; }

    /// <summary>
    /// åº§æ¨™å¤‰æ›æƒ…å ±ã‚’å–å¾—ï¼ˆéžconstç‰ˆï¼‰
    /// </summary>
    /// <returns>ç¾åœ¨ã®åº§æ¨™å¤‰æ›æƒ…å ±ã®å‚ç…§</returns>
    Transform& GetWorldTransform() { return transform_; }

    /// <summary>
    /// åº§æ¨™å¤‰æ›æƒ…å ±ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—
    /// </summary>
    /// <returns>åº§æ¨™å¤‰æ›æƒ…å ±ã¸ã®éžconstãƒã‚¤ãƒ³ã‚¿</returns>
    Transform* GetTransformPtr() { return &transform_; }

    /// <summary>
    /// å¹³è¡Œç§»å‹•æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ä½ç½®æƒ…å ±ã®å‚ç…§</returns>
    Vector3 GetTranslate() const { return transform_.translate; }

    /// <summary>
    /// å›žè»¢æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®å›žè»¢æƒ…å ±ã®å‚ç…§ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</returns>
    Vector3 GetRotate() const { return transform_.rotate; }

    /// <summary>
    /// ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã®å‚ç…§</returns>
    Vector3 GetScale() const { return transform_.scale; }

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—
    /// </summary>
    /// <returns>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    Player* GetPlayer() const { return player_; }

    /// <summary>
    /// HPã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®HPå€¤</returns>
    float GetHp() const { return hp_; }

    /// <summary>
    /// æœ€å¤§HPã‚’å–å¾—
    /// </summary>
    /// <returns>æœ€å¤§HPå€¤</returns>
    static constexpr float GetMaxHp() { return kMaxHp; }

    /// <summary>
    /// ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚ºã‚’å–å¾—
    /// </summary>
    /// <returns>ãƒ•ã‚§ãƒ¼ã‚ºç•ªå·</returns>
    uint32_t GetPhase() const { return phase_; }

    /// <summary>
    /// æ­»äº¡çŠ¶æ…‹ã‚’å–å¾—
    /// </summary>
    /// <returns> æ­»äº¡ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã®çœŸå½å€¤ </returns>
    bool IsDead() const { return isDead_; }

    /// <summary>
    /// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å–å¾—
    /// </summary>
    /// <returns>ãƒœã‚¹ã®OBBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    OBBCollider* GetCollider() const { return bodyCollider_.get(); }

    //-----------------------------è¿‘æŽ¥æ”»æ’ƒé–¢é€£------------------------------//
    /// <summary>
    /// æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã‚’å–å¾—
    /// </summary>
    /// <returns>æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã®Object3dãƒã‚¤ãƒ³ã‚¿</returns>
    Object3d* GetMeleeAttackBlock() const { return meleeAttackBlock_.get(); }

    /// <summary>
    /// æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã®è¡¨ç¤º/éžè¡¨ç¤ºã‚’è¨­å®š
    /// </summary>
    /// <param name="visible">è¡¨ç¤ºã™ã‚‹å ´åˆtrue</param>
    void SetMeleeAttackBlockVisible(bool visible) { meleeAttackBlockVisible_ = visible; }

    /// <summary>
    /// æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ãŒè¡¨ç¤ºä¸­ã‹å–å¾—
    /// </summary>
    /// <returns>è¡¨ç¤ºä¸­ã®å ´åˆtrue</returns>
    bool IsMeleeAttackBlockVisible() const { return meleeAttackBlockVisible_; }

    /// <summary>
    /// è¿‘æŽ¥æ”»æ’ƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å–å¾—
    /// </summary>
    /// <returns>è¿‘æŽ¥æ”»æ’ƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    BossMeleeAttackCollider* GetMeleeAttackCollider() const { return meleeAttackCollider_.get(); }

    /// <summary>
    /// äºˆå…†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–/éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    /// </summary>
    /// <param name="active">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹å ´åˆtrue</param>
    void SetAttackSignEmitterActive(bool active);

    /// <summary>
    /// äºˆå…†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä½ç½®ã‚’è¨­å®š
    /// </summary>
    /// <param name="position">è¨­å®šã™ã‚‹ä½ç½®</param>
    void SetAttackSignEmitterPosition(const Vector3& position);

    /// <summary>
    /// EmitterManagerã‚’è¨­å®š
    /// </summary>
    /// <param name="emitterManager">EmitterManagerã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetEmitterManager(EmitterManager* emitterManager) { emitterManager_ = emitterManager; }

private:
    // ãƒœã‚¹ã®3Dãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆæç”»ã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ï¼‰
    std::unique_ptr<Object3d> model_;

    // ãƒœã‚¹ã®åº§æ¨™å¤‰æ›æƒ…å ±ï¼ˆä½ç½®ã€å›žè»¢ã€ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
    Transform transform_{};

    // ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼
    std::unique_ptr<BossBehaviorTree> behaviorTree_;

#ifdef _DEBUG
    // ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ãƒŽãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿
    std::unique_ptr<BossNodeEditor> nodeEditor_;

    // ãƒŽãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿ã®è¡¨ç¤ºãƒ•ãƒ©ã‚°
    bool showNodeEditor_ = false;
#endif

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®å‚ç…§
    Player* player_ = nullptr;

    // ãƒœã‚¹ã®ç¾åœ¨HPï¼ˆ0ã«ãªã‚‹ã¨æ’ƒç ´ã€åˆæœŸå€¤200ï¼‰
    float hp_ = kMaxHp;

    // ãƒœã‚¹ã®ãƒ©ã‚¤ãƒ•ï¼ˆHPãŒ0ã«ãªã‚‹ãŸã³ã«æ¸›å°‘ã€0ã§ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼‰
    uint8_t life_ = 1;

    // ç¾åœ¨ã®æˆ¦é—˜ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆHP200~100:ãƒ•ã‚§ãƒ¼ã‚º1ã€HP100~0:ãƒ•ã‚§ãƒ¼ã‚º2ï¼‰
    uint32_t phase_ = 1;

    // ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°
    bool isReadyToChangePhase_ = false;

    // æ­»äº¡ãƒ•ãƒ©ã‚°
    bool isDead_ = false;

    // ä¸€æ™‚è¡Œå‹•åœæ­¢ãƒ•ãƒ©ã‚°
    bool isPause_ = false;

    // ãƒœã‚¹æœ¬ä½“ã®è¡çªåˆ¤å®šç”¨AABBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
    std::unique_ptr<OBBCollider> bodyCollider_;

    //-----------------------------è¿‘æŽ¥æ”»æ’ƒé–¢é€£------------------------------//
    // è¿‘æŽ¥æ”»æ’ƒç”¨æ­¦å™¨ãƒ–ãƒ­ãƒƒã‚¯
    std::unique_ptr<Object3d> meleeAttackBlock_;

    // æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯è¡¨ç¤ºãƒ•ãƒ©ã‚°
    bool meleeAttackBlockVisible_ = false;

    // è¿‘æŽ¥æ”»æ’ƒç”¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
    std::unique_ptr<BossMeleeAttackCollider> meleeAttackCollider_;

    // äºˆå…†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç®¡ç†
    EmitterManager* emitterManager_ = nullptr;

    // äºˆå…†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå
    std::string attackSignEmitterName_ = "boss_melee_attack_sign";

    // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†ç”ŸçŠ¶æ…‹ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°ã€‚
    bool isPlayHitEffect_ = false;

    // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¿ã‚¤ãƒžãƒ¼
    float hitEffectTimer_ = 0.0f;

    // ===== ã‚·ã‚§ã‚¤ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–¢é€£ =====
    // ã‚·ã‚§ã‚¤ã‚¯å†ç”Ÿä¸­ãƒ•ãƒ©ã‚°
    bool isShaking_ = false;
    // ã‚·ã‚§ã‚¤ã‚¯ã‚¿ã‚¤ãƒžãƒ¼ï¼ˆçµŒéŽæ™‚é–“ï¼‰
    float shakeTimer_ = 0.0f;
    // ã‚·ã‚§ã‚¤ã‚¯æŒç¶šæ™‚é–“
    float shakeDuration_ = 0.3f;
    // ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
    float shakeIntensity_ = 0.2f;
    // ç¾åœ¨ã®ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦ï¼ˆå®Ÿè¡Œæ™‚ï¼‰
    float currentShakeIntensity_ = 0.0f;
    // æç”»ç”¨ã‚·ã‚§ã‚¤ã‚¯ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    Vector3 shakeOffset_ = { 0.0f, 0.0f, 0.0f };

    // å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã‚­ãƒ¥ãƒ¼ï¼ˆGameSceneãŒå‡¦ç†ï¼‰
    std::vector<BulletSpawnRequest> pendingBullets_;

    // HPãƒãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
    std::unique_ptr<Sprite> hpBarSprite1_;
    Vector2 hpBarSize1_{};
    std::unique_ptr<Sprite> hpBarSprite2_;
    Vector2 hpBarSize2_{};
    std::unique_ptr<Sprite> hpBarBGSprite_;

    // åˆæœŸåº§æ¨™
    float initialY_ = 2.5f;   ///< åˆæœŸYåº§æ¨™
    float initialZ_ = 10.0f;  ///< åˆæœŸZåº§æ¨™

    // HPãƒãƒ¼ç”»é¢ä½ç½®
    float hpBarScreenXRatio_ = 0.65f;   ///< HPãƒãƒ¼Xåº§æ¨™ï¼ˆç”»é¢å¹…ã«å¯¾ã™ã‚‹æ¯”çŽ‡ï¼‰
    float hpBarScreenYRatio_ = 0.05f;   ///< HPãƒãƒ¼Yåº§æ¨™ï¼ˆç”»é¢é«˜ã•ã«å¯¾ã™ã‚‹æ¯”çŽ‡ï¼‰
};



============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossApproach.cpp
============================================================
#include "BTBossApproach.h"
#include "../../Boss.h"
#include "../../../Player/Player.h"
#include "../../../../Common/GameConst.h"

#include <algorithm>
#include <cmath>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossApproach::BTBossApproach() {
    name_ = "BossApproach";
}

BTNodeStatus BTBossApproach::Execute(BTBlackboard* blackboard) {
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    Player* player = blackboard->GetPlayer();
    if (!player) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    float deltaTime = blackboard->GetDeltaTime();

    // åˆå›žå®Ÿè¡Œæ™‚ã®åˆæœŸåŒ–
    if (isFirstExecute_) {
        InitializeApproach(boss, player);
        isFirstExecute_ = false;

        // æ—¢ã«ç›®æ¨™è·é›¢å†…ã«ã„ã‚‹å ´åˆã¯å³åº§ã«æˆåŠŸ
        if (approachDuration_ <= 0.0f) {
            isFirstExecute_ = true;
            status_ = BTNodeStatus::Success;
            return BTNodeStatus::Success;
        }
    }

    // æŽ¥è¿‘ç§»å‹•ã®æ›´æ–°
    UpdateApproachMovement(boss, deltaTime);

    // çµŒéŽæ™‚é–“ã‚’æ›´æ–°
    elapsedTime_ += deltaTime;

    // çµ‚äº†åˆ¤å®šï¼ˆä½ç½®ãƒ™ãƒ¼ã‚¹ï¼‰
    Vector3 currentPos = boss->GetTransform().translate;
    Vector3 diff = currentPos - targetPosition_;
    diff.y = 0.0f;  // æ°´å¹³è·é›¢ã®ã¿
    float distanceToTarget = diff.Length();

    if (distanceToTarget < kArrivalThreshold) {
        // ç›®æ¨™ä½ç½®ã«åˆ°é”
        boss->SetTranslate(targetPosition_);

        // ãƒªã‚»ãƒƒãƒˆã—ã¦æˆåŠŸã‚’è¿”ã™
        isFirstExecute_ = true;
        elapsedTime_ = 0.0f;
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    // ã¾ã æŽ¥è¿‘ä¸­
    status_ = BTNodeStatus::Running;
    return BTNodeStatus::Running;
}

void BTBossApproach::Reset() {
    BTNode::Reset();
    elapsedTime_ = 0.0f;
    isFirstExecute_ = true;
    approachDuration_ = 0.0f;
}

void BTBossApproach::InitializeApproach(Boss* boss, Player* player) {
    // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
    elapsedTime_ = 0.0f;

    // é–‹å§‹ä½ç½®ã‚’è¨˜éŒ²
    startPosition_ = boss->GetTransform().translate;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‚’å–å¾—
    Vector3 playerPos = player->GetTransform().translate;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
    Vector3 toPlayer = playerPos - startPosition_;
    toPlayer.y = 0.0f;  // æ°´å¹³é¢ã®ã¿
    float distance = toPlayer.Length();

    if (distance > kDirectionEpsilon) {
        Vector3 direction = toPlayer.Normalize();

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ã‚’å‘ã
        float angle = atan2f(direction.x, direction.z);
        boss->SetRotate(Vector3(0.0f, angle, 0.0f));

        // ç›®æ¨™ä½ç½® = ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‹ã‚‰ targetDistance_ æ‰‹å‰
        float approachDistance = distance - targetDistance_;
        if (approachDistance > 0.0f) {
            targetPosition_ = startPosition_ + direction * approachDistance;
            targetPosition_ = ClampToArea(targetPosition_);

            // å®Ÿéš›ã®ç§»å‹•è·é›¢ã‹ã‚‰æ‰€è¦æ™‚é–“ã‚’è¨ˆç®—
            Vector3 actualMove = targetPosition_ - startPosition_;
            actualMove.y = 0.0f;
            float actualDistance = actualMove.Length();
            approachDuration_ = actualDistance / approachSpeed_;
        }
        else {
            // æ—¢ã«ç›®æ¨™è·é›¢å†…ã«ã„ã‚‹
            targetPosition_ = startPosition_;
            approachDuration_ = 0.0f;
        }
    }
    else {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã»ã¼åŒã˜ä½ç½®
        targetPosition_ = startPosition_;
        approachDuration_ = 0.0f;
    }
}

void BTBossApproach::UpdateApproachMovement(Boss* boss, float deltaTime) {
    deltaTime; // æœªä½¿ç”¨è­¦å‘ŠæŠ‘åˆ¶

    if (approachDuration_ > 0.0f) {
        // æŽ¥è¿‘ä¸­ã®ç§»å‹•
        float t = elapsedTime_ / approachDuration_;

        // clamp to [0, 1] - ã“ã‚Œã«ã‚ˆã‚Š elapsedTime_ > approachDuration_ ã§ã‚‚ t=1.0 ã¨ãªã‚‹
        t = std::clamp(t, 0.0f, 1.0f);

        // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆåŠ é€Ÿâ†’æ¸›é€Ÿï¼‰: smoothstep
        t = t * t * (kEasingCoeffA - kEasingCoeffB * t);

        Vector3 newPosition = Vector3::Lerp(startPosition_, targetPosition_, t);
        boss->SetTranslate(newPosition);
    }
}

Vector3 BTBossApproach::ClampToArea(const Vector3& position) {
    Vector3 clampedPos = position;

    // GameConstantsã®ã‚¹ãƒ†ãƒ¼ã‚¸å¢ƒç•Œã‚’ä½¿ç”¨
    // Xåº§æ¨™ã®åˆ¶é™
    clampedPos.x = std::clamp(clampedPos.x, GameConst::kStageXMin + GameConst::kAreaMargin, GameConst::kStageXMax - GameConst::kAreaMargin);

    // Zåº§æ¨™ã®åˆ¶é™
    clampedPos.z = std::clamp(clampedPos.z, GameConst::kStageZMin + GameConst::kAreaMargin, GameConst::kStageZMax - GameConst::kAreaMargin);

    // Yåº§æ¨™ã¯å…ƒã®å€¤ã‚’ä¿æŒ
    clampedPos.y = position.y;

    return clampedPos;
}

nlohmann::json BTBossApproach::ExtractParameters() const {
    return {
        {"approachSpeed", approachSpeed_},
        {"targetDistance", targetDistance_}
    };
}

#ifdef _DEBUG
bool BTBossApproach::DrawImGui() {
    bool changed = false;

    if (ImGui::DragFloat("Approach Speed##approach", &approachSpeed_, 1.0f, 10.0f, 200.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Target Distance##approach", &targetDistance_, 0.5f, 1.0f, 50.0f)) {
        changed = true;
    }

    ImGui::Separator();
    ImGui::Text("Runtime Info:");
    ImGui::Text("Duration: %.2f sec", approachDuration_);
    ImGui::Text("Elapsed: %.2f sec", elapsedTime_);

    return changed;
}
#endif


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossApproach.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"
#include "Vector3.h"

class Boss;
class Player;

/// <summary>
/// ãƒœã‚¹ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŽ¥è¿‘ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒŽãƒ¼ãƒ‰
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ã«ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ç§»å‹•ã§ç´ æ—©ãæŽ¥è¿‘ã—ã€ä¸€å®šè·é›¢ã§åœæ­¢ã™ã‚‹
/// </summary>
class BTBossApproach : public BTNode {
    //=========================================================================================
    // å®šæ•°
    //=========================================================================================
private:
    static constexpr float kDirectionEpsilon = 0.01f;  ///< æ–¹å‘åˆ¤å®šã®é–¾å€¤
    static constexpr float kArrivalThreshold = 0.5f;   ///< åˆ°é”åˆ¤å®šã®é–¾å€¤
    static constexpr float kEasingCoeffA = 3.0f;       ///< ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ä¿‚æ•°A
    static constexpr float kEasingCoeffB = 2.0f;       ///< ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ä¿‚æ•°B

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossApproach();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossApproach() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ãƒ»è¨­å®š
    float GetApproachSpeed() const { return approachSpeed_; }
    void SetApproachSpeed(float speed) { approachSpeed_ = speed; }
    float GetTargetDistance() const { return targetDistance_; }
    void SetTargetDistance(float distance) { targetDistance_ = distance; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override {
        if (params.contains("approachSpeed")) {
            approachSpeed_ = params["approachSpeed"];
        }
        if (params.contains("targetDistance")) {
            targetDistance_ = params["targetDistance"];
        }
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

private:
    /// <summary>
    /// æŽ¥è¿‘ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</param>
    void InitializeApproach(Boss* boss, Player* player);

    /// <summary>
    /// æŽ¥è¿‘ç§»å‹•ã®æ›´æ–°
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void UpdateApproachMovement(Boss* boss, float deltaTime);

    /// <summary>
    /// ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ä½ç½®ã‚’è¨ˆç®—
    /// </summary>
    /// <param name="position">èª¿æ•´å‰ã®ä½ç½®</param>
    /// <returns>ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ä½ç½®</returns>
    Vector3 ClampToArea(const Vector3& position);

    //=========================================================================================
    // ãƒ¡ãƒ³ãƒå¤‰æ•°
    //=========================================================================================
private:
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    float approachSpeed_ = 80.0f;      ///< æŽ¥è¿‘é€Ÿåº¦
    float targetDistance_ = 12.0f;     ///< ç›®æ¨™è·é›¢ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®è·é›¢ï¼‰

    // çŠ¶æ…‹ç®¡ç†
    Vector3 startPosition_;            ///< é–‹å§‹ä½ç½®
    Vector3 targetPosition_;           ///< ç›®æ¨™ä½ç½®ï¼ˆè¨ˆç®—æ¸ˆã¿ï¼‰
    float elapsedTime_ = 0.0f;         ///< çµŒéŽæ™‚é–“
    float approachDuration_ = 0.0f;    ///< æŽ¥è¿‘æ‰€è¦æ™‚é–“ï¼ˆè·é›¢ã‹ã‚‰å‹•çš„è¨ˆç®—ï¼‰
    bool isFirstExecute_ = true;       ///< åˆå›žå®Ÿè¡Œãƒ•ãƒ©ã‚°
};


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossDash.cpp
============================================================
#include "BTBossDash.h"
#include "../../Boss.h"
#include "../../../Player/Player.h"
#include "../../../../Common/GameConst.h"
#include "RandomEngine.h"

#include <algorithm>
#include <cmath>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossDash::BTBossDash() {
    name_ = "BossDash";
}

BTNodeStatus BTBossDash::Execute(BTBlackboard* blackboard) {
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    float deltaTime = blackboard->GetDeltaTime();

    // åˆå›žå®Ÿè¡Œæ™‚ã®åˆæœŸåŒ–
    if (isFirstExecute_) {
        InitializeDash(boss);
        isFirstExecute_ = false;
    }

    // ãƒ€ãƒƒã‚·ãƒ¥ç§»å‹•ã®æ›´æ–°
    UpdateDashMovement(boss, deltaTime);

    // çµŒéŽæ™‚é–“ã‚’æ›´æ–°
    elapsedTime_ += deltaTime;

    // ãƒ€ãƒƒã‚·ãƒ¥ãŒå®Œäº†ã—ãŸã‹ç¢ºèª
    if (elapsedTime_ >= dashDuration_) {
        // æœ€çµ‚ä½ç½®ã«è¨­å®š
        boss->SetTranslate(targetPosition_);

        // ãƒªã‚»ãƒƒãƒˆã—ã¦æˆåŠŸã‚’è¿”ã™
        isFirstExecute_ = true;
        elapsedTime_ = 0.0f;
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    // ã¾ã ãƒ€ãƒƒã‚·ãƒ¥ä¸­
    status_ = BTNodeStatus::Running;
    return BTNodeStatus::Running;
}

void BTBossDash::Reset() {
    BTNode::Reset();
    elapsedTime_ = 0.0f;
    isFirstExecute_ = true;
}

void BTBossDash::InitializeDash(Boss* boss) {
    // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
    elapsedTime_ = 0.0f;

    // é–‹å§‹ä½ç½®ã‚’è¨˜éŒ²
    startPosition_ = boss->GetTransform().translate;

    // ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘ã‚’ç”Ÿæˆ
    RandomEngine* rng = RandomEngine::GetInstance();

    // XZå¹³é¢ä¸Šã®ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘ã‚’å–å¾—ï¼ˆY=0ã§æ­£è¦åŒ–æ¸ˆã¿ï¼‰
    dashDirection_ = rng->GetRandomDirectionXZ();

    // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ€ãƒƒã‚·ãƒ¥è·é›¢ã‚’å–å¾—
    float dashDistance = rng->GetFloat(minDistance_, maxDistance_);

    // ç›®æ¨™ä½ç½®ã‚’è¨ˆç®—
    targetPosition_ = startPosition_ + dashDirection_ * dashDistance;

    // ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ã‚ˆã†èª¿æ•´
    targetPosition_ = ClampToArea(targetPosition_);

    // ãƒ€ãƒƒã‚·ãƒ¥æ–¹å‘ã‚’å†è¨ˆç®—ï¼ˆã‚¨ãƒªã‚¢åˆ¶é™å¾Œï¼‰
    dashDirection_ = targetPosition_ - startPosition_;
    float actualDistance = dashDirection_.Length();
    if (actualDistance > kDirectionEpsilon) {
        dashDirection_ = dashDirection_.Normalize();
        // ãƒ€ãƒƒã‚·ãƒ¥æ™‚é–“ã‚’èª¿æ•´ï¼ˆè·é›¢ã«å¿œã˜ã¦ï¼‰
        dashDuration_ = actualDistance / dashSpeed_;
    }

    // ãƒ€ãƒƒã‚·ãƒ¥æ–¹å‘ã‚’å‘ã
    if (dashDirection_.Length() > kDirectionEpsilon) {
        float angle = atan2f(dashDirection_.x, dashDirection_.z);
        boss->SetRotate(Vector3(0.0f, angle, 0.0f));
    }
}

void BTBossDash::UpdateDashMovement(Boss* boss, float deltaTime) {
    deltaTime; // æœªä½¿ç”¨è­¦å‘ŠæŠ‘åˆ¶
    if (elapsedTime_ < dashDuration_) {
        // ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã®ç§»å‹•
        float t = elapsedTime_ / dashDuration_;

        // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆåŠ é€Ÿâ†’æ¸›é€Ÿï¼‰
        t = t * t * (kEasingCoeffA - kEasingCoeffB * t);

        Vector3 newPosition = Vector3::Lerp(startPosition_, targetPosition_, t);
        boss->SetTranslate(newPosition);

        // ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçš„ãªè¡¨ç¾ï¼ˆå°‘ã—æŒ¯å‹•ã•ã›ã‚‹ï¼‰
        float vibration = sinf(elapsedTime_ * vibrationFreq_) * vibrationAmp_;
        Vector3 currentPos = boss->GetTransform().translate;
        currentPos.y += vibration;
        boss->SetTranslate(currentPos);
    }
}

Vector3 BTBossDash::ClampToArea(const Vector3& position) {
    Vector3 clampedPos = position;

    // GameConstantsã®ã‚¹ãƒ†ãƒ¼ã‚¸å¢ƒç•Œã‚’ä½¿ç”¨
    // Xåº§æ¨™ã®åˆ¶é™
    clampedPos.x = std::clamp(clampedPos.x, GameConst::kStageXMin + GameConst::kAreaMargin, GameConst::kStageXMax - GameConst::kAreaMargin);

    // Zåº§æ¨™ã®åˆ¶é™
    clampedPos.z = std::clamp(clampedPos.z, GameConst::kStageZMin + GameConst::kAreaMargin, GameConst::kStageZMax - GameConst::kAreaMargin);

    // Yåº§æ¨™ã¯å…ƒã®å€¤ã‚’ä¿æŒ
    clampedPos.y = position.y;

    return clampedPos;
}

nlohmann::json BTBossDash::ExtractParameters() const {
    return {
        {"dashSpeed", dashSpeed_},
        {"dashDuration", dashDuration_}
    };
}

#ifdef _DEBUG
bool BTBossDash::DrawImGui() {
    bool changed = false;

    if (ImGui::DragFloat("Speed##dash", &dashSpeed_, 1.0f, 10.0f, 200.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Duration##dash", &dashDuration_, 0.05f, 0.1f, 3.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Min Distance##dash", &minDistance_, 0.1f, 0.0f, 100.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Max Distance##dash", &maxDistance_, 0.1f, 0.0f, 100.0f)) {
        changed = true;
    }

    ImGui::Separator();
    ImGui::Text("Effect Parameters:");
    if (ImGui::DragFloat("Vibration Freq##dash", &vibrationFreq_, 1.0f, 1.0f, 100.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Vibration Amp##dash", &vibrationAmp_, 0.01f, 0.0f, 0.5f)) {
        changed = true;
    }

    return changed;
}
#endif

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossDash.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"
#include "Vector3.h"

class Boss;

/// <summary>
/// ãƒœã‚¹ã®ãƒ€ãƒƒã‚·ãƒ¥ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒŽãƒ¼ãƒ‰
/// </summary>
class BTBossDash : public BTNode {
    //=========================================================================================
    // å®šæ•°
    //=========================================================================================
private:
    static constexpr float kDirectionEpsilon = 0.01f;  ///< æ–¹å‘åˆ¤å®šã®é–¾å€¤
    static constexpr float kEasingCoeffA = 3.0f;       ///< ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ä¿‚æ•°A
    static constexpr float kEasingCoeffB = 2.0f;       ///< ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ä¿‚æ•°B

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossDash();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossDash() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ãƒ»è¨­å®š
    float GetDashSpeed() const { return dashSpeed_; }
    void SetDashSpeed(float speed) { dashSpeed_ = speed; }
    float GetDashDuration() const { return dashDuration_; }
    void SetDashDuration(float duration) { dashDuration_ = duration; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override {
        if (params.contains("dashSpeed")) {
            dashSpeed_ = params["dashSpeed"];
        }
        if (params.contains("dashDuration")) {
            dashDuration_ = params["dashDuration"];
        }
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

private:
    /// <summary>
    /// ãƒ€ãƒƒã‚·ãƒ¥ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void InitializeDash(Boss* boss);

    /// <summary>
    /// ãƒ€ãƒƒã‚·ãƒ¥ç§»å‹•ã®æ›´æ–°
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void UpdateDashMovement(Boss* boss, float deltaTime);

    /// <summary>
    /// ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ä½ç½®ã‚’è¨ˆç®—
    /// </summary>
    /// <param name="position">èª¿æ•´å‰ã®ä½ç½®</param>
    /// <returns>ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ä½ç½®</returns>
    Vector3 ClampToArea(const Vector3& position);

    // ãƒ€ãƒƒã‚·ãƒ¥æ–¹å‘
    Vector3 dashDirection_;

    // ãƒ€ãƒƒã‚·ãƒ¥é€Ÿåº¦
    float dashSpeed_ = 60.0f;

    // ãƒ€ãƒƒã‚·ãƒ¥æ™‚é–“
    float dashDuration_ = 0.5f;

    // ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹ä½ç½®
    Vector3 startPosition_;

    // ãƒ€ãƒƒã‚·ãƒ¥ç›®æ¨™ä½ç½®
    Vector3 targetPosition_;

    // çµŒéŽæ™‚é–“
    float elapsedTime_ = 0.0f;

    // åˆå›žå®Ÿè¡Œãƒ•ãƒ©ã‚°
    bool isFirstExecute_ = true;

    // ãƒ€ãƒƒã‚·ãƒ¥è·é›¢ç¯„å›²ï¼ˆImGuièª¿æ•´ç”¨ï¼‰
    float minDistance_ = 10.0f;  ///< æœ€å°ãƒ€ãƒƒã‚·ãƒ¥è·é›¢
    float maxDistance_ = 50.0f;  ///< æœ€å¤§ãƒ€ãƒƒã‚·ãƒ¥è·é›¢

    // èª¿æ•´å¯èƒ½ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆImGuiç·¨é›†ç”¨ï¼‰
    float vibrationFreq_ = 50.0f;  ///< æŒ¯å‹•å‘¨æ³¢æ•°
    float vibrationAmp_ = 0.05f;   ///< æŒ¯å‹•æŒ¯å¹…
};

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossIdle.cpp
============================================================
#include "BTBossIdle.h"
#include "../../Boss.h"
#include "../../../Player/Player.h"
#include "Vector3.h"
#include <cmath>
#include <numbers>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossIdle::BTBossIdle() {
    name_ = "BossIdle";
}

BTNodeStatus BTBossIdle::Execute(BTBlackboard* blackboard) {
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    float deltaTime = blackboard->GetDeltaTime();

    // åˆå›žå®Ÿè¡Œæ™‚ã®åˆæœŸåŒ–
    if (isFirstExecute_) {
        elapsedTime_ = 0.0f;
        isFirstExecute_ = false;

        // æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
        int actionCounter = blackboard->GetInt("ActionCounter", 0);
        blackboard->SetInt("ActionCounter", actionCounter + 1);
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹å‘ã‚’å‘ã
    LookAtPlayer(boss, deltaTime);

    // çµŒéŽæ™‚é–“ã‚’æ›´æ–°
    elapsedTime_ += deltaTime;

    // å¾…æ©Ÿæ™‚é–“ãŒçµŒéŽã—ãŸã‚‰æˆåŠŸã‚’è¿”ã™
    if (elapsedTime_ >= idleDuration_) {
        isFirstExecute_ = true;  // æ¬¡å›žå®Ÿè¡Œæ™‚ã®ãŸã‚ã«ãƒªã‚»ãƒƒãƒˆ
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    // ã¾ã å¾…æ©Ÿä¸­
    status_ = BTNodeStatus::Running;
    return BTNodeStatus::Running;
}

void BTBossIdle::Reset() {
    BTNode::Reset();
    elapsedTime_ = 0.0f;
    isFirstExecute_ = true;
}

void BTBossIdle::LookAtPlayer(Boss* boss, float deltaTime) {
    Player* player = boss->GetPlayer();
    if (!player) {
        return;
    }

    Vector3 playerPos = player->GetTransform().translate;
    Vector3 bossPos = boss->GetTransform().translate;
    Vector3 toPlayer = playerPos - bossPos;
    toPlayer.y = 0.0f;  // Yè»¸ã¯ç„¡è¦–

    if (toPlayer.Length() > kDirectionEpsilon) {
        toPlayer.Normalize();

        // å‘ããŸã„è§’åº¦ã‚’è¨ˆç®—
        float targetAngle = atan2f(toPlayer.x, toPlayer.z);

        // ç¾åœ¨ã®è§’åº¦
        float currentAngle = boss->GetTransform().rotate.y;

        // è§’åº¦å·®ã‚’è¨ˆç®—ï¼ˆ-Ï€ï½žÏ€ã®ç¯„å›²ã«æ­£è¦åŒ–ï¼‰
        constexpr float kPi = static_cast<float>(std::numbers::pi);
        constexpr float kTwoPi = 2.0f * kPi;
        float angleDiff = targetAngle - currentAngle;
        while (angleDiff > kPi) angleDiff -= kTwoPi;
        while (angleDiff < -kPi) angleDiff += kTwoPi;

        // ã‚¹ãƒ ãƒ¼ã‚ºã«å›žè»¢ï¼ˆå›žè»¢é€Ÿåº¦ã‚’èª¿æ•´ï¼‰
        float rotationAmount = angleDiff * rotationSpeed_ * deltaTime;

        // å›žè»¢é‡ã‚’åˆ¶é™ï¼ˆæ€¥æ¿€ãªå›žè»¢ã‚’é˜²ãï¼‰
        float maxRotationPerFrame = rotationSpeed_ * deltaTime;
        if (fabs(rotationAmount) > maxRotationPerFrame) {
            rotationAmount = (rotationAmount > 0) ? maxRotationPerFrame : -maxRotationPerFrame;
        }

        // å›žè»¢ã‚’é©ç”¨
        Transform transform = boss->GetTransform();
        transform.rotate.y += rotationAmount;
        boss->SetTransform(transform);
    }
}

nlohmann::json BTBossIdle::ExtractParameters() const {
    return {{"idleDuration", idleDuration_}};
}

#ifdef _DEBUG
bool BTBossIdle::DrawImGui() {
    bool changed = false;

    if (ImGui::DragFloat("Idle Duration##idle", &idleDuration_, 0.1f, 0.0f, 10.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Rotation Speed##idle", &rotationSpeed_, 0.1f, 0.1f, 20.0f)) {
        changed = true;
    }

    return changed;
}
#endif


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossIdle.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"

class Boss;

/// <summary>
/// ãƒœã‚¹ã®å¾…æ©Ÿã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒŽãƒ¼ãƒ‰
/// </summary>
class BTBossIdle : public BTNode {
    //=========================================================================================
    // å®šæ•°
    //=========================================================================================
private:
    static constexpr float kDirectionEpsilon = 0.01f;   ///< æ–¹å‘åˆ¤å®šã®é–¾å€¤

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossIdle();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossIdle() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    /// <summary>
    /// å¾…æ©Ÿæ™‚é–“ã®è¨­å®š
    /// </summary>
    /// <param name="duration">å¾…æ©Ÿæ™‚é–“</param>
    void SetIdleDuration(float duration) { idleDuration_ = duration; }

    /// <summary>
    /// å¾…æ©Ÿæ™‚é–“ã®å–å¾—
    /// </summary>
    /// <returns>å¾…æ©Ÿæ™‚é–“</returns>
    float GetIdleDuration() const { return idleDuration_; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override {
        if (params.contains("idleDuration")) {
            idleDuration_ = params["idleDuration"];
        }
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

private:
    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹å‘ã‚’å‘ãå‡¦ç†
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void LookAtPlayer(Boss* boss, float deltaTime);


    // å¾…æ©Ÿæ™‚é–“ï¼ˆæ¬¡ã®è¡Œå‹•ã¾ã§ã®æ™‚é–“ï¼‰
    float idleDuration_ = 2.0f;

    // å›žè»¢é€Ÿåº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³/ç§’ï¼‰
    float rotationSpeed_ = 5.0f;

    // çµŒéŽæ™‚é–“
    float elapsedTime_ = 0.0f;

    // åˆå›žå®Ÿè¡Œãƒ•ãƒ©ã‚°
    bool isFirstExecute_ = true;
};

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossMeleeAttack.cpp
============================================================
#include "BTBossMeleeAttack.h"
#include "../../Boss.h"
#include "../../../Player/Player.h"
#include "../../../../Collision/BossMeleeAttackCollider.h"
#include "../../../../Common/GameConst.h"
#include "Object3d.h"
#include "Mat4x4Func.h"
#include <cmath>
#include <algorithm>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossMeleeAttack::BTBossMeleeAttack() {
    name_ = "BossMeleeAttack";
}

BTNodeStatus BTBossMeleeAttack::Execute(BTBlackboard* blackboard) {
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    float deltaTime = blackboard->GetDeltaTime();

    // åˆå›žå®Ÿè¡Œæ™‚ã®åˆæœŸåŒ–
    if (isFirstExecute_) {
        InitializeMeleeAttack(boss);
        isFirstExecute_ = false;
    }

    // çµŒéŽæ™‚é–“ã‚’æ›´æ–°
    elapsedTime_ += deltaTime;
    phaseTimer_ += deltaTime;

    // ãƒ•ã‚§ãƒ¼ã‚ºã«å¿œã˜ãŸå‡¦ç†
    switch (currentPhase_) {
    case MeleePhase::Prepare:
        ProcessPreparePhase(boss, deltaTime);
        // æº–å‚™æ™‚é–“çµ‚äº†ã§Executeãƒ•ã‚§ãƒ¼ã‚ºã¸
        if (phaseTimer_ >= prepareTime_) {
            currentPhase_ = MeleePhase::Execute;
            phaseTimer_ = 0.0f;
            // äºˆå…†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’OFF
            boss->SetAttackSignEmitterActive(false);
            // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æœ‰åŠ¹åŒ–
            if (boss->GetMeleeAttackCollider()) {
                boss->GetMeleeAttackCollider()->SetActive(true);
                boss->GetMeleeAttackCollider()->Reset();
                colliderActivated_ = true;
            }
            // â˜…çªé€²ã®åˆæœŸåŒ–ï¼ˆExecuteé–‹å§‹æ™‚ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‚’ç¢ºå®šï¼‰
            InitializeRush(boss);
        }
        break;

    case MeleePhase::Execute:
        ProcessExecutePhase(boss, deltaTime);
        // æ”»æ’ƒæ™‚é–“çµ‚äº†ã§Recoveryãƒ•ã‚§ãƒ¼ã‚ºã¸
        if (phaseTimer_ >= attackDuration_) {
            currentPhase_ = MeleePhase::Recovery;
            phaseTimer_ = 0.0f;
            // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’ç„¡åŠ¹åŒ–
            if (boss->GetMeleeAttackCollider()) {
                boss->GetMeleeAttackCollider()->SetActive(false);
            }
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’éžè¡¨ç¤º
            boss->SetMeleeAttackBlockVisible(false);
        }
        break;

    case MeleePhase::Recovery:
        ProcessRecoveryPhase(boss);
        // ç¡¬ç›´æ™‚é–“çµ‚äº†ã§å®Œäº†
        if (phaseTimer_ >= recoveryTime_) {
            // ãƒªã‚»ãƒƒãƒˆã—ã¦æˆåŠŸã‚’è¿”ã™
            isFirstExecute_ = true;
            elapsedTime_ = 0.0f;
            phaseTimer_ = 0.0f;
            currentPhase_ = MeleePhase::Prepare;
            colliderActivated_ = false;
            status_ = BTNodeStatus::Success;
            return BTNodeStatus::Success;
        }
        break;
    }

    // ã¾ã å‡¦ç†ä¸­
    status_ = BTNodeStatus::Running;
    return BTNodeStatus::Running;
}

void BTBossMeleeAttack::Reset() {
    BTNode::Reset();
    elapsedTime_ = 0.0f;
    phaseTimer_ = 0.0f;
    blockAngle_ = 0.0f;
    isFirstExecute_ = true;
    currentPhase_ = MeleePhase::Prepare;
    colliderActivated_ = false;
    rushInitialized_ = false;
}

void BTBossMeleeAttack::InitializeMeleeAttack(Boss* boss) {
    // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
    elapsedTime_ = 0.0f;
    phaseTimer_ = 0.0f;
    blockAngle_ = kBlockStartAngle;
    currentPhase_ = MeleePhase::Prepare;
    colliderActivated_ = false;

    // totalDurationã‚’è¨ˆç®—
    totalDuration_ = prepareTime_ + attackDuration_ + recoveryTime_;

    // ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¡¨ç¤º
    boss->SetMeleeAttackBlockVisible(true);

    // äºˆå…†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ON
    boss->SetAttackSignEmitterActive(true);

    // åˆæœŸä½ç½®ã‚’è¨­å®š
    UpdateBlockPosition(boss);

    // çªé€²ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆExecuteé–‹å§‹æ™‚ã«åˆæœŸåŒ–ã™ã‚‹ï¼‰
    rushInitialized_ = false;
}

void BTBossMeleeAttack::AimAtPlayer(Boss* boss, float deltaTime) {
    Player* player = boss->GetPlayer();
    if (!player) {
        return;
    }

    Vector3 playerPos = player->GetTransform().translate;
    Vector3 bossPos = boss->GetTransform().translate;
    Vector3 toPlayer = playerPos - bossPos;
    toPlayer.y = 0.0f; // Yè»¸ã¯ç„¡è¦–

    if (toPlayer.Length() > kDirectionEpsilon) {
        toPlayer = toPlayer.Normalize();
        float targetAngle = atan2f(toPlayer.x, toPlayer.z);

        // ç¾åœ¨ã®è§’åº¦ã‚’å–å¾—
        float currentAngle = boss->GetRotate().y;

        // è§’åº¦å·®ã‚’è¨ˆç®—
        float angleDiff = targetAngle - currentAngle;

        // -Ï€ã‹ã‚‰Ï€ã®ç¯„å›²ã«æ­£è¦åŒ–
        while (angleDiff > 3.14159f) angleDiff -= 2.0f * 3.14159f;
        while (angleDiff < -3.14159f) angleDiff += 2.0f * 3.14159f;

        // ã‚¹ãƒ ãƒ¼ã‚ºã«å›žè»¢ï¼ˆè£œé–“çŽ‡ã‚’èª¿æ•´ï¼‰
        float rotationSpeed = 5.0f;
        float newAngle = currentAngle + angleDiff * rotationSpeed * deltaTime;

        boss->SetRotate(Vector3(0.0f, newAngle, 0.0f));
    }
}

void BTBossMeleeAttack::ProcessPreparePhase(Boss* boss, float deltaTime) {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹å‘ã‚’å‘ã
    AimAtPlayer(boss, deltaTime);

    // ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã‚’æ›´æ–°ï¼ˆæŒ¯ã‚‰ãªã„ã€é–‹å§‹ä½ç½®ã«å›ºå®šï¼‰
    UpdateBlockPosition(boss);

    // äºˆå…†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä½ç½®ã‚’æ›´æ–°
    Object3d* block = boss->GetMeleeAttackBlock();
    if (block) {
        boss->SetAttackSignEmitterPosition(block->GetTransform().translate);
    }
}

void BTBossMeleeAttack::ProcessExecutePhase(Boss* boss, float deltaTime) {
    // ãƒ’ãƒƒãƒˆåˆ¤å®šã‚’ãƒã‚§ãƒƒã‚¯
    BossMeleeAttackCollider* collider = boss->GetMeleeAttackCollider();
    bool hasHit = collider && collider->HasHitPlayer();

    if (hasHit) {
        // ãƒ’ãƒƒãƒˆæ™‚: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ä¸€å®šè·é›¢ã‚’ä¿ã£ã¦åœæ­¢
        Player* player = boss->GetPlayer();
        if (player) {
            Vector3 playerPos = player->GetTransform().translate;
            Vector3 bossPos = boss->GetTransform().translate;
            Vector3 toPlayer = playerPos - bossPos;
            toPlayer.y = 0.0f;
            float currentDistance = toPlayer.Length();

            // ç¾åœ¨ã®è·é›¢ãŒstopDistance_ã‚ˆã‚Šè¿‘ã„å ´åˆã¯ã€stopDistance_ã¾ã§å¾Œé€€
            if (currentDistance < stopDistance_ && currentDistance > kDirectionEpsilon) {
                Vector3 direction = toPlayer.Normalize();
                Vector3 stopPos = playerPos - direction * stopDistance_;
                stopPos = ClampToArea(stopPos);
                boss->SetTranslate(stopPos);
            }
            // ãã†ã§ãªã‘ã‚Œã°ç¾åœ¨ä½ç½®ã‚’ç¶­æŒï¼ˆç§»å‹•ã—ãªã„ï¼‰
        }
    } else {
        // ãƒŸã‚¹æ™‚: é€šå¸¸é€šã‚Šçªé€²
        float t = phaseTimer_ / attackDuration_;
        t = std::clamp(t, 0.0f, 1.0f);
        t = t * t * (3.0f - 2.0f * t);  // Smoothstep

        Vector3 newPosition = Vector3::Lerp(startPosition_, targetPosition_, t);
        boss->SetTranslate(newPosition);
    }

    // ãƒ–ãƒ­ãƒƒã‚¯ã‚’å›žè»¢ã•ã›ã‚‹ï¼ˆå³ã‹ã‚‰å·¦ã¸ï¼‰
    float rotationSpeed = swingAngle_ / attackDuration_;
    blockAngle_ += rotationSpeed * deltaTime;

    // ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã‚’æ›´æ–°
    UpdateBlockPosition(boss);
}

void BTBossMeleeAttack::ProcessRecoveryPhase(Boss* boss) {
    // ç¡¬ç›´ä¸­ã¯ç‰¹ã«å‡¦ç†ãªã—
    (void)boss;
}

Vector3 BTBossMeleeAttack::ClampToArea(const Vector3& position) {
    Vector3 clampedPos = position;
    clampedPos.x = std::clamp(clampedPos.x,
        GameConst::kStageXMin + GameConst::kAreaMargin,
        GameConst::kStageXMax - GameConst::kAreaMargin);
    clampedPos.z = std::clamp(clampedPos.z,
        GameConst::kStageZMin + GameConst::kAreaMargin,
        GameConst::kStageZMax - GameConst::kAreaMargin);
    clampedPos.y = position.y;
    return clampedPos;
}

void BTBossMeleeAttack::InitializeRush(Boss* boss) {
    rushInitialized_ = true;
    startPosition_ = boss->GetTransform().translate;

    Player* player = boss->GetPlayer();
    if (player) {
        Vector3 playerPos = player->GetTransform().translate;
        Vector3 toPlayer = playerPos - startPosition_;
        toPlayer.y = 0.0f;

        if (toPlayer.Length() > kDirectionEpsilon) {
            rushDirection_ = toPlayer.Normalize();

            // çªé€²æ–¹å‘ã«å‘ã
            float angle = atan2f(rushDirection_.x, rushDirection_.z);
            boss->SetRotate(Vector3(0.0f, angle, 0.0f));

            // ç›®æ¨™ä½ç½® = é–‹å§‹ä½ç½® + æ–¹å‘ * çªé€²è·é›¢
            targetPosition_ = startPosition_ + rushDirection_ * rushDistance_;
            targetPosition_ = ClampToArea(targetPosition_);
        } else {
            rushDirection_ = Vector3(0.0f, 0.0f, 1.0f);
            targetPosition_ = startPosition_;
        }
    } else {
        rushDirection_ = Vector3(0.0f, 0.0f, 1.0f);
        targetPosition_ = startPosition_;
    }
}

void BTBossMeleeAttack::UpdateBlockPosition(Boss* boss) {
    Object3d* block = boss->GetMeleeAttackBlock();
    if (!block) return;

    // ãƒœã‚¹ã®ä½ç½®ã¨å›žè»¢ã‚’å–å¾—
    Vector3 bossPos = boss->GetTranslate();
    float bossRotY = boss->GetRotate().y;

    // ãƒ¯ãƒ¼ãƒ«ãƒ‰ç©ºé–“ã§ã®è§’åº¦ã‚’è¨ˆç®—
    float worldAngle = bossRotY + blockAngle_;

    // Mat4x4::MakeRotateYã§å›žè»¢è¡Œåˆ—ã‚’ä½œæˆ
    Matrix4x4 rotationMatrix = Mat4x4::MakeRotateY(worldAngle);

    // å›žè»¢è¡Œåˆ—ã‚’ä½¿ã£ã¦ãƒ­ãƒ¼ã‚«ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«å¤‰æ›
    Vector3 localOffset = { 0.0f, 0.0f, blockRadius_ };  // å‰æ–¹å‘ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    Vector3 worldOffset = Mat4x4::TransformNormal(rotationMatrix, localOffset);

    // ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã‚’è¨ˆç®—
    Vector3 blockPos = bossPos + worldOffset;

    // ãƒ–ãƒ­ãƒƒã‚¯ã®Transformè¨­å®š
    Transform blockTransform;
    blockTransform.translate = blockPos;
    blockTransform.rotate = { 0.0f, worldAngle, 0.0f };
    blockTransform.scale = { blockScale_, blockScale_, blockScale_ };
    block->SetTransform(blockTransform);
    block->Update();

    // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®å‘ãè¨­å®šï¼ˆãƒœã‚¹ã®å‘ãã«è¿½å¾“ï¼‰
    BossMeleeAttackCollider* collider = boss->GetMeleeAttackCollider();
    if (collider && colliderActivated_) {
        collider->SetOrientation(Mat4x4::MakeRotateY(bossRotY));
    }
}

nlohmann::json BTBossMeleeAttack::ExtractParameters() const {
    return {
        {"prepareTime", prepareTime_},
        {"attackDuration", attackDuration_},
        {"recoveryTime", recoveryTime_},
        {"blockRadius", blockRadius_},
        {"blockScale", blockScale_},
        {"swingAngle", swingAngle_},
        {"rushDistance", rushDistance_},
        {"stopDistance", stopDistance_}
    };
}

#ifdef _DEBUG
bool BTBossMeleeAttack::DrawImGui() {
    bool changed = false;

    if (ImGui::DragFloat("Prepare Time##melee", &prepareTime_, 0.05f, 0.0f, 3.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Attack Duration##melee", &attackDuration_, 0.05f, 0.0f, 3.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Recovery Time##melee", &recoveryTime_, 0.05f, 0.0f, 3.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Block Radius##melee", &blockRadius_, 0.1f, 0.5f, 10.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Block Scale##melee", &blockScale_, 0.1f, 0.1f, 5.0f)) {
        changed = true;
    }
    if (ImGui::SliderAngle("Swing Angle##melee", &swingAngle_, 0.0f, 360.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Rush Distance##melee", &rushDistance_, 1.0f, 0.0f, 50.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Stop Distance##melee", &stopDistance_, 0.5f, 1.0f, 20.0f)) {
        changed = true;
    }

    return changed;
}
#endif


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossMeleeAttack.h
============================================================
#pragma once
#include <numbers>

#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"
#include "Vector3.h"

class Boss;

/// <summary>
/// ãƒœã‚¹ã®è¿‘æŽ¥æ”»æ’ƒã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒŽãƒ¼ãƒ‰
/// æº–å‚™â†’æ”»æ’ƒâ†’ç¡¬ç›´ã®3ãƒ•ã‚§ãƒ¼ã‚ºã§æ­¦å™¨ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒ¯ã‚‹
/// </summary>
class BTBossMeleeAttack : public BTNode {
    //=========================================================================================
    // å®šæ•°
    //=========================================================================================
private:
    static constexpr float kDirectionEpsilon = 0.01f;   ///< æ–¹å‘åˆ¤å®šã®é–¾å€¤
    static constexpr float kBlockStartAngle = -1.5708f; ///< ãƒ–ãƒ­ãƒƒã‚¯é–‹å§‹è§’åº¦ï¼ˆ-Ï€/2ã€å³å´ã‹ã‚‰é–‹å§‹ï¼‰
    static constexpr float kAngleEpsilon = 0.001f;      ///< è§’åº¦åˆ¤å®šã®é–¾å€¤

    //=========================================================================================
    // åˆ—æŒ™åž‹
    //=========================================================================================
private:
    /// <summary>
    /// æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚º
    /// </summary>
    enum class MeleePhase {
        Prepare,    ///< æº–å‚™ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ã‚’å‘ãã€äºˆå…†è¡¨ç¤ºï¼‰
        Execute,    ///< æ”»æ’ƒå®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚ºï¼ˆãƒ–ãƒ­ãƒƒã‚¯å›žè»¢ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šï¼‰
        Recovery    ///< ç¡¬ç›´ãƒ•ã‚§ãƒ¼ã‚º
    };

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossMeleeAttack();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossMeleeAttack() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ãƒ»è¨­å®š
    float GetPrepareTime() const { return prepareTime_; }
    void SetPrepareTime(float time) { prepareTime_ = time; }
    float GetAttackDuration() const { return attackDuration_; }
    void SetAttackDuration(float duration) { attackDuration_ = duration; }
    float GetRecoveryTime() const { return recoveryTime_; }
    void SetRecoveryTime(float time) { recoveryTime_ = time; }
    float GetBlockRadius() const { return blockRadius_; }
    void SetBlockRadius(float radius) { blockRadius_ = radius; }
    float GetBlockScale() const { return blockScale_; }
    void SetBlockScale(float scale) { blockScale_ = scale; }
    float GetSwingAngle() const { return swingAngle_; }
    void SetSwingAngle(float angle) { swingAngle_ = angle; }
    float GetRushDistance() const { return rushDistance_; }
    void SetRushDistance(float distance) { rushDistance_ = distance; }
    float GetStopDistance() const { return stopDistance_; }
    void SetStopDistance(float distance) { stopDistance_ = distance; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override {
        if (params.contains("prepareTime")) {
            prepareTime_ = params["prepareTime"];
        }
        if (params.contains("attackDuration")) {
            attackDuration_ = params["attackDuration"];
        }
        if (params.contains("recoveryTime")) {
            recoveryTime_ = params["recoveryTime"];
        }
        if (params.contains("blockRadius")) {
            blockRadius_ = params["blockRadius"];
        }
        if (params.contains("blockScale")) {
            blockScale_ = params["blockScale"];
        }
        if (params.contains("swingAngle")) {
            swingAngle_ = params["swingAngle"];
        }
        if (params.contains("rushDistance")) {
            rushDistance_ = params["rushDistance"];
        }
        if (params.contains("stopDistance")) {
            stopDistance_ = params["stopDistance"];
        }
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

private:
    /// <summary>
    /// æ”»æ’ƒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void InitializeMeleeAttack(Boss* boss);

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ã‚’å‘ãå‡¦ç†
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void AimAtPlayer(Boss* boss, float deltaTime);

    /// <summary>
    /// æº–å‚™ãƒ•ã‚§ãƒ¼ã‚ºã®å‡¦ç†
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void ProcessPreparePhase(Boss* boss, float deltaTime);

    /// <summary>
    /// æ”»æ’ƒå®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚ºã®å‡¦ç†
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void ProcessExecutePhase(Boss* boss, float deltaTime);

    /// <summary>
    /// ç¡¬ç›´ãƒ•ã‚§ãƒ¼ã‚ºã®å‡¦ç†
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void ProcessRecoveryPhase(Boss* boss);

    /// <summary>
    /// ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã®æ›´æ–°ï¼ˆMat4x4ä½¿ç”¨ï¼‰
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void UpdateBlockPosition(Boss* boss);

    /// <summary>
    /// ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ä½ç½®ã‚’è¨ˆç®—
    /// </summary>
    /// <param name="position">èª¿æ•´å‰ã®ä½ç½®</param>
    /// <returns>ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ä½ç½®</returns>
    Vector3 ClampToArea(const Vector3& position);

    /// <summary>
    /// çªé€²ã®åˆæœŸåŒ–ï¼ˆExecuteé–‹å§‹æ™‚ã«å‘¼ã¶ï¼‰
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void InitializeRush(Boss* boss);

    //=========================================================================================
    // ãƒ¡ãƒ³ãƒå¤‰æ•°
    //=========================================================================================
private:
    // ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†
    MeleePhase currentPhase_ = MeleePhase::Prepare;

    // æ™‚é–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    float prepareTime_ = 1.0f;      ///< æº–å‚™æ™‚é–“
    float attackDuration_ = 0.3f;   ///< æ”»æ’ƒæŒç¶šæ™‚é–“
    float recoveryTime_ = 0.3f;     ///< ç¡¬ç›´æ™‚é–“
    float totalDuration_ = 1.6f;    ///< ç·æ™‚é–“

    // ãƒ–ãƒ­ãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    float blockRadius_ = 8.0f;      ///< ãƒœã‚¹ã‹ã‚‰ã®è·é›¢
    float blockScale_ = 0.5f;       ///< ãƒ–ãƒ­ãƒƒã‚¯ã‚¹ã‚±ãƒ¼ãƒ«
    float swingAngle_ =             ///< æŒ¯ã‚Šå¹…ï¼ˆÏ€ = 180åº¦ï¼‰
        static_cast<float>(std::numbers::pi);
    float blockAngle_ = 0.0f;       ///< ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯è§’åº¦

    // çŠ¶æ…‹ç®¡ç†
    float elapsedTime_ = 0.0f;      ///< çµŒéŽæ™‚é–“
    float phaseTimer_ = 0.0f;       ///< ç¾åœ¨ãƒ•ã‚§ãƒ¼ã‚ºã®ã‚¿ã‚¤ãƒžãƒ¼
    bool isFirstExecute_ = true;    ///< åˆå›žå®Ÿè¡Œãƒ•ãƒ©ã‚°
    bool colliderActivated_ = false;///< ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼æœ‰åŠ¹åŒ–æ¸ˆã¿ãƒ•ãƒ©ã‚°

    // çªé€²ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    float rushDistance_ = 20.0f;    ///< çªé€²è·é›¢ï¼ˆãƒŸã‚¹æ™‚ï¼‰
    float stopDistance_ = 5.0f;     ///< ãƒ’ãƒƒãƒˆæ™‚ã®åœæ­¢è·é›¢ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®è·é›¢ï¼‰

    // çªé€²çŠ¶æ…‹ç®¡ç†
    Vector3 startPosition_;         ///< çªé€²é–‹å§‹ä½ç½®
    Vector3 targetPosition_;        ///< çªé€²ç›®æ¨™ä½ç½®ï¼ˆExecuteé–‹å§‹æ™‚ã«å›ºå®šï¼‰
    Vector3 rushDirection_;         ///< çªé€²æ–¹å‘
    bool rushInitialized_ = false;  ///< çªé€²åˆæœŸåŒ–æ¸ˆã¿ãƒ•ãƒ©ã‚°
};


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossRapidFire.cpp
============================================================
#include "BTBossRapidFire.h"
#include "../../Boss.h"
#include "../../../Player/Player.h"
#include "../../../../Common/GameConst.h"
#include <cmath>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossRapidFire::BTBossRapidFire() {
    name_ = "BossRapidFire";
}

BTNodeStatus BTBossRapidFire::Execute(BTBlackboard* blackboard) {
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    float deltaTime = blackboard->GetDeltaTime();

    // åˆå›žå®Ÿè¡Œæ™‚ã®åˆæœŸåŒ–
    if (isFirstExecute_) {
        InitializeRapidFire(boss);
        isFirstExecute_ = false;
    }

    // ãƒ•ã‚§ãƒ¼ã‚º1: ãƒãƒ£ãƒ¼ã‚¸ä¸­ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç…§æº–ï¼‰
    if (elapsedTime_ < chargeTime_) {
        AimAtPlayer(boss, deltaTime);
    }
    // ãƒ•ã‚§ãƒ¼ã‚º2: é€£ç¶šç™ºå°„ä¸­ï¼ˆè¿½å°¾ã—ãªãŒã‚‰ç™ºå°„ï¼‰
    else if (firedCount_ < bulletCount_) {
        // ç™ºå°„ä¸­ã‚‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ã‚’è¿½å°¾
        AimAtPlayer(boss, deltaTime);

        // ç™ºå°„é–“éš”ãƒã‚§ãƒƒã‚¯
        timeSinceLastFire_ += deltaTime;
        if (timeSinceLastFire_ >= fireInterval_) {
            FireBullet(boss);
            firedCount_++;
            timeSinceLastFire_ = 0.0f;
        }
    }
    // ãƒ•ã‚§ãƒ¼ã‚º3: ç¡¬ç›´ä¸­ï¼ˆä½•ã‚‚ã—ãªã„ï¼‰

    // çµŒéŽæ™‚é–“ã‚’æ›´æ–°
    elapsedTime_ += deltaTime;

    // çŠ¶æ…‹çµ‚äº†ãƒã‚§ãƒƒã‚¯
    if (elapsedTime_ >= totalDuration_) {
        // ãƒªã‚»ãƒƒãƒˆã—ã¦æˆåŠŸã‚’è¿”ã™
        isFirstExecute_ = true;
        elapsedTime_ = 0.0f;
        firedCount_ = 0;
        timeSinceLastFire_ = 0.0f;
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    // ã¾ã å°„æ’ƒå‡¦ç†ä¸­
    status_ = BTNodeStatus::Running;
    return BTNodeStatus::Running;
}

void BTBossRapidFire::Reset() {
    BTNode::Reset();
    elapsedTime_ = 0.0f;
    firedCount_ = 0;
    timeSinceLastFire_ = 0.0f;
    isFirstExecute_ = true;
}

void BTBossRapidFire::InitializeRapidFire(Boss* boss) {
    // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
    elapsedTime_ = 0.0f;
    firedCount_ = 0;
    // å³åº§ã«1ç™ºç›®ã‚’æ’ƒã¦ã‚‹ã‚ˆã†ã«
    timeSinceLastFire_ = fireInterval_;

    // totalDurationã‚’è¨ˆç®—
    // ãƒãƒ£ãƒ¼ã‚¸æ™‚é–“ + (ç™ºå°„é–“éš” Ã— å¼¾æ•°) + ç¡¬ç›´æ™‚é–“
    totalDuration_ = chargeTime_ + (fireInterval_ * static_cast<float>(bulletCount_)) + recoveryTime_;
}

void BTBossRapidFire::AimAtPlayer(Boss* boss, float deltaTime) {
    Player* player = boss->GetPlayer();
    if (!player) {
        return;
    }

    Vector3 playerPos = player->GetTransform().translate;
    Vector3 bossPos = boss->GetTransform().translate;
    Vector3 toPlayer = playerPos - bossPos;
    toPlayer.y = 0.0f; // Yè»¸ã¯ç„¡è¦–

    if (toPlayer.Length() > GameConst::kDirectionEpsilon) {
        toPlayer = toPlayer.Normalize();
        float angle = atan2f(toPlayer.x, toPlayer.z);
        boss->SetRotate(Vector3(0.0f, angle, 0.0f));
    }
}

void BTBossRapidFire::FireBullet(Boss* boss) {
    // ç™ºå°„ä½ç½®ï¼ˆãƒœã‚¹ã®åº§æ¨™ï¼‰
    Vector3 firePosition = boss->GetTransform().translate;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®æ–¹å‘ã‚’è¨ˆç®—
    Vector3 direction = CalculateDirectionToPlayer(boss);

    // å¼¾ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
    Vector3 bulletVelocity = direction * bulletSpeed_;

    // ãƒœã‚¹ã«å¼¾ç”Ÿæˆã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
    boss->RequestBulletSpawn(firePosition, bulletVelocity);
}

Vector3 BTBossRapidFire::CalculateDirectionToPlayer(Boss* boss) {
    Player* player = boss->GetPlayer();
    if (!player) {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„å ´åˆã¯å‰æ–¹å‘ã‚’è¿”ã™
        return Vector3(0.0f, 0.0f, 1.0f);
    }

    Vector3 firePosition = boss->GetTransform().translate;
    Vector3 playerPos = player->GetTransform().translate;
    Vector3 toPlayer = playerPos - firePosition;

    // æ°´å¹³æ–¹å‘ã®ã¿ã§è¨ˆç®—
    float distance = sqrtf(toPlayer.x * toPlayer.x + toPlayer.z * toPlayer.z);
    if (distance > GameConst::kDirectionEpsilon) {
        toPlayer = toPlayer.Normalize();
    } else {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒçœŸä¸Šã«ã„ã‚‹å ´åˆãªã©
        toPlayer = Vector3(0.0f, 0.0f, 1.0f);
    }

    return toPlayer;
}

nlohmann::json BTBossRapidFire::ExtractParameters() const {
    return {
        {"chargeTime", chargeTime_},
        {"bulletCount", bulletCount_},
        {"fireInterval", fireInterval_},
        {"bulletSpeed", bulletSpeed_},
        {"recoveryTime", recoveryTime_}
    };
}

#ifdef _DEBUG
bool BTBossRapidFire::DrawImGui() {
    bool changed = false;

    if (ImGui::DragFloat("Charge Time##rapidfire", &chargeTime_, 0.05f, 0.0f, 3.0f)) {
        changed = true;
    }
    if (ImGui::DragInt("Bullet Count##rapidfire", &bulletCount_, 1, 1, 20)) {
        changed = true;
    }
    if (ImGui::DragFloat("Fire Interval##rapidfire", &fireInterval_, 0.01f, 0.05f, 1.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Bullet Speed##rapidfire", &bulletSpeed_, 1.0f, 5.0f, 100.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Recovery Time##rapidfire", &recoveryTime_, 0.05f, 0.0f, 3.0f)) {
        changed = true;
    }

    return changed;
}
#endif


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossRapidFire.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"
#include "Vector3.h"

class Boss;

/// <summary>
/// ãƒœã‚¹ã®é€£ç¶šè¿½å°¾å°„æ’ƒã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒŽãƒ¼ãƒ‰
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ã«é€£ç¶šã§å¼¾ã‚’ç™ºå°„ã™ã‚‹æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³
/// ç™ºå°„ä¸­ã‚‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹å‘ã‚’è¿½å°¾ã—ç¶šã‘ã‚‹
/// </summary>
class BTBossRapidFire : public BTNode {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossRapidFire();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossRapidFire() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ãƒ»è¨­å®š
    float GetChargeTime() const { return chargeTime_; }
    void SetChargeTime(float time) { chargeTime_ = time; }
    int GetBulletCount() const { return bulletCount_; }
    void SetBulletCount(int count) { bulletCount_ = count; }
    float GetFireInterval() const { return fireInterval_; }
    void SetFireInterval(float interval) { fireInterval_ = interval; }
    float GetBulletSpeed() const { return bulletSpeed_; }
    void SetBulletSpeed(float speed) { bulletSpeed_ = speed; }
    float GetRecoveryTime() const { return recoveryTime_; }
    void SetRecoveryTime(float time) { recoveryTime_ = time; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override {
        if (params.contains("chargeTime")) {
            chargeTime_ = params["chargeTime"];
        }
        if (params.contains("bulletCount")) {
            bulletCount_ = params["bulletCount"];
        }
        if (params.contains("fireInterval")) {
            fireInterval_ = params["fireInterval"];
        }
        if (params.contains("bulletSpeed")) {
            bulletSpeed_ = params["bulletSpeed"];
        }
        if (params.contains("recoveryTime")) {
            recoveryTime_ = params["recoveryTime"];
        }
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

private:
    /// <summary>
    /// å°„æ’ƒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void InitializeRapidFire(Boss* boss);

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç‹™ã†å‡¦ç†
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void AimAtPlayer(Boss* boss, float deltaTime);

    /// <summary>
    /// å¼¾ã‚’1ç™ºç™ºå°„
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void FireBullet(Boss* boss);

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®æ–¹å‘ã‚’è¨ˆç®—
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <returns>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®æ­£è¦åŒ–ã•ã‚ŒãŸæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector3 CalculateDirectionToPlayer(Boss* boss);

    // å°„æ’ƒå‰ã®æº–å‚™æ™‚é–“
    float chargeTime_ = 0.5f;

    // ç™ºå°„ã™ã‚‹å¼¾ã®æ•°
    int bulletCount_ = 5;

    // ç™ºå°„é–“éš”ï¼ˆç§’ï¼‰
    float fireInterval_ = 0.15f;

    // å°„æ’ƒå¾Œã®ç¡¬ç›´æ™‚é–“
    float recoveryTime_ = 0.5f;

    // çŠ¶æ…‹ã®ç·æ™‚é–“
    float totalDuration_ = 0.0f;

    // å¼¾ã®é€Ÿåº¦
    float bulletSpeed_ = 20.0f;

    // çµŒéŽæ™‚é–“
    float elapsedTime_ = 0.0f;

    // ç™ºå°„æ¸ˆã¿å¼¾æ•°
    int firedCount_ = 0;

    // å‰å›žç™ºå°„ã‹ã‚‰ã®çµŒéŽæ™‚é–“
    float timeSinceLastFire_ = 0.0f;

    // åˆå›žå®Ÿè¡Œãƒ•ãƒ©ã‚°
    bool isFirstExecute_ = true;
};


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossRetreat.cpp
============================================================
#include "BTBossRetreat.h"
#include "../../Boss.h"
#include "../../../Player/Player.h"
#include "../../../../Common/GameConst.h"
#include "Mat4x4Func.h"

#include <algorithm>
#include <array>
#include <cmath>
#include <numbers>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossRetreat::BTBossRetreat() {
    name_ = "BossRetreat";
}

BTNodeStatus BTBossRetreat::Execute(BTBlackboard* blackboard) {
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    Player* player = blackboard->GetPlayer();
    if (!player) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    float deltaTime = blackboard->GetDeltaTime();

    // åˆå›žå®Ÿè¡Œæ™‚ã®åˆæœŸåŒ–
    if (isFirstExecute_) {
        InitializeRetreat(boss, player);
        isFirstExecute_ = false;

        // æ—¢ã«ç›®æ¨™è·é›¢ä»¥ä¸Šé›¢ã‚Œã¦ã„ã‚‹å ´åˆã¯å³åº§ã«æˆåŠŸ
        if (retreatDuration_ <= 0.0f) {
            isFirstExecute_ = true;
            status_ = BTNodeStatus::Success;
            return BTNodeStatus::Success;
        }
    }

    // é›¢è„±ç§»å‹•ã®æ›´æ–°
    UpdateRetreatMovement(boss, deltaTime);

    // çµŒéŽæ™‚é–“ã‚’æ›´æ–°
    elapsedTime_ += deltaTime;

    // çµ‚äº†åˆ¤å®šï¼ˆä½ç½®ãƒ™ãƒ¼ã‚¹ï¼‰
    Vector3 currentPos = boss->GetTransform().translate;
    Vector3 diff = currentPos - targetPosition_;
    diff.y = 0.0f;  // æ°´å¹³è·é›¢ã®ã¿
    float distanceToTarget = diff.Length();

    if (distanceToTarget < kArrivalThreshold) {
        // ç›®æ¨™ä½ç½®ã«åˆ°é”
        boss->SetTranslate(targetPosition_);

        // ãƒªã‚»ãƒƒãƒˆã—ã¦æˆåŠŸã‚’è¿”ã™
        isFirstExecute_ = true;
        elapsedTime_ = 0.0f;
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    // ã¾ã é›¢è„±ä¸­
    status_ = BTNodeStatus::Running;
    return BTNodeStatus::Running;
}

void BTBossRetreat::Reset() {
    BTNode::Reset();
    elapsedTime_ = 0.0f;
    isFirstExecute_ = true;
    retreatDuration_ = 0.0f;
}

void BTBossRetreat::InitializeRetreat(Boss* boss, Player* player) {
    // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
    elapsedTime_ = 0.0f;

    // é–‹å§‹ä½ç½®ã‚’è¨˜éŒ²
    startPosition_ = boss->GetTransform().translate;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‚’å–å¾—
    Vector3 playerPos = player->GetTransform().translate;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ãƒœã‚¹ã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆé›¢ã‚Œã‚‹æ–¹å‘ï¼‰
    Vector3 toRetreat = startPosition_ - playerPos;
    toRetreat.y = 0.0f;  // æ°´å¹³é¢ã®ã¿
    float currentDistance = toRetreat.Length();

    if (currentDistance > kDirectionEpsilon) {
        Vector3 primaryDirection = toRetreat.Normalize();

        // ç›®æ¨™ä½ç½® = ç¾åœ¨ä½ç½®ã‹ã‚‰ targetDistance_ ã¾ã§é›¢ã‚ŒãŸä½ç½®
        float retreatDistance = targetDistance_ - currentDistance;
        if (retreatDistance > 0.0f) {
            // å£å›žé¿: æœ€é©ãªé›¢è„±æ–¹å‘ã‚’æŽ¢ç´¢
            Vector3 bestDirection = FindBestRetreatDirection(primaryDirection, retreatDistance);

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‘ã„ãŸã¾ã¾ï¼ˆbestDirectionã®é€†æ–¹å‘ã‚’å‘ãï¼‰
            float angle = atan2f(-bestDirection.x, -bestDirection.z);
            boss->SetRotate(Vector3(0.0f, angle, 0.0f));

            targetPosition_ = startPosition_ + bestDirection * retreatDistance;
            targetPosition_ = ClampToArea(targetPosition_);

            // å®Ÿéš›ã®ç§»å‹•è·é›¢ã‹ã‚‰æ‰€è¦æ™‚é–“ã‚’è¨ˆç®—
            Vector3 actualMove = targetPosition_ - startPosition_;
            actualMove.y = 0.0f;
            float actualDistance = actualMove.Length();
            retreatDuration_ = actualDistance / retreatSpeed_;
        }
        else {
            // æ—¢ã«ç›®æ¨™è·é›¢ä»¥ä¸Šé›¢ã‚Œã¦ã„ã‚‹
            targetPosition_ = startPosition_;
            retreatDuration_ = 0.0f;
        }
    }
    else {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã»ã¼åŒã˜ä½ç½®
        targetPosition_ = startPosition_;
        retreatDuration_ = 0.0f;
    }
}

void BTBossRetreat::UpdateRetreatMovement(Boss* boss, float deltaTime) {
    deltaTime; // æœªä½¿ç”¨è­¦å‘ŠæŠ‘åˆ¶

    if (retreatDuration_ > 0.0f) {
        // é›¢è„±ä¸­ã®ç§»å‹•
        float t = elapsedTime_ / retreatDuration_;

        // clamp to [0, 1]
        t = std::clamp(t, 0.0f, 1.0f);

        // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆåŠ é€Ÿâ†’æ¸›é€Ÿï¼‰: smoothstep
        t = t * t * (kEasingCoeffA - kEasingCoeffB * t);

        Vector3 newPosition = Vector3::Lerp(startPosition_, targetPosition_, t);
        boss->SetTranslate(newPosition);
    }
}

Vector3 BTBossRetreat::ClampToArea(const Vector3& position) {
    Vector3 clampedPos = position;

    // GameConstantsã®ã‚¹ãƒ†ãƒ¼ã‚¸å¢ƒç•Œã‚’ä½¿ç”¨
    // Xåº§æ¨™ã®åˆ¶é™
    clampedPos.x = std::clamp(clampedPos.x, GameConst::kStageXMin + GameConst::kAreaMargin, GameConst::kStageXMax - GameConst::kAreaMargin);

    // Zåº§æ¨™ã®åˆ¶é™
    clampedPos.z = std::clamp(clampedPos.z, GameConst::kStageZMin + GameConst::kAreaMargin, GameConst::kStageZMax - GameConst::kAreaMargin);

    // Yåº§æ¨™ã¯å…ƒã®å€¤ã‚’ä¿æŒ
    clampedPos.y = position.y;

    return clampedPos;
}

Vector3 BTBossRetreat::FindBestRetreatDirection(const Vector3& primaryDirection, float retreatDistance) {
    // å…ƒã®æ–¹å‘ã§ã®ç§»å‹•è·é›¢ã‚’è©•ä¾¡
    float primaryScore = EvaluateDirection(primaryDirection, retreatDistance);

    // é–¾å€¤ä»¥ä¸Šãªã‚‰å…ƒã®æ–¹å‘ã‚’ä½¿ç”¨
    if (primaryScore >= kMinRetreatDistance) {
        return primaryDirection;
    }

    // ä»£æ›¿æ–¹å‘ã‚’è©•ä¾¡ï¼ˆMat4x4::MakeRotateY + TransformNormalã§å›žè»¢ï¼‰
    constexpr float kHalfPi = std::numbers::pi_v<float> / 2.0f;  // 90åº¦
    constexpr float kPi = std::numbers::pi_v<float>;              // 180åº¦

    Matrix4x4 rotLeft90 = Mat4x4::MakeRotateY(kHalfPi);
    Matrix4x4 rotRight90 = Mat4x4::MakeRotateY(-kHalfPi);
    Matrix4x4 rot180 = Mat4x4::MakeRotateY(kPi);

    struct DirectionCandidate {
        Vector3 direction;
        float score;
    };

    std::array<DirectionCandidate, 4> candidates = {{
        { primaryDirection, primaryScore },
        { Mat4x4::TransformNormal(rotLeft90, primaryDirection), 0.0f },   // å·¦90åº¦
        { Mat4x4::TransformNormal(rotRight90, primaryDirection), 0.0f },  // å³90åº¦
        { Mat4x4::TransformNormal(rot180, primaryDirection), 0.0f }       // 180åº¦ï¼ˆé€†æ–¹å‘ï¼‰
    }};

    // å„æ–¹å‘ã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
    for (size_t i = 1; i < candidates.size(); ++i) {
        candidates[i].score = EvaluateDirection(candidates[i].direction, retreatDistance);
    }

    // æœ€é«˜ã‚¹ã‚³ã‚¢ã®æ–¹å‘ã‚’é¸æŠž
    auto best = std::max_element(candidates.begin(), candidates.end(),
        [](const DirectionCandidate& a, const DirectionCandidate& b) {
            return a.score < b.score;
        });

    return best->direction;
}

float BTBossRetreat::EvaluateDirection(const Vector3& direction, float retreatDistance) {
    Vector3 targetPos = startPosition_ + direction * retreatDistance;
    targetPos = ClampToArea(targetPos);

    Vector3 actualMove = targetPos - startPosition_;
    actualMove.y = 0.0f;
    return actualMove.Length();
}

nlohmann::json BTBossRetreat::ExtractParameters() const {
    return {
        {"retreatSpeed", retreatSpeed_},
        {"targetDistance", targetDistance_}
    };
}

#ifdef _DEBUG
bool BTBossRetreat::DrawImGui() {
    bool changed = false;

    if (ImGui::DragFloat("Retreat Speed##retreat", &retreatSpeed_, 1.0f, 10.0f, 200.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Target Distance##retreat", &targetDistance_, 0.5f, 1.0f, 100.0f)) {
        changed = true;
    }

    ImGui::Separator();
    ImGui::Text("Runtime Info:");
    ImGui::Text("Duration: %.2f sec", retreatDuration_);
    ImGui::Text("Elapsed: %.2f sec", elapsedTime_);

    return changed;
}
#endif


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossRetreat.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"
#include "Vector3.h"

class Boss;
class Player;

/// <summary>
/// ãƒœã‚¹ã®é›¢è„±ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒŽãƒ¼ãƒ‰
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‘ã„ãŸã¾ã¾å¾Œæ–¹ã«ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ç§»å‹•ã§é›¢ã‚Œã‚‹
/// </summary>
class BTBossRetreat : public BTNode {
    //=========================================================================================
    // å®šæ•°
    //=========================================================================================
private:
    static constexpr float kDirectionEpsilon = 0.01f;  ///< æ–¹å‘åˆ¤å®šã®é–¾å€¤
    static constexpr float kArrivalThreshold = 0.5f;   ///< åˆ°é”åˆ¤å®šã®é–¾å€¤
    static constexpr float kEasingCoeffA = 3.0f;       ///< ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ä¿‚æ•°A
    static constexpr float kEasingCoeffB = 2.0f;       ///< ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ä¿‚æ•°B
    static constexpr float kMinRetreatDistance = 10.0f; ///< ä»£æ›¿æ–¹å‘ã‚’æ¤œè¨Žã™ã‚‹æœ€å°ç§»å‹•è·é›¢

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossRetreat();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossRetreat() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ãƒ»è¨­å®š
    float GetRetreatSpeed() const { return retreatSpeed_; }
    void SetRetreatSpeed(float speed) { retreatSpeed_ = speed; }
    float GetTargetDistance() const { return targetDistance_; }
    void SetTargetDistance(float distance) { targetDistance_ = distance; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override {
        if (params.contains("retreatSpeed")) {
            retreatSpeed_ = params["retreatSpeed"];
        }
        if (params.contains("targetDistance")) {
            targetDistance_ = params["targetDistance"];
        }
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

private:
    /// <summary>
    /// é›¢è„±ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</param>
    void InitializeRetreat(Boss* boss, Player* player);

    /// <summary>
    /// é›¢è„±ç§»å‹•ã®æ›´æ–°
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void UpdateRetreatMovement(Boss* boss, float deltaTime);

    /// <summary>
    /// ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ä½ç½®ã‚’è¨ˆç®—
    /// </summary>
    /// <param name="position">èª¿æ•´å‰ã®ä½ç½®</param>
    /// <returns>ã‚¨ãƒªã‚¢å†…ã«åŽã¾ã‚‹ä½ç½®</returns>
    Vector3 ClampToArea(const Vector3& position);

    /// <summary>
    /// æœ€é©ãªé›¢è„±æ–¹å‘ã‚’æŽ¢ç´¢ï¼ˆå£å›žé¿ï¼‰
    /// </summary>
    /// <param name="primaryDirection">åŸºæœ¬ã®é›¢è„±æ–¹å‘</param>
    /// <param name="retreatDistance">é›¢è„±è·é›¢</param>
    /// <returns>æœ€é©ãªé›¢è„±æ–¹å‘</returns>
    Vector3 FindBestRetreatDirection(const Vector3& primaryDirection, float retreatDistance);

    /// <summary>
    /// æŒ‡å®šæ–¹å‘ã§ã®ç§»å‹•è·é›¢ã‚’è©•ä¾¡
    /// </summary>
    /// <param name="direction">è©•ä¾¡ã™ã‚‹æ–¹å‘</param>
    /// <param name="retreatDistance">é›¢è„±è·é›¢</param>
    /// <returns>å®Ÿéš›ã«ç§»å‹•ã§ãã‚‹è·é›¢</returns>
    float EvaluateDirection(const Vector3& direction, float retreatDistance);

    //=========================================================================================
    // ãƒ¡ãƒ³ãƒå¤‰æ•°
    //=========================================================================================
private:
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    float retreatSpeed_ = 60.0f;       ///< é›¢è„±é€Ÿåº¦
    float targetDistance_ = 55.0f;     ///< ç›®æ¨™è·é›¢ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®è·é›¢ï¼‰

    // çŠ¶æ…‹ç®¡ç†
    Vector3 startPosition_;            ///< é–‹å§‹ä½ç½®
    Vector3 targetPosition_;           ///< ç›®æ¨™ä½ç½®ï¼ˆè¨ˆç®—æ¸ˆã¿ï¼‰
    float elapsedTime_ = 0.0f;         ///< çµŒéŽæ™‚é–“
    float retreatDuration_ = 0.0f;     ///< é›¢è„±æ‰€è¦æ™‚é–“ï¼ˆè·é›¢ã‹ã‚‰å‹•çš„è¨ˆç®—ï¼‰
    bool isFirstExecute_ = true;       ///< åˆå›žå®Ÿè¡Œãƒ•ãƒ©ã‚°
};


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossShoot.cpp
============================================================
#include "BTBossShoot.h"
#include "../../Boss.h"
#include "../../../Player/Player.h"
#include <cmath>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossShoot::BTBossShoot() {
    name_ = "BossShoot";
}

BTNodeStatus BTBossShoot::Execute(BTBlackboard* blackboard) {
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    float deltaTime = blackboard->GetDeltaTime();

    // åˆå›žå®Ÿè¡Œæ™‚ã®åˆæœŸåŒ–
    if (isFirstExecute_) {
        InitializeShoot(boss);
        isFirstExecute_ = false;
        hasFired_ = false;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹å‘ã‚’å‘ãï¼ˆå°„æ’ƒæº–å‚™ä¸­ï¼‰
    if (elapsedTime_ < chargeTime_) {
        AimAtPlayer(boss, deltaTime);
    }

    // å¼¾ã‚’ç™ºå°„
    if (elapsedTime_ >= chargeTime_ && !hasFired_) {
        FireBullets(boss);
        hasFired_ = true;
    }

    // çµŒéŽæ™‚é–“ã‚’æ›´æ–°
    elapsedTime_ += deltaTime;

    // çŠ¶æ…‹çµ‚äº†ãƒã‚§ãƒƒã‚¯
    if (elapsedTime_ >= totalDuration_) {
        // ãƒªã‚»ãƒƒãƒˆã—ã¦æˆåŠŸã‚’è¿”ã™
        isFirstExecute_ = true;
        elapsedTime_ = 0.0f;
        hasFired_ = false;
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    // ã¾ã å°„æ’ƒå‡¦ç†ä¸­
    status_ = BTNodeStatus::Running;
    return BTNodeStatus::Running;
}

void BTBossShoot::Reset() {
    BTNode::Reset();
    elapsedTime_ = 0.0f;
    isFirstExecute_ = true;
    hasFired_ = false;
}

void BTBossShoot::InitializeShoot(Boss* boss) {
    // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
    elapsedTime_ = 0.0f;

    // totalDurationã‚’è¨ˆç®—
    totalDuration_ = chargeTime_ + recoveryTime_;
}

void BTBossShoot::AimAtPlayer(Boss* boss, float deltaTime) {
    Player* player = boss->GetPlayer();
    if (!player) {
        return;
    }

    Vector3 playerPos = player->GetTransform().translate;
    Vector3 bossPos = boss->GetTransform().translate;
    Vector3 toPlayer = playerPos - bossPos;
    toPlayer.y = 0.0f; // Yè»¸ã¯ç„¡è¦–

    if (toPlayer.Length() > kDirectionEpsilon) {
        toPlayer = toPlayer.Normalize();
        float angle = atan2f(toPlayer.x, toPlayer.z);
        boss->SetRotate(Vector3(0.0f, angle, 0.0f));
    }
}

void BTBossShoot::FireBullets(Boss* boss) {
    Player* player = boss->GetPlayer();
    if (!player) {
        return;
    }

    // ç™ºå°„ä½ç½®ï¼ˆãƒœã‚¹ã®å‰æ–¹å°‘ã—ä¸Šï¼‰
    Vector3 firePosition = boss->GetTransform().translate;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®æ–¹å‘ã‚’è¨ˆç®—
    Vector3 playerPos = player->GetTransform().translate;
    Vector3 toPlayer = playerPos - firePosition;

    // æ°´å¹³æ–¹å‘ã®ã¿ã§è¨ˆç®—ï¼ˆYæˆåˆ†ã¯å°ã•ãä¿ã¤ï¼‰
    float distance = sqrtf(toPlayer.x * toPlayer.x + toPlayer.z * toPlayer.z);
    if (distance > kDirectionEpsilon) {
        toPlayer = toPlayer.Normalize();
    }

    // å¼¾ã‚’ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ
    for (int i = 0; i < bulletCount_; i++) {
        // ç™ºå°„è§’åº¦ã‚’è¨ˆç®—ï¼ˆæ‰‡çŠ¶ã«åˆ†æ•£ï¼‰
        float angleOffset = 0.0f;
        if (bulletCount_ > 1) {
            // -spreadAngle_ã‹ã‚‰+spreadAngle_ã®ç¯„å›²ã«å‡ç­‰ã«åˆ†æ•£
            float t = static_cast<float>(i) / static_cast<float>(bulletCount_ - 1);
            angleOffset = spreadAngle_ * (2.0f * t - 1.0f);
        }

        // ç™ºå°„æ–¹å‘ã‚’è¨ˆç®—
        Vector3 bulletDirection = CalculateBulletDirection(toPlayer, angleOffset);

        // å¼¾ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
        Vector3 bulletVelocity = bulletDirection * bulletSpeed_;

        // ãƒœã‚¹ã«å¼¾ç”Ÿæˆã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
        boss->RequestBulletSpawn(firePosition, bulletVelocity);
    }
}

Vector3 BTBossShoot::CalculateBulletDirection(const Vector3& baseDirection, float angleOffset) {
    if (std::abs(angleOffset) < kAngleEpsilon) {
        // ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒãªã„å ´åˆã¯ãã®ã¾ã¾è¿”ã™
        return baseDirection;
    }

    // Yè»¸å›žè»¢è¡Œåˆ—ã‚’ä½œæˆ
    float cos_angle = cosf(angleOffset);
    float sin_angle = sinf(angleOffset);

    // å›žè»¢ã‚’é©ç”¨ï¼ˆYè»¸å›žè»¢ï¼‰
    Vector3 rotatedDirection;
    rotatedDirection.x = baseDirection.x * cos_angle - baseDirection.z * sin_angle;
    rotatedDirection.y = baseDirection.y;
    rotatedDirection.z = baseDirection.x * sin_angle + baseDirection.z * cos_angle;

    rotatedDirection = rotatedDirection.Normalize();
    return rotatedDirection;
}

nlohmann::json BTBossShoot::ExtractParameters() const {
    return {
        {"chargeTime", chargeTime_},
        {"recoveryTime", recoveryTime_},
        {"bulletSpeed", bulletSpeed_},
        {"spreadAngle", spreadAngle_}
    };
}

#ifdef _DEBUG
bool BTBossShoot::DrawImGui() {
    bool changed = false;

    if (ImGui::DragFloat("Charge Time##shoot", &chargeTime_, 0.05f, 0.0f, 3.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Recovery Time##shoot", &recoveryTime_, 0.05f, 0.0f, 3.0f)) {
        changed = true;
    }
    if (ImGui::DragFloat("Bullet Speed##shoot", &bulletSpeed_, 1.0f, 5.0f, 100.0f)) {
        changed = true;
    }
    if (ImGui::SliderAngle("Spread Angle##shoot", &spreadAngle_, 0.0f, 45.0f)) {
        changed = true;
    }
    if (ImGui::DragInt("Bullet Count##shoot", &bulletCount_, 1, 1, 10)) {
        changed = true;
    }

    return changed;
}
#endif

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Actions/BTBossShoot.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"
#include "Vector3.h"

class Boss;

/// <summary>
/// ãƒœã‚¹ã®å°„æ’ƒã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒŽãƒ¼ãƒ‰
/// </summary>
class BTBossShoot : public BTNode {
    //=========================================================================================
    // å®šæ•°
    //=========================================================================================
private:
    static constexpr float kDirectionEpsilon = 0.01f;  ///< æ–¹å‘åˆ¤å®šã®é–¾å€¤
    static constexpr float kAngleEpsilon = 0.001f;     ///< è§’åº¦åˆ¤å®šã®é–¾å€¤

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossShoot();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossShoot() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—ãƒ»è¨­å®š
    float GetChargeTime() const { return chargeTime_; }
    void SetChargeTime(float time) { chargeTime_ = time; }
    float GetBulletSpeed() const { return bulletSpeed_; }
    void SetBulletSpeed(float speed) { bulletSpeed_ = speed; }
    float GetSpreadAngle() const { return spreadAngle_; }
    void SetSpreadAngle(float angle) { spreadAngle_ = angle; }
    float GetRecoveryTime() const { return recoveryTime_; }
    void SetRecoveryTime(float time) { recoveryTime_ = time; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override {
        if (params.contains("chargeTime")) {
            chargeTime_ = params["chargeTime"];
        }
        if (params.contains("bulletSpeed")) {
            bulletSpeed_ = params["bulletSpeed"];
        }
        if (params.contains("spreadAngle")) {
            spreadAngle_ = params["spreadAngle"];
        }
        if (params.contains("recoveryTime")) {
            recoveryTime_ = params["recoveryTime"];
        }
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

private:
    /// <summary>
    /// å°„æ’ƒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void InitializeShoot(Boss* boss);

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç‹™ã†å‡¦ç†
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void AimAtPlayer(Boss* boss, float deltaTime);

    /// <summary>
    /// å¼¾ã‚’ç™ºå°„
    /// </summary>
    /// <param name="boss">ãƒœã‚¹</param>
    void FireBullets(Boss* boss);

    /// <summary>
    /// å¼¾ã®ç™ºå°„æ–¹å‘ã‚’è¨ˆç®—
    /// </summary>
    /// <param name="baseDirection">åŸºæº–æ–¹å‘</param>
    /// <param name="angleOffset">è§’åº¦ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</param>
    /// <returns>ç™ºå°„æ–¹å‘</returns>
    Vector3 CalculateBulletDirection(const Vector3& baseDirection, float angleOffset);

    // å°„æ’ƒå‰ã®æº–å‚™æ™‚é–“
    float chargeTime_ = 0.5f;

    // å°„æ’ƒå¾Œã®ç¡¬ç›´æ™‚é–“
    float recoveryTime_ = 0.5f;

    // çŠ¶æ…‹ã®ç·æ™‚é–“
    float totalDuration_ = 1.0f;

    // å¼¾ãŒç™ºå°„æ¸ˆã¿ã‹ã©ã†ã‹
    bool hasFired_ = false;

    // å¼¾ã®é€Ÿåº¦
    float bulletSpeed_ = 20.0f;

    // æ‰‡çŠ¶ç™ºå°„ã®è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
    float spreadAngle_ = 0.2618f; // ç´„15åº¦

    // çµŒéŽæ™‚é–“
    float elapsedTime_ = 0.0f;

    // åˆå›žå®Ÿè¡Œãƒ•ãƒ©ã‚°
    bool isFirstExecute_ = true;

    // å¼¾æ•°ï¼ˆImGuièª¿æ•´ç”¨ï¼‰
    int bulletCount_ = 3;  ///< ç™ºå°„ã™ã‚‹å¼¾æ•°
};

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/BossBehaviorTree.cpp
============================================================
#include "BossBehaviorTree.h"
#include "../../../BehaviorTree/Core/BTComposite.h"
#include "../../../BehaviorTree/Composites/BTSelector.h"
#include "../../../BehaviorTree/Composites/BTSequence.h"
#include "Actions/BTBossIdle.h"
#include "Actions/BTBossDash.h"
#include "Actions/BTBossShoot.h"
#include "Conditions/BTActionSelector.h"
#include "../Boss.h"
#include "../../Player/Player.h"
#include "../BossBehaviorTree/BossNodeFactory.h"
#include <fstream>
#include <unordered_map>

BossBehaviorTree::BossBehaviorTree(Boss* boss, Player* player) {
    // ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰ã®åˆæœŸåŒ–
    blackboard_ = std::make_unique<BTBlackboard>();
    blackboard_->SetBoss(boss);
    blackboard_->SetPlayer(player);
    blackboard_->SetInt("ActionCounter", 0);

    // ãƒ„ãƒªãƒ¼ã‚’èª­ã¿è¾¼ã¿
    LoadFromJSON("resources/Json/BossTree.json");
}

BossBehaviorTree::~BossBehaviorTree() = default;

void BossBehaviorTree::Update(float deltaTime) {
    if (!rootNode_) {
        return;
    }

    // ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰ã«ãƒ‡ãƒ«ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ ã‚’è¨­å®š
    blackboard_->SetDeltaTime(deltaTime);

    // å®Ÿè¡Œå‰ã«å®Ÿè¡Œä¸­ãƒŽãƒ¼ãƒ‰æƒ…å ±ã‚’ã‚¯ãƒªã‚¢
    currentRunningNode_ = nullptr;

    // ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ
    BTNodeStatus status = rootNode_->Execute(blackboard_.get());

    // å®Ÿè¡Œä¸­ãƒŽãƒ¼ãƒ‰ã‚’æ¤œç´¢
    FindRunningNodeRecursive(rootNode_);

    // å®Œäº†ã—ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
    if (status != BTNodeStatus::Running) {
        rootNode_->Reset();
    }
}

void BossBehaviorTree::Reset() {
    if (rootNode_) {
        rootNode_->Reset();
    }
    blackboard_->SetInt("ActionCounter", 0);
}

void BossBehaviorTree::SetPlayer(Player* player) {
    blackboard_->SetPlayer(player);
}

const std::string& BossBehaviorTree::GetCurrentNodeName() const {
    return currentNodeName_;
}

void BossBehaviorTree::BuildTree() {
    // ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰ã¯è¡Œå‹•ãƒ„ãƒªãƒ¼
    rootNode_ = BuildActionTree();
}

BTNodePtr BossBehaviorTree::BuildActionTree() {
    // ãƒ«ãƒ¼ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ï¼ˆIdle â†’ Action ã‚’ç¹°ã‚Šè¿”ã™ï¼‰
    auto rootSequence = std::make_shared<BTSequence>();
    rootSequence->SetName("MainLoop");

    // 1. Idleï¼ˆå¾…æ©Ÿï¼‰
    auto idleNode = std::make_shared<BTBossIdle>();
    rootSequence->AddChild(idleNode);

    // 2. Actioné¸æŠžï¼ˆDashã‹Shootã‹ï¼‰
    auto actionSelector = std::make_shared<BTSelector>();
    actionSelector->SetName("ActionSelector");

    // 2-1. Dashãƒ–ãƒ©ãƒ³ãƒï¼ˆå¶æ•°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼‰
    auto dashSequence = std::make_shared<BTSequence>();
    dashSequence->SetName("DashSequence");

    auto dashCondition = std::make_shared<BTActionSelector>(BTActionSelector::ActionType::Dash);
    auto dashAction = std::make_shared<BTBossDash>();

    dashSequence->AddChild(dashCondition);
    dashSequence->AddChild(dashAction);

    // 2-2. Shootãƒ–ãƒ©ãƒ³ãƒï¼ˆå¥‡æ•°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼‰
    auto shootSequence = std::make_shared<BTSequence>();
    shootSequence->SetName("ShootSequence");

    auto shootCondition = std::make_shared<BTActionSelector>(BTActionSelector::ActionType::Shoot);
    auto shootAction = std::make_shared<BTBossShoot>();

    shootSequence->AddChild(shootCondition);
    shootSequence->AddChild(shootAction);

    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é¸æŠžã«ãƒ–ãƒ©ãƒ³ãƒã‚’è¿½åŠ 
    actionSelector->AddChild(dashSequence);
    actionSelector->AddChild(shootSequence);

    // ãƒ«ãƒ¼ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é¸æŠžã‚’è¿½åŠ 
    rootSequence->AddChild(actionSelector);

    return rootSequence;
}

/// <summary>
/// ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰ã‚’å¤–éƒ¨ã‹ã‚‰è¨­å®š
/// </summary>
void BossBehaviorTree::SetRootNode(BTNodePtr rootNode) {
    if (rootNode) {
        rootNode_ = rootNode;
        // æ—¢å­˜ã®ãƒ„ãƒªãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
        Reset();
        currentNodeName_ = "External Tree";
    }
}

/// <summary>
/// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ„ãƒªãƒ¼ã‚’èª­ã¿è¾¼ã¿
/// </summary>
bool BossBehaviorTree::LoadFromJSON(const std::string& filepath) {
    try {
        // JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
        std::ifstream file(filepath);
        if (!file.is_open()) {
            return false;
        }

        nlohmann::json json;
        file >> json;
        file.close();

        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
        if (!json.contains("version") || json["version"] != "1.0") {
            return false;
        }

        // ãƒŽãƒ¼ãƒ‰ãƒžãƒƒãƒ—ã‚’ä½œæˆï¼ˆID â†’ ãƒŽãƒ¼ãƒ‰æƒ…å ±ï¼‰
        std::unordered_map<int, nlohmann::json> nodeMap;
        if (json.contains("nodes")) {
            for (const auto& nodeJson : json["nodes"]) {
                int nodeId = nodeJson["id"];
                nodeMap[nodeId] = nodeJson;
            }
        }

        // ãƒªãƒ³ã‚¯æƒ…å ±ã‚’å–å¾—
        std::vector<nlohmann::json> links;
        if (json.contains("links")) {
            links = json["links"].get<std::vector<nlohmann::json>>();
        }

        // ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰ã‚’æŽ¢ã™ï¼ˆè¦ªãƒªãƒ³ã‚¯ã‚’æŒãŸãªã„ãƒŽãƒ¼ãƒ‰ï¼‰
        int rootNodeId = -1;
        std::unordered_set<int> childNodeIds;
        for (const auto& link : links) {
            childNodeIds.insert(link["targetNodeId"].get<int>());
        }

        for (const auto& [nodeId, nodeJson] : nodeMap) {
            if (childNodeIds.find(nodeId) == childNodeIds.end()) {
                rootNodeId = nodeId;
                break;
            }
        }

        if (rootNodeId == -1 && !nodeMap.empty()) {
            // ãƒ«ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€æœ€åˆã®ãƒŽãƒ¼ãƒ‰ã‚’ãƒ«ãƒ¼ãƒˆã¨ã™ã‚‹
            rootNodeId = nodeMap.begin()->first;
        }

        if (rootNodeId == -1) {
            return false;
        }

        // ãƒ„ãƒªãƒ¼ã‚’å†å¸°çš„ã«æ§‹ç¯‰
        std::unordered_set<int> visitedNodes;
        rootNode_ = BuildNodeFromJSON(nodeMap[rootNodeId], nodeMap, links, visitedNodes);

        if (!rootNode_) {
            return false;
        }

        // ãƒ„ãƒªãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
        Reset();
        currentNodeName_ = "Loaded from JSON";

        return true;
    }
    catch (const std::exception&) {
        // ã‚¨ãƒ©ãƒ¼å‡¦ç†
        return false;
    }
}

/// <summary>
/// JSONã‹ã‚‰ãƒŽãƒ¼ãƒ‰ãƒ„ãƒªãƒ¼ã‚’å†å¸°çš„ã«æ§‹ç¯‰
/// </summary>
BTNodePtr BossBehaviorTree::BuildNodeFromJSON(
    const nlohmann::json& nodeJson,
    const std::unordered_map<int, nlohmann::json>& nodeMap,
    const std::vector<nlohmann::json>& links,
    std::unordered_set<int>& visitedNodes) {

    if (nodeJson.empty()) return nullptr;

    int nodeId = nodeJson["id"];

    // å¾ªç’°å‚ç…§ã‚’é˜²ã
    if (visitedNodes.find(nodeId) != visitedNodes.end()) {
        return nullptr;
    }
    visitedNodes.insert(nodeId);

    // ãƒŽãƒ¼ãƒ‰ã‚’ä½œæˆï¼ˆBossNodeFactoryã‚’ä½¿ç”¨ï¼‰
    std::string nodeType = nodeJson["type"];
    BTNodePtr node = BossNodeFactory::CreateNode(nodeType);

    if (!node) {
        return nullptr;
    }

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨ï¼ˆãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã§å„ãƒŽãƒ¼ãƒ‰ãŒè‡ªå·±å‡¦ç†ï¼‰
    if (nodeJson.contains("parameters") && !nodeJson["parameters"].is_null()) {
        node->ApplyParameters(nodeJson["parameters"]);
    }

    // è¡¨ç¤ºåã‚’è¨­å®šï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    if (nodeJson.contains("displayName")) {
        node->SetName(nodeJson["displayName"]);
    }

    // ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã®å ´åˆã€å­ãƒŽãƒ¼ãƒ‰ã‚’è¿½åŠ 
    if (node->IsComposite()) {
        auto compositeNode = std::dynamic_pointer_cast<BTComposite>(node);
        if (compositeNode) {
            // ã“ã®ãƒŽãƒ¼ãƒ‰ã®å­ãƒŽãƒ¼ãƒ‰IDã‚’åŽé›†
            std::vector<int> childIds;
            for (const auto& link : links) {
                if (link["sourceNodeId"] == nodeId) {
                    childIds.push_back(link["targetNodeId"]);
                }
            }

            // å­ãƒŽãƒ¼ãƒ‰ã‚’å†å¸°çš„ã«æ§‹ç¯‰
            for (int childId : childIds) {
                auto childIt = nodeMap.find(childId);
                if (childIt != nodeMap.end()) {
                    BTNodePtr childNode = BuildNodeFromJSON(childIt->second, nodeMap, links, visitedNodes);
                    if (childNode) {
                        compositeNode->AddChild(childNode);
                    }
                }
            }
        }
    }

    return node;
}

/// <summary>
/// å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰ã‚’å†å¸°çš„ã«æ¤œç´¢
/// </summary>
void BossBehaviorTree::FindRunningNodeRecursive(const BTNodePtr& node) {
    if (!node || !node->IsRunning()) {
        return;
    }

    // ç¾åœ¨å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰ã‚’æ›´æ–°
    currentRunningNode_ = node;

    // ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã®å ´åˆã€å­ãƒŽãƒ¼ãƒ‰ã‚‚æŽ¢ç´¢
    auto composite = std::dynamic_pointer_cast<BTComposite>(node);
    if (composite) {
        const auto& children = composite->GetChildren();
        for (const auto& child : children) {
            if (child && child->IsRunning()) {
                // å®Ÿè¡Œä¸­ã®å­ãƒŽãƒ¼ãƒ‰ã‚’å†å¸°çš„ã«æŽ¢ç´¢
                FindRunningNodeRecursive(child);
                break;  // æœ€åˆã«è¦‹ã¤ã‹ã£ãŸå®Ÿè¡Œä¸­ã®å­ãƒŽãƒ¼ãƒ‰ã®ã¿å‡¦ç†
            }
        }
    }
}

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/BossBehaviorTree.h
============================================================
#pragma once
#include "../../../BehaviorTree/Core/BTNode.h"
#include "../../../BehaviorTree/Core/BTBlackboard.h"
#include <memory>
#include <json.hpp>
#include <unordered_set>

class Boss;
class Player;

/// <summary>
/// ãƒœã‚¹ç”¨ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼
/// </summary>
class BossBehaviorTree {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    /// <param name="boss">ãƒœã‚¹ã®ãƒã‚¤ãƒ³ã‚¿</param>
    /// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
    BossBehaviorTree(Boss* boss, Player* player);

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~BossBehaviorTree();

    /// <summary>
    /// ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã®æ›´æ–°
    /// </summary>
    /// <param name="deltaTime">çµŒéŽæ™‚é–“</param>
    void Update(float deltaTime);

    /// <summary>
    /// ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset();

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¨­å®š
    /// </summary>
    /// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetPlayer(Player* player);

    /// <summary>
    /// ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰å</returns>
    const std::string& GetCurrentNodeName() const;

    /// <summary>
    /// ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰ã®å–å¾—ï¼ˆã‚¨ãƒ‡ã‚£ã‚¿ç”¨ï¼‰
    /// </summary>
    /// <returns>ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰</returns>
    BTNodePtr GetRootNode() const { return rootNode_; }

    /// <summary>
    /// ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰ã‚’å¤–éƒ¨ã‹ã‚‰è¨­å®š
    /// </summary>
    /// <param name="rootNode">æ–°ã—ã„ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰</param>
    void SetRootNode(BTNodePtr rootNode);

    /// <summary>
    /// ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰ã®å–å¾—ï¼ˆãƒŽãƒ¼ãƒ‰åˆæœŸåŒ–ç”¨ï¼‰
    /// </summary>
    /// <returns>ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</returns>
    BTBlackboard* GetBlackboard() const { return blackboard_.get(); }

    /// <summary>
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ„ãƒªãƒ¼ã‚’èª­ã¿è¾¼ã¿
    /// </summary>
    /// <param name="filepath">JSONãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    /// <returns>æˆåŠŸã—ãŸã‚‰true</returns>
    bool LoadFromJSON(const std::string& filepath);

    /// <summary>
    /// ç¾åœ¨å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰ã‚’å–å¾—
    /// </summary>
    /// <returns>å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰ï¼ˆãªã‘ã‚Œã°nullptrï¼‰</returns>
    BTNodePtr GetCurrentRunningNode() const { return currentRunningNode_; }

private:
    /// <summary>
    /// ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã®æ§‹ç¯‰
    /// </summary>
    void BuildTree();

    /// <summary>
    /// è¡Œå‹•ãƒ„ãƒªãƒ¼ã®æ§‹ç¯‰ï¼ˆIdle â†’ Dash/Shoot ã®é¸æŠžï¼‰
    /// </summary>
    /// <returns>æ§‹ç¯‰ã—ãŸãƒŽãƒ¼ãƒ‰</returns>
    BTNodePtr BuildActionTree();

    /// <summary>
    /// JSONã‹ã‚‰ãƒŽãƒ¼ãƒ‰ãƒ„ãƒªãƒ¼ã‚’å†å¸°çš„ã«æ§‹ç¯‰
    /// </summary>
    /// <param name="nodeJson">ãƒŽãƒ¼ãƒ‰ã®JSON</param>
    /// <param name="nodeMap">å…¨ãƒŽãƒ¼ãƒ‰ã®ãƒžãƒƒãƒ—</param>
    /// <param name="links">ãƒªãƒ³ã‚¯æƒ…å ±</param>
    /// <param name="visitedNodes">è¨ªå•æ¸ˆã¿ãƒŽãƒ¼ãƒ‰ã‚»ãƒƒãƒˆ</param>
    /// <returns>æ§‹ç¯‰ã—ãŸãƒŽãƒ¼ãƒ‰</returns>
    BTNodePtr BuildNodeFromJSON(const nlohmann::json& nodeJson,
                                const std::unordered_map<int, nlohmann::json>& nodeMap,
                                const std::vector<nlohmann::json>& links,
                                std::unordered_set<int>& visitedNodes);

    /// <summary>
    /// å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰ã‚’å†å¸°çš„ã«æ¤œç´¢
    /// </summary>
    /// <param name="node">æ¤œç´¢é–‹å§‹ãƒŽãƒ¼ãƒ‰</param>
    void FindRunningNodeRecursive(const BTNodePtr& node);

    // ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰
    BTNodePtr rootNode_;

    // ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰
    std::unique_ptr<BTBlackboard> blackboard_;

    // ç¾åœ¨ã®ãƒŽãƒ¼ãƒ‰å
    std::string currentNodeName_;

    // å®Ÿè¡Œä¸­ãƒŽãƒ¼ãƒ‰è¿½è·¡ç”¨
    BTNodePtr currentRunningNode_;
};

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/BossNodeFactory.cpp
============================================================
// ===== å…¨ãƒ“ãƒ«ãƒ‰ã§ä½¿ç”¨å¯èƒ½ãªã‚³ãƒ¼ãƒ‰ =====

#include "BossNodeFactory.h"

// BehaviorTreeãƒŽãƒ¼ãƒ‰ã®ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰
#include "../../../BehaviorTree/Composites/BTSelector.h"
#include "../../../BehaviorTree/Composites/BTSequence.h"
#include "../../../BehaviorTree/Composites/BTRandomSelector.h"
#include "../BossBehaviorTree/Actions/BTBossIdle.h"
#include "../BossBehaviorTree/Actions/BTBossDash.h"
#include "../BossBehaviorTree/Actions/BTBossShoot.h"
#include "../BossBehaviorTree/Actions/BTBossRapidFire.h"
#include "../BossBehaviorTree/Actions/BTBossMeleeAttack.h"
#include "../BossBehaviorTree/Actions/BTBossApproach.h"
#include "../BossBehaviorTree/Actions/BTBossRetreat.h"
#include "../BossBehaviorTree/Conditions/BTActionSelector.h"
#include "../BossBehaviorTree/Conditions/BTBossPhaseCondition.h"
#include "../BossBehaviorTree/Conditions/BTBossHPCondition.h"
#include "../BossBehaviorTree/Conditions/BTBossDistanceCondition.h"

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã®ç”Ÿæˆ
/// </summary>
BTNodePtr BossNodeFactory::CreateNode(const std::string& nodeType) {
    // CompositeãƒŽãƒ¼ãƒ‰
    if (nodeType == "BTSelector") {
        return std::make_shared<BTSelector>();
    }
    else if (nodeType == "BTSequence") {
        return std::make_shared<BTSequence>();
    }
    else if (nodeType == "BTRandomSelector") {
        return std::make_shared<BTRandomSelector>();
    }
    // ActionãƒŽãƒ¼ãƒ‰ï¼ˆBlackboardçµŒç”±ã§Boss/Playerã«ã‚¢ã‚¯ã‚»ã‚¹ï¼‰
    else if (nodeType == "BTBossIdle") {
        return std::make_shared<BTBossIdle>();
    }
    else if (nodeType == "BTBossDash") {
        return std::make_shared<BTBossDash>();
    }
    else if (nodeType == "BTBossShoot") {
        return std::make_shared<BTBossShoot>();
    }
    else if (nodeType == "BTBossRapidFire") {
        return std::make_shared<BTBossRapidFire>();
    }
    else if (nodeType == "BTBossMeleeAttack") {
        return std::make_shared<BTBossMeleeAttack>();
    }
    else if (nodeType == "BTBossApproach") {
        return std::make_shared<BTBossApproach>();
    }
    else if (nodeType == "BTBossRetreat") {
        return std::make_shared<BTBossRetreat>();
    }
    // ConditionãƒŽãƒ¼ãƒ‰
    else if (nodeType == "BTActionSelector") {
        return std::make_shared<BTActionSelector>(BTActionSelector::ActionType::Dash);
    }
    else if (nodeType == "BTBossPhaseCondition") {
        return std::make_shared<BTBossPhaseCondition>();
    }
    else if (nodeType == "BTBossHPCondition") {
        return std::make_shared<BTBossHPCondition>();
    }
    else if (nodeType == "BTBossDistanceCondition") {
        return std::make_shared<BTBossDistanceCondition>();
    }

    return nullptr;
}

/// <summary>
/// Boss/Playerã®ä¾å­˜é–¢ä¿‚ã‚’æŒã¤ãƒŽãƒ¼ãƒ‰ã®ç”Ÿæˆ
/// </summary>
BTNodePtr BossNodeFactory::CreateNodeWithDependencies(
    const std::string& nodeType,
    [[maybe_unused]] Boss* boss,
    [[maybe_unused]] Player* player) {

    // ç¾åœ¨ã¯å…¨ãƒŽãƒ¼ãƒ‰ãŒBlackboardçµŒç”±ã§å‚ç…§ã™ã‚‹ãŸã‚ã€CreateNodeã¨åŒã˜
    return CreateNode(nodeType);
}

// ===== ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã®ã¿ã®ã‚³ãƒ¼ãƒ‰ =====

#ifdef _DEBUG

#include <typeinfo>
#include <algorithm>

// é™çš„ãƒ¡ãƒ³ãƒã®å®šç¾©
std::vector<BossNodeFactory::NodeTypeInfo> BossNodeFactory::nodeTypes_;
bool BossNodeFactory::initialized_ = false;

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æƒ…å ±ã®åˆæœŸåŒ–
/// </summary>
void BossNodeFactory::InitializeNodeTypes() {
    if (initialized_) return;

    // ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æƒ…å ±ã®ç™»éŒ²
    nodeTypes_ = {
        // ========== Composite ãƒŽãƒ¼ãƒ‰ ==========
        {
            "BTSelector",
            "Selector",
            NodeCategory::Composite,
            ImVec4(0.8f, 0.4f, 0.2f, 1.0f),  // ã‚ªãƒ¬ãƒ³ã‚¸
            true  // å­ãƒŽãƒ¼ãƒ‰ã‚’æŒã¦ã‚‹
        },
        {
            "BTSequence",
            "Sequence",
            NodeCategory::Composite,
            ImVec4(0.2f, 0.6f, 0.8f, 1.0f),  // é’
            true  // å­ãƒŽãƒ¼ãƒ‰ã‚’æŒã¦ã‚‹
        },
        {
            "BTRandomSelector",
            "Random Selector",
            NodeCategory::Composite,
            ImVec4(0.9f, 0.6f, 0.2f, 1.0f),  // æ˜Žã‚‹ã„ã‚ªãƒ¬ãƒ³ã‚¸
            true  // å­ãƒŽãƒ¼ãƒ‰ã‚’æŒã¦ã‚‹
        },

        // ========== Action ãƒŽãƒ¼ãƒ‰ ==========
        {
            "BTBossIdle",
            "Idle",
            NodeCategory::Action,
            ImVec4(0.2f, 0.8f, 0.4f, 1.0f),  // ç·‘
            false  // å­ãƒŽãƒ¼ãƒ‰ã‚’æŒã¦ãªã„
        },
        {
            "BTBossDash",
            "Dash",
            NodeCategory::Action,
            ImVec4(0.3f, 0.8f, 0.5f, 1.0f),  // æ˜Žã‚‹ã„ç·‘
            false
        },
        {
            "BTBossShoot",
            "Shoot",
            NodeCategory::Action,
            ImVec4(0.8f, 0.3f, 0.3f, 1.0f),  // èµ¤
            false
        },
        {
            "BTBossRapidFire",
            "Rapid Fire",
            NodeCategory::Action,
            ImVec4(0.9f, 0.2f, 0.5f, 1.0f),  // ãƒžã‚¼ãƒ³ã‚¿
            false
        },
        {
            "BTBossMeleeAttack",
            "Melee Attack",
            NodeCategory::Action,
            ImVec4(0.9f, 0.4f, 0.1f, 1.0f),  // ã‚ªãƒ¬ãƒ³ã‚¸-èµ¤
            false
        },
        {
            "BTBossApproach",
            "Approach",
            NodeCategory::Action,
            ImVec4(0.4f, 0.9f, 0.4f, 1.0f),  // æ˜Žã‚‹ã„ç·‘ï¼ˆç§»å‹•ç³»ï¼‰
            false
        },
        {
            "BTBossRetreat",
            "Retreat",
            NodeCategory::Action,
            ImVec4(0.3f, 0.7f, 0.9f, 1.0f),  // æ°´è‰²ï¼ˆApproachã¨å¯¾ã«ãªã‚‹è‰²ï¼‰
            false
        },

        // ========== Condition ãƒŽãƒ¼ãƒ‰ ==========
        {
            "BTActionSelector",
            "Action Selector",
            NodeCategory::Condition,
            ImVec4(0.8f, 0.8f, 0.2f, 1.0f),  // é»„è‰²
            false
        },
        {
            "BTBossPhaseCondition",
            "Phase Condition",
            NodeCategory::Condition,
            ImVec4(0.5f, 0.2f, 0.9f, 1.0f),  // ç´«
            false
        },
        {
            "BTBossHPCondition",
            "HP Condition",
            NodeCategory::Condition,
            ImVec4(0.9f, 0.5f, 0.2f, 1.0f),  // ã‚ªãƒ¬ãƒ³ã‚¸
            false
        },
        {
            "BTBossDistanceCondition",
            "Distance Condition",
            NodeCategory::Condition,
            ImVec4(0.2f, 0.7f, 0.5f, 1.0f),  // ç·‘
            false
        }
    };

    initialized_ = true;
}

/// <summary>
/// åˆ©ç”¨å¯èƒ½ãªãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ä¸€è¦§ã®å–å¾—
/// </summary>
std::vector<std::string> BossNodeFactory::GetAvailableNodeTypes() {
    InitializeNodeTypes();

    std::vector<std::string> types;
    for (const auto& nodeType : nodeTypes_) {
        types.push_back(nodeType.typeName);
    }
    return types;
}

/// <summary>
/// ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å–å¾—
/// </summary>
std::vector<std::string> BossNodeFactory::GetNodeTypesByCategory(NodeCategory category) {
    InitializeNodeTypes();

    std::vector<std::string> types;
    for (const auto& nodeType : nodeTypes_) {
        if (nodeType.category == category) {
            types.push_back(nodeType.typeName);
        }
    }
    return types;
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã®å–å¾—ï¼ˆé€†å¼•ãï¼‰
/// </summary>
std::string BossNodeFactory::GetNodeType(const BTNodePtr& node) {
    if (!node) return "";

    // RTTIã‚’ä½¿ç”¨ã—ã¦ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
    const std::type_info& typeInfo = typeid(*node);

    // å„ã‚¿ã‚¤ãƒ—ã¨æ¯”è¼ƒ
    if (typeInfo == typeid(BTSelector)) return "BTSelector";
    if (typeInfo == typeid(BTSequence)) return "BTSequence";
    if (typeInfo == typeid(BTRandomSelector)) return "BTRandomSelector";
    if (typeInfo == typeid(BTBossIdle)) return "BTBossIdle";
    if (typeInfo == typeid(BTBossDash)) return "BTBossDash";
    if (typeInfo == typeid(BTBossShoot)) return "BTBossShoot";
    if (typeInfo == typeid(BTBossRapidFire)) return "BTBossRapidFire";
    if (typeInfo == typeid(BTBossMeleeAttack)) return "BTBossMeleeAttack";
    if (typeInfo == typeid(BTBossApproach)) return "BTBossApproach";
    if (typeInfo == typeid(BTBossRetreat)) return "BTBossRetreat";
    if (typeInfo == typeid(BTActionSelector)) return "BTActionSelector";
    if (typeInfo == typeid(BTBossPhaseCondition)) return "BTBossPhaseCondition";
    if (typeInfo == typeid(BTBossHPCondition)) return "BTBossHPCondition";
    if (typeInfo == typeid(BTBossDistanceCondition)) return "BTBossDistanceCondition";

    return "";
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æƒ…å ±ã®å–å¾—
/// </summary>
BossNodeFactory::NodeTypeInfo BossNodeFactory::GetNodeTypeInfo(const std::string& nodeType) {
    InitializeNodeTypes();

    for (const auto& info : nodeTypes_) {
        if (info.typeName == nodeType) {
            return info;
        }
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
    NodeTypeInfo defaultInfo;
    defaultInfo.typeName = nodeType;
    defaultInfo.displayName = nodeType;
    defaultInfo.category = NodeCategory::Action;
    defaultInfo.color = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
    defaultInfo.isComposite = false;
    return defaultInfo;
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã®è¡¨ç¤ºåã‚’å–å¾—
/// </summary>
std::string BossNodeFactory::GetNodeDisplayName(const std::string& nodeType) {
    NodeTypeInfo info = GetNodeTypeInfo(nodeType);
    return info.displayName;
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã®è‰²ã‚’å–å¾—
/// </summary>
ImVec4 BossNodeFactory::GetNodeColor(const std::string& nodeType) {
    NodeTypeInfo info = GetNodeTypeInfo(nodeType);
    return info.color;
}

/// <summary>
/// ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã‹ã©ã†ã‹åˆ¤å®š
/// </summary>
bool BossNodeFactory::IsCompositeNode(const std::string& nodeType) {
    NodeTypeInfo info = GetNodeTypeInfo(nodeType);
    return info.isComposite;
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—
/// </summary>
BossNodeFactory::NodeCategory BossNodeFactory::GetNodeCategory(const std::string& nodeType) {
    NodeTypeInfo info = GetNodeTypeInfo(nodeType);
    return info.category;
}

#endif // _DEBUG


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/BossNodeFactory.h
============================================================
#pragma once

#include <string>
#include <vector>
#include <memory>
#include "../../../BehaviorTree/Core/BTNode.h"

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

class Boss;
class Player;

/// <summary>
/// ãƒœã‚¹ãƒŽãƒ¼ãƒ‰ã®ç”Ÿæˆãƒ•ã‚¡ã‚¯ãƒˆãƒª
/// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æ–‡å­—åˆ—ã‹ã‚‰å®Ÿéš›ã®BTNodeã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
/// </summary>
class BossNodeFactory {
public:
    // ===== å…¨ãƒ“ãƒ«ãƒ‰ã§ä½¿ç”¨å¯èƒ½ =====

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ç”Ÿæˆ
    /// </summary>
    /// <param name="nodeType">ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åï¼ˆ"BTSelector", "BTSequence"ç­‰ï¼‰</param>
    /// <returns>ç”Ÿæˆã•ã‚ŒãŸãƒŽãƒ¼ãƒ‰ï¼ˆå¤±æ•—æ™‚ã¯nullptrï¼‰</returns>
    static BTNodePtr CreateNode(const std::string& nodeType);

    /// <summary>
    /// Boss/Playerã®ä¾å­˜é–¢ä¿‚ã‚’æŒã¤ãƒŽãƒ¼ãƒ‰ã®ç”Ÿæˆ
    /// </summary>
    /// <param name="nodeType">ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å</param>
    /// <param name="boss">ãƒœã‚¹ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆå¿…è¦ãªå ´åˆï¼‰</param>
    /// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆå¿…è¦ãªå ´åˆï¼‰</param>
    /// <returns>ç”Ÿæˆã•ã‚ŒãŸãƒŽãƒ¼ãƒ‰ï¼ˆå¤±æ•—æ™‚ã¯nullptrï¼‰</returns>
    static BTNodePtr CreateNodeWithDependencies(
        const std::string& nodeType,
        Boss* boss = nullptr,
        Player* player = nullptr
    );

#ifdef _DEBUG
    // ===== ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã®ã¿ =====

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã‚«ãƒ†ã‚´ãƒª
    /// </summary>
    enum class NodeCategory {
        Composite,      // è¤‡åˆãƒŽãƒ¼ãƒ‰ï¼ˆSelector, Sequenceï¼‰
        Action,         // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒŽãƒ¼ãƒ‰ï¼ˆIdle, Dash, Shootï¼‰
        Condition,      // æ¡ä»¶ãƒŽãƒ¼ãƒ‰ï¼ˆActionSelectorï¼‰
        Decorator       // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒŽãƒ¼ãƒ‰ï¼ˆå°†æ¥ã®æ‹¡å¼µç”¨ï¼‰
    };

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æƒ…å ±
    /// </summary>
    struct NodeTypeInfo {
        std::string typeName;           // ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åï¼ˆ"BTSelector"ç­‰ï¼‰
        std::string displayName;        // è¡¨ç¤ºåï¼ˆ"ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼"ç­‰ï¼‰
        NodeCategory category;          // ã‚«ãƒ†ã‚´ãƒª
        ImVec4 color;                  // ãƒŽãƒ¼ãƒ‰ã‚«ãƒ©ãƒ¼
        bool isComposite;              // å­ãƒŽãƒ¼ãƒ‰ã‚’æŒã¦ã‚‹ã‹
    };

    /// <summary>
    /// åˆ©ç”¨å¯èƒ½ãªãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ä¸€è¦§ã®å–å¾—
    /// </summary>
    /// <returns>åˆ©ç”¨å¯èƒ½ãªãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åã®ãƒªã‚¹ãƒˆ</returns>
    static std::vector<std::string> GetAvailableNodeTypes();

    /// <summary>
    /// ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å–å¾—
    /// </summary>
    /// <param name="category">ã‚«ãƒ†ã‚´ãƒª</param>
    /// <returns>è©²å½“ã‚«ãƒ†ã‚´ãƒªã®ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒªã‚¹ãƒˆ</returns>
    static std::vector<std::string> GetNodeTypesByCategory(NodeCategory category);

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã®å–å¾—ï¼ˆé€†å¼•ãï¼‰
    /// </summary>
    /// <param name="node">BTNodeã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
    /// <returns>ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å</returns>
    static std::string GetNodeType(const BTNodePtr& node);

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æƒ…å ±ã®å–å¾—
    /// </summary>
    /// <param name="nodeType">ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å</param>
    /// <returns>ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æƒ…å ±</returns>
    static NodeTypeInfo GetNodeTypeInfo(const std::string& nodeType);

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®è¡¨ç¤ºåã‚’å–å¾—
    /// </summary>
    /// <param name="nodeType">ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å</param>
    /// <returns>è¡¨ç¤ºç”¨ã®åå‰</returns>
    static std::string GetNodeDisplayName(const std::string& nodeType);

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®è‰²ã‚’å–å¾—ï¼ˆã‚¨ãƒ‡ã‚£ã‚¿è¡¨ç¤ºç”¨ï¼‰
    /// </summary>
    /// <param name="nodeType">ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å</param>
    /// <returns>ãƒŽãƒ¼ãƒ‰ã®è‰²ï¼ˆImVec4ï¼‰</returns>
    static ImVec4 GetNodeColor(const std::string& nodeType);

    /// <summary>
    /// ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã‹ã©ã†ã‹åˆ¤å®š
    /// </summary>
    /// <param name="nodeType">ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å</param>
    /// <returns>ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆï¼ˆå­ã‚’æŒã¦ã‚‹ï¼‰ãªã‚‰true</returns>
    static bool IsCompositeNode(const std::string& nodeType);

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—
    /// </summary>
    /// <param name="nodeType">ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å</param>
    /// <returns>ãƒŽãƒ¼ãƒ‰ã‚«ãƒ†ã‚´ãƒª</returns>
    static NodeCategory GetNodeCategory(const std::string& nodeType);

private:
    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æƒ…å ±ã®åˆæœŸåŒ–ï¼ˆé™çš„ï¼‰
    /// </summary>
    static void InitializeNodeTypes();

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—æƒ…å ±ã®ãƒžãƒƒãƒ—
    /// </summary>
    static std::vector<NodeTypeInfo> nodeTypes_;

    /// <summary>
    /// åˆæœŸåŒ–ãƒ•ãƒ©ã‚°
    /// </summary>
    static bool initialized_;
#endif // _DEBUG
};


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Conditions/BTActionSelector.cpp
============================================================
#include "BTActionSelector.h"

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTActionSelector::BTActionSelector(ActionType type)
    : expectedType_(type) {
    name_ = (type == ActionType::Dash) ? "ActionSelector(Dash)" : "ActionSelector(Shoot)";
}

BTNodeStatus BTActionSelector::Execute(BTBlackboard* blackboard) {
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å–å¾—
    int actionCounter = blackboard->GetInt("ActionCounter", 0);

    // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã®å¶å¥‡ã§åˆ¤å®š
    int currentType = actionCounter % 2;

    // æœŸå¾…ã™ã‚‹ã‚¿ã‚¤ãƒ—ã¨ä¸€è‡´ã™ã‚Œã°æˆåŠŸ
    if (currentType == static_cast<int>(expectedType_)) {
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    status_ = BTNodeStatus::Failure;
    return BTNodeStatus::Failure;
}

void BTActionSelector::Reset() {
    BTNode::Reset();
}

nlohmann::json BTActionSelector::ExtractParameters() const {
    return {{"actionType", static_cast<int>(expectedType_)}};
}

#ifdef _DEBUG
bool BTActionSelector::DrawImGui() {
    bool changed = false;

    int actionType = static_cast<int>(expectedType_);
    const char* items[] = { "Dash", "Shoot" };
    if (ImGui::Combo("Action Type##selector", &actionType, items, IM_ARRAYSIZE(items))) {
        expectedType_ = static_cast<ActionType>(actionType);
        changed = true;
    }

    return changed;
}
#endif

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Conditions/BTActionSelector.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"

/// <summary>
/// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é¸æŠžæ¡ä»¶ãƒŽãƒ¼ãƒ‰
/// ActionCounterã®å€¤ã«åŸºã¥ã„ã¦æˆåŠŸ/å¤±æ•—ã‚’è¿”ã™
/// </summary>
class BTActionSelector : public BTNode {
public:
    /// <summary>
    /// æœŸå¾…ã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class ActionType {
        Dash = 0,   // å¶æ•°ã®å ´åˆ
        Shoot = 1   // å¥‡æ•°ã®å ´åˆ
    };

    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    /// <param name="type">æœŸå¾…ã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—</param>
    explicit BTActionSelector(ActionType type);

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTActionSelector() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    /// <summary>
    /// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
    /// </summary>
    /// <returns>æœŸå¾…ã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—</returns>
    ActionType GetActionType() const { return expectedType_; }

    /// <summary>
    /// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’è¨­å®š
    /// </summary>
    /// <param name="type">æ–°ã—ã„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—</param>
    void SetActionType(ActionType type) { expectedType_ = type; }

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override {
        if (params.contains("actionType")) {
            expectedType_ = static_cast<ActionType>(params["actionType"].get<int>());
        }
    }

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

private:
    // æœŸå¾…ã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
    ActionType expectedType_;
};

============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Conditions/BTBossDistanceCondition.cpp
============================================================
#include "BTBossDistanceCondition.h"
#include "../../Boss.h"
#include "../../../Player/Player.h"
#include "Vector3.h"

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossDistanceCondition::BTBossDistanceCondition() {
    name_ = "DistanceCondition";
}

BTNodeStatus BTBossDistanceCondition::Execute(BTBlackboard* blackboard) {
    // ãƒœã‚¹ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—
    Boss* boss = blackboard->GetBoss();
    Player* player = blackboard->GetPlayer();

    if (!boss || !player) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    // ä½ç½®ã‚’å–å¾—
    Vector3 bossPos = boss->GetTransform().translate;
    Vector3 playerPos = player->GetTransform().translate;

    // æ°´å¹³è·é›¢ã‚’è¨ˆç®—ï¼ˆYè»¸ã‚’ç„¡è¦–ï¼‰
    Vector3 diff = playerPos - bossPos;
    diff.y = 0.0f;
    float distance = diff.Length();

    // ç¯„å›²å†…ãƒã‚§ãƒƒã‚¯: minDistance_ <= distance <= maxDistance_
    if (distance >= minDistance_ && distance <= maxDistance_) {
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    status_ = BTNodeStatus::Failure;
    return BTNodeStatus::Failure;
}

void BTBossDistanceCondition::Reset() {
    BTNode::Reset();
}

void BTBossDistanceCondition::ApplyParameters(const nlohmann::json& params) {
    if (params.contains("minDistance")) {
        minDistance_ = params["minDistance"].get<float>();
    }
    if (params.contains("maxDistance")) {
        maxDistance_ = params["maxDistance"].get<float>();
    }
}

nlohmann::json BTBossDistanceCondition::ExtractParameters() const {
    return {
        {"minDistance", minDistance_},
        {"maxDistance", maxDistance_}
    };
}

#ifdef _DEBUG
bool BTBossDistanceCondition::DrawImGui() {
    bool changed = false;

    // æœ€å°è·é›¢ã®ç·¨é›†
    if (ImGui::DragFloat("Min Distance##dist", &minDistance_, 0.5f, 0.0f, 100.0f, "%.1f")) {
        // minãŒmaxã‚’è¶…ãˆãªã„ã‚ˆã†ã«
        if (minDistance_ > maxDistance_) {
            minDistance_ = maxDistance_;
        }
        changed = true;
    }

    // æœ€å¤§è·é›¢ã®ç·¨é›†
    if (ImGui::DragFloat("Max Distance##dist", &maxDistance_, 0.5f, 0.0f, 100.0f, "%.1f")) {
        // maxãŒminã‚’ä¸‹å›žã‚‰ãªã„ã‚ˆã†ã«
        if (maxDistance_ < minDistance_) {
            maxDistance_ = minDistance_;
        }
        changed = true;
    }

    // è£œåŠ©ãƒ†ã‚­ã‚¹ãƒˆ
    ImGui::TextDisabled("Success if: %.1f <= distance <= %.1f", minDistance_, maxDistance_);

    return changed;
}
#endif


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Conditions/BTBossDistanceCondition.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"

/// <summary>
/// è·é›¢æ¡ä»¶ãƒŽãƒ¼ãƒ‰
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒæŒ‡å®šç¯„å›²å†…ã‹ã‚’åˆ¤å®šã—ã¦æˆåŠŸ/å¤±æ•—ã‚’è¿”ã™
/// </summary>
class BTBossDistanceCondition : public BTNode {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossDistanceCondition();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossDistanceCondition() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override;

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

    // Getters/Setters
    float GetMinDistance() const { return minDistance_; }
    void SetMinDistance(float dist) { minDistance_ = dist; }

    float GetMaxDistance() const { return maxDistance_; }
    void SetMaxDistance(float dist) { maxDistance_ = dist; }

private:
    // æœ€å°è·é›¢ï¼ˆã“ã‚Œä»¥ä¸Šé›¢ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰
    float minDistance_ = 0.0f;

    // æœ€å¤§è·é›¢ï¼ˆã“ã‚Œä»¥ä¸‹ã®è·é›¢ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰
    float maxDistance_ = 15.0f;
};


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Conditions/BTBossHPCondition.cpp
============================================================
#include "BTBossHPCondition.h"
#include "../../Boss.h"

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossHPCondition::BTBossHPCondition() {
    name_ = "HPCondition";
}

BTNodeStatus BTBossHPCondition::Execute(BTBlackboard* blackboard) {
    // ãƒœã‚¹ã‚’å–å¾—
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    // ç¾åœ¨ã®HPã‚’ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã«å¤‰æ›
    float currentHp = boss->GetHp();
    float currentPercent = (currentHp / Boss::GetMaxHp()) * 100.0f;

    if (EvaluateCondition(currentPercent)) {
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    status_ = BTNodeStatus::Failure;
    return BTNodeStatus::Failure;
}

void BTBossHPCondition::Reset() {
    BTNode::Reset();
}

bool BTBossHPCondition::EvaluateCondition(float currentPercent) const {
    switch (comparison_) {
    case Comparison::Less:
        return currentPercent < thresholdPercent_;
    case Comparison::LessOrEqual:
        return currentPercent <= thresholdPercent_;
    case Comparison::Greater:
        return currentPercent > thresholdPercent_;
    case Comparison::GreaterOrEqual:
        return currentPercent >= thresholdPercent_;
    default:
        return false;
    }
}

void BTBossHPCondition::ApplyParameters(const nlohmann::json& params) {
    if (params.contains("thresholdPercent")) {
        thresholdPercent_ = params["thresholdPercent"].get<float>();
    }
    if (params.contains("comparison")) {
        comparison_ = static_cast<Comparison>(params["comparison"].get<int>());
    }
}

nlohmann::json BTBossHPCondition::ExtractParameters() const {
    return {
        {"thresholdPercent", thresholdPercent_},
        {"comparison", static_cast<int>(comparison_)}
    };
}

#ifdef _DEBUG
bool BTBossHPCondition::DrawImGui() {
    bool changed = false;

    // HPé–¾å€¤ã®ç·¨é›†ï¼ˆãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ï¼‰
    if (ImGui::DragFloat("HP Threshold %##hp", &thresholdPercent_, 1.0f, 0.0f, 100.0f, "%.1f%%")) {
        changed = true;
    }

    // æ¯”è¼ƒã‚¿ã‚¤ãƒ—ã®é¸æŠž
    int comp = static_cast<int>(comparison_);
    const char* compItems[] = { "Less (<)", "Less Or Equal (<=)", "Greater (>)", "Greater Or Equal (>=)" };
    if (ImGui::Combo("Comparison##hp", &comp, compItems, IM_ARRAYSIZE(compItems))) {
        comparison_ = static_cast<Comparison>(comp);
        changed = true;
    }

    return changed;
}
#endif


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Conditions/BTBossHPCondition.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"

/// <summary>
/// HPæ¡ä»¶ãƒŽãƒ¼ãƒ‰
/// ç¾åœ¨ã®ãƒœã‚¹HPã‚’æœ€å¤§HPã«å¯¾ã™ã‚‹ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã§æ¯”è¼ƒã—ã¦æˆåŠŸ/å¤±æ•—ã‚’è¿”ã™
/// </summary>
class BTBossHPCondition : public BTNode {
public:
    /// <summary>
    /// æ¯”è¼ƒã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class Comparison {
        Less = 0,            // HPãŒé–¾å€¤æœªæº€
        LessOrEqual = 1,     // HPãŒé–¾å€¤ä»¥ä¸‹
        Greater = 2,         // HPãŒé–¾å€¤è¶…éŽ
        GreaterOrEqual = 3   // HPãŒé–¾å€¤ä»¥ä¸Š
    };

    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossHPCondition();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossHPCondition() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override;

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

    // Getters/Setters
    float GetThresholdPercent() const { return thresholdPercent_; }
    void SetThresholdPercent(float percent) { thresholdPercent_ = percent; }

    Comparison GetComparison() const { return comparison_; }
    void SetComparison(Comparison comp) { comparison_ = comp; }

private:
    /// <summary>
    /// æ¯”è¼ƒæ¡ä»¶ã‚’è©•ä¾¡
    /// </summary>
    /// <param name="currentPercent">ç¾åœ¨ã®HPãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸</param>
    /// <returns>æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚Œã°true</returns>
    bool EvaluateCondition(float currentPercent) const;

    // HPé–¾å€¤ï¼ˆãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸: 0ã€œ100ï¼‰
    float thresholdPercent_ = 50.0f;

    // æ¯”è¼ƒã‚¿ã‚¤ãƒ—
    Comparison comparison_ = Comparison::LessOrEqual;
};


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Conditions/BTBossPhaseCondition.cpp
============================================================
#include "BTBossPhaseCondition.h"
#include "../../Boss.h"

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

BTBossPhaseCondition::BTBossPhaseCondition() {
    name_ = "PhaseCondition";
}

BTNodeStatus BTBossPhaseCondition::Execute(BTBlackboard* blackboard) {
    // ãƒœã‚¹ã‚’å–å¾—
    Boss* boss = blackboard->GetBoss();
    if (!boss) {
        status_ = BTNodeStatus::Failure;
        return BTNodeStatus::Failure;
    }

    // ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚ºã‚’å–å¾—ã—ã¦æ¯”è¼ƒ
    uint32_t currentPhase = boss->GetPhase();

    if (EvaluateCondition(currentPhase)) {
        status_ = BTNodeStatus::Success;
        return BTNodeStatus::Success;
    }

    status_ = BTNodeStatus::Failure;
    return BTNodeStatus::Failure;
}

void BTBossPhaseCondition::Reset() {
    BTNode::Reset();
}

bool BTBossPhaseCondition::EvaluateCondition(uint32_t currentPhase) const {
    switch (comparison_) {
    case Comparison::Equal:
        return currentPhase == targetPhase_;
    case Comparison::NotEqual:
        return currentPhase != targetPhase_;
    case Comparison::GreaterOrEqual:
        return currentPhase >= targetPhase_;
    case Comparison::LessOrEqual:
        return currentPhase <= targetPhase_;
    default:
        return false;
    }
}

void BTBossPhaseCondition::ApplyParameters(const nlohmann::json& params) {
    if (params.contains("targetPhase")) {
        targetPhase_ = params["targetPhase"].get<uint32_t>();
    }
    if (params.contains("comparison")) {
        comparison_ = static_cast<Comparison>(params["comparison"].get<int>());
    }
}

nlohmann::json BTBossPhaseCondition::ExtractParameters() const {
    return {
        {"targetPhase", targetPhase_},
        {"comparison", static_cast<int>(comparison_)}
    };
}

#ifdef _DEBUG
bool BTBossPhaseCondition::DrawImGui() {
    bool changed = false;

    // ãƒ•ã‚§ãƒ¼ã‚ºå€¤ã®ç·¨é›†
    int phase = static_cast<int>(targetPhase_);
    if (ImGui::DragInt("Target Phase##phase", &phase, 1, 1, 2)) {
        targetPhase_ = static_cast<uint32_t>(phase);
        changed = true;
    }

    // æ¯”è¼ƒã‚¿ã‚¤ãƒ—ã®é¸æŠž
    int comp = static_cast<int>(comparison_);
    const char* compItems[] = { "Equal (==)", "Not Equal (!=)", "Greater Or Equal (>=)", "Less Or Equal (<=)" };
    if (ImGui::Combo("Comparison##phase", &comp, compItems, IM_ARRAYSIZE(compItems))) {
        comparison_ = static_cast<Comparison>(comp);
        changed = true;
    }

    return changed;
}
#endif


============================================================
File Path: GameProject/Object/Boss/BossBehaviorTree/Conditions/BTBossPhaseCondition.h
============================================================
#pragma once
#include "../../../../BehaviorTree/Core/BTNode.h"
#include "../../../../BehaviorTree/Core/BTBlackboard.h"

/// <summary>
/// ãƒ•ã‚§ãƒ¼ã‚ºæ¡ä»¶ãƒŽãƒ¼ãƒ‰
/// ç¾åœ¨ã®ãƒœã‚¹ãƒ•ã‚§ãƒ¼ã‚ºã‚’æŒ‡å®šã—ãŸå€¤ã¨æ¯”è¼ƒã—ã¦æˆåŠŸ/å¤±æ•—ã‚’è¿”ã™
/// </summary>
class BTBossPhaseCondition : public BTNode {
public:
    /// <summary>
    /// æ¯”è¼ƒã‚¿ã‚¤ãƒ—
    /// </summary>
    enum class Comparison {
        Equal = 0,           // ãƒ•ã‚§ãƒ¼ã‚ºãŒä¸€è‡´
        NotEqual = 1,        // ãƒ•ã‚§ãƒ¼ã‚ºãŒä¸ä¸€è‡´
        GreaterOrEqual = 2,  // ãƒ•ã‚§ãƒ¼ã‚ºãŒä»¥ä¸Š
        LessOrEqual = 3      // ãƒ•ã‚§ãƒ¼ã‚ºãŒä»¥ä¸‹
    };

    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BTBossPhaseCondition();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BTBossPhaseCondition() = default;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®å®Ÿè¡Œ
    /// </summary>
    /// <param name="blackboard">ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒ¼ãƒ‰</param>
    /// <returns>å®Ÿè¡Œçµæžœ</returns>
    BTNodeStatus Execute(BTBlackboard* blackboard) override;

    /// <summary>
    /// ãƒŽãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset() override;

    /// <summary>
    /// JSONã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    /// </summary>
    /// <param name="params">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿JSON</param>
    void ApplyParameters(const nlohmann::json& params) override;

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONã¨ã—ã¦æŠ½å‡º
    /// </summary>
    nlohmann::json ExtractParameters() const override;

#ifdef _DEBUG
    /// <summary>
    /// ImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†UIã‚’æç”»
    /// </summary>
    bool DrawImGui() override;
#endif

    // Getters/Setters
    uint32_t GetTargetPhase() const { return targetPhase_; }
    void SetTargetPhase(uint32_t phase) { targetPhase_ = phase; }

    Comparison GetComparison() const { return comparison_; }
    void SetComparison(Comparison comp) { comparison_ = comp; }

private:
    /// <summary>
    /// æ¯”è¼ƒæ¡ä»¶ã‚’è©•ä¾¡
    /// </summary>
    /// <param name="currentPhase">ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚º</param>
    /// <returns>æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚Œã°true</returns>
    bool EvaluateCondition(uint32_t currentPhase) const;

    // ç›®æ¨™ãƒ•ã‚§ãƒ¼ã‚º
    uint32_t targetPhase_ = 2;

    // æ¯”è¼ƒã‚¿ã‚¤ãƒ—
    Comparison comparison_ = Comparison::Equal;
};


============================================================
File Path: GameProject/Object/Boss/BossNodeEditor/BossNodeEditor.cpp
============================================================
#ifdef _DEBUG

#include "BossNodeEditor.h"
#include "../BossBehaviorTree/BossNodeFactory.h"
#include "../BossBehaviorTree/BossBehaviorTree.h"
#include "../../../BehaviorTree/Core/BTComposite.h"
#include "../../../BehaviorTree/Core/BTBlackboard.h"
#include "../BossBehaviorTree/Conditions/BTActionSelector.h"
#include "DebugUIManager.h"
#include <imgui_internal.h>
#include <algorithm>
#include <queue>
#include <set>
#include <unordered_map>
#include <json.hpp>
#include <fstream>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <filesystem>

/// <summary>
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
/// </summary>
BossNodeEditor::BossNodeEditor()
    : editorContext_(nullptr)
    , editorConfig_()
    , nextNodeId_(10000)    // BossNodeEditorå°‚ç”¨: 10000ç•ªå°
    , nextPinId_(20000)     // BossNodeEditorå°‚ç”¨: 20000ç•ªå°
    , nextLinkId_(30000)    // BossNodeEditorå°‚ç”¨: 30000ç•ªå°
    , isVisible_(false)
    , firstFrame_(true)
    , highlightedNodeId_(-1)
    , highlightStartTime_(0.0f) {
}

/// <summary>
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
/// </summary>
BossNodeEditor::~BossNodeEditor() {
    Finalize();
}

/// <summary>
/// ã‚¨ãƒ‡ã‚£ã‚¿ã®åˆæœŸåŒ–
/// </summary>
void BossNodeEditor::Initialize() {
    // ã‚¨ãƒ‡ã‚£ã‚¿ã‚³ãƒ³ãƒ•ã‚£ã‚°ã®ä½œæˆ
    editorConfig_ = std::make_unique<ed::Config>();
    editorConfig_->SettingsFile = "resources/Json/BossNodeEditor.json";
    editorConfig_->NavigateButtonIndex = 1;        // ãƒžã‚¦ã‚¹ä¸­ãƒœã‚¿ãƒ³ã§ãƒŠãƒ“ã‚²ãƒ¼ãƒˆ
    editorConfig_->ContextMenuButtonIndex = 2;     // ãƒžã‚¦ã‚¹å³ãƒœã‚¿ãƒ³ã§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼

    // ã‚¨ãƒ‡ã‚£ã‚¿ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä½œæˆ
    editorContext_ = ed::CreateEditor(editorConfig_.get());

    LoadFromJSON("resources/Json/BossTree.json");
}

/// <summary>
/// ã‚¨ãƒ‡ã‚£ã‚¿ã®çµ‚äº†å‡¦ç†
/// </summary>
void BossNodeEditor::Finalize() {
    if (editorContext_) {
        ed::DestroyEditor(editorContext_);
        editorContext_ = nullptr;
    }
    // editorConfig_ã¯unique_ptrã§è‡ªå‹•è§£æ”¾
    editorConfig_.reset();
    Clear();
}

/// <summary>
/// ã‚¨ãƒ‡ã‚£ã‚¿ã®æ›´æ–°ãƒ»æç”»ï¼ˆImGuiã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ã§å‘¼ã¶ï¼‰
/// </summary>
void BossNodeEditor::Update() {
    if (!isVisible_) return;

    // ImGuiã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®é–‹å§‹
    if (ImGui::Begin("Boss Behavior Tree Editor", &isVisible_)) {
        // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®æç”»
        DrawToolbar();

        ImGui::Separator();

        // ãƒŽãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿ã‚­ãƒ£ãƒ³ãƒã‚¹ã®é–‹å§‹
        ed::SetCurrentEditor(editorContext_);
        ed::Begin("Boss Node Editor Canvas");

        // ãƒŽãƒ¼ãƒ‰ã®æç”»
        DrawNodes();

        // ãƒªãƒ³ã‚¯ã®æç”»
        DrawLinks();

        // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
        HandleNodeCreation();
        HandleLinkCreation();
        HandleDeletion();

        // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
        // DrawContextMenu();

        // é¸æŠžãƒŽãƒ¼ãƒ‰ã®å–å¾—ï¼ˆed::End()å‰ã«å®Ÿè¡Œå¿…é ˆï¼‰
        {
            int selectedCount = ed::GetSelectedObjectCount();
            if (selectedCount > 0) {
                std::vector<ed::NodeId> selectedNodes(selectedCount);
                int nodeCount = ed::GetSelectedNodes(selectedNodes.data(), selectedCount);
                if (nodeCount > 0) {
                    selectedNodeId_ = static_cast<int>(selectedNodes[0].Get());
                } else {
                    selectedNodeId_ = -1;
                }
            } else {
                selectedNodeId_ = -1;
            }
        }

        ed::End();
        ed::SetCurrentEditor(nullptr);

        // ãƒŽãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼
        DrawNodeInspector();

        // åˆå›žãƒ•ãƒ¬ãƒ¼ãƒ ã®å‡¦ç†å®Œäº†
        if (firstFrame_) {
            firstFrame_ = false;
        }
    }
    ImGui::End();
}

/// <summary>
/// ã‚¨ãƒ‡ã‚£ã‚¿ã®ã‚¯ãƒªã‚¢
/// </summary>
void BossNodeEditor::Clear() {
    nodes_.clear();
    pins_.clear();
    links_.clear();
    runtimeNodeToEditorId_.clear();

    // IDç¯„å›²ã‚’åˆæœŸå€¤ã«æˆ»ã™ï¼ˆIDç«¶åˆã‚’é˜²ããŸã‚ç¯„å›²ã‚’åˆ†é›¢ï¼‰
    nextNodeId_ = 10000;    // BossNodeEditorå°‚ç”¨: 10000ç•ªå°
    nextPinId_ = 20000;     // BossNodeEditorå°‚ç”¨: 20000ç•ªå°
    nextLinkId_ = 30000;    // BossNodeEditorå°‚ç”¨: 30000ç•ªå°

    highlightedNodeId_ = -1;
    highlightStartTime_ = 0.0f;
    selectedNodeId_ = -1;
    firstFrame_ = true;
}

/// <summary>
/// ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®æç”»
/// </summary>
void BossNodeEditor::DrawToolbar() {
    // ãƒŽãƒ¼ãƒ‰ã®æ®µéšŽçš„ã‚ªãƒ•ã‚»ãƒƒãƒˆç”¨ã®é™çš„å¤‰æ•°
    static float nodeOffsetX = 100.0f;
    static float nodeOffsetY = 100.0f;

    // é¸æŠžã•ã‚ŒãŸãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’ä¿æŒã™ã‚‹é™çš„å¤‰æ•°
    static int selectedNodeTypeIndex = 0;
    static std::string selectedNodeType = "BTSelector"; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

    if (ImGui::Button("Save##bne_toolbar")) {
        SaveToJSON("resources/Json/BossTree.json");
    }
    ImGui::SameLine();

    if (ImGui::Button("Load##bne_toolbar")) {
        LoadFromJSON("resources/Json/BossTree.json");
    }
    ImGui::SameLine();

    if (ImGui::Button("Clear##bne_toolbar")) {
        Clear();
        nodeOffsetX = 100.0f;
        nodeOffsetY = 100.0f;
    }

    // ãƒŽãƒ¼ãƒ‰ä½œæˆç”¨ã®UIã‚»ã‚¯ã‚·ãƒ§ãƒ³
    ImGui::SameLine();
    ImGui::Separator();
    ImGui::SameLine();
    ImGui::Text("Node Type:");
    ImGui::SameLine();

    // å…¨ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’åŽé›†ã—ã¦çµ±ä¸€ã•ã‚ŒãŸãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‚’ä½œæˆ
    static std::vector<std::string> allNodeTypes;
    static std::vector<std::string> allDisplayNames;
    allNodeTypes.clear();
    allDisplayNames.clear();

    // CompositeãƒŽãƒ¼ãƒ‰
    auto compositeTypes = BossNodeFactory::GetNodeTypesByCategory(BossNodeFactory::NodeCategory::Composite);
    for (const auto& type : compositeTypes) {
        allNodeTypes.push_back(type);
        allDisplayNames.push_back("[Composite] " + BossNodeFactory::GetNodeDisplayName(type));
    }

    // ActionãƒŽãƒ¼ãƒ‰
    auto actionTypes = BossNodeFactory::GetNodeTypesByCategory(BossNodeFactory::NodeCategory::Action);
    for (const auto& type : actionTypes) {
        allNodeTypes.push_back(type);
        allDisplayNames.push_back("[Action] " + BossNodeFactory::GetNodeDisplayName(type));
    }

    // ConditionãƒŽãƒ¼ãƒ‰
    auto conditionTypes = BossNodeFactory::GetNodeTypesByCategory(BossNodeFactory::NodeCategory::Condition);
    for (const auto& type : conditionTypes) {
        allNodeTypes.push_back(type);
        allDisplayNames.push_back("[Condition] " + BossNodeFactory::GetNodeDisplayName(type));
    }

    // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒªã‚¹ãƒˆ
    if (!allNodeTypes.empty()) {
        // ç¯„å›²ãƒã‚§ãƒƒã‚¯: é™çš„å¤‰æ•°ãŒç¯„å›²å¤–ã®å ´åˆã¯ãƒªã‚»ãƒƒãƒˆ
        if (selectedNodeTypeIndex >= static_cast<int>(allDisplayNames.size())) {
            selectedNodeTypeIndex = 0;
        }

        // ç¾åœ¨é¸æŠžã•ã‚Œã¦ã„ã‚‹ãƒŽãƒ¼ãƒ‰ã®è¡¨ç¤ºå
        const char* previewValue = selectedNodeTypeIndex < static_cast<int>(allDisplayNames.size())
            ? allDisplayNames[selectedNodeTypeIndex].c_str()
            : "Select Node Type...";

        ImGui::SetNextItemWidth(200);
        if (ImGui::BeginCombo("##NodeTypeCombo", previewValue)) {
            for (int i = 0; i < static_cast<int>(allDisplayNames.size()); i++) {
                bool isSelected = (selectedNodeTypeIndex == i);
                if (ImGui::Selectable(allDisplayNames[i].c_str(), isSelected)) {
                    selectedNodeTypeIndex = i;
                    selectedNodeType = allNodeTypes[i];
                }
                if (isSelected) {
                    ImGui::SetItemDefaultFocus();
                }
            }
            ImGui::EndCombo();
        }

        ImGui::SameLine();

        // Add Nodeãƒœã‚¿ãƒ³
        if (ImGui::Button("Add Node##bne_toolbar")) {
            ImVec2 centerPos = ImVec2(nodeOffsetX, nodeOffsetY);
            nodeOffsetX += 30.0f;
            nodeOffsetY += 20.0f;
            // ç”»é¢å¤–ã«è¡Œã‹ãªã„ã‚ˆã†ã«ãƒªã‚»ãƒƒãƒˆ
            if (nodeOffsetX > 800.0f) nodeOffsetX = 100.0f;
            if (nodeOffsetY > 600.0f) nodeOffsetY = 100.0f;
            CreateNode(selectedNodeType, centerPos);
        }
    }
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã®æç”»
/// </summary>
void BossNodeEditor::DrawNodes() {
    for (const auto& node : nodes_) {
        DrawNode(node);
    }
}

/// <summary>
/// å€‹åˆ¥ãƒŽãƒ¼ãƒ‰ã®æç”»
/// </summary>
void BossNodeEditor::DrawNode(const EditorNode& node) {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ«æ•°ã‚’è¿½è·¡
    int pushedColors = 2;  // NodeBg, NodeBorder
    int pushedVars = 2;    // NodeRounding, NodeBorderWidth

    // ãƒŽãƒ¼ãƒ‰ã®åŸºæœ¬è‰²ã‚’è¨­å®šï¼ˆå°‘ã—æš—ã‚ã«ï¼‰
    ImVec4 nodeColor = ImVec4(
        node.color.x * 0.7f,
        node.color.y * 0.7f,
        node.color.z * 0.7f,
        1.0f
    );

    // å®Ÿè¡Œä¸­ãƒŽãƒ¼ãƒ‰ã®ãƒ‘ãƒ«ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨ˆç®—
    bool isHighlighted = (node.id == highlightedNodeId_);

    float pulseIntensity = 0.0f;
    float borderWidth = 1.5f;
    ImVec4 borderColor = ImVec4(0.31f, 0.31f, 0.31f, 1.0f); // ImColor(80, 80, 80)

    if (isHighlighted) {
        // å®Ÿè¡Œä¸­ãƒŽãƒ¼ãƒ‰: ãƒ‘ãƒ«ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        float elapsed = static_cast<float>(ImGui::GetTime()) - highlightStartTime_;
        pulseIntensity = (sinf(elapsed * 6.0f) + 1.0f) * 0.5f; // 0.0ï½ž1.0ã§æŒ¯å‹•

        // ãƒœãƒ¼ãƒ€ãƒ¼è‰²ã‚’æ™‚é–“çµŒéŽã§å¤‰åŒ–ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ï½žé»„è‰²ï¼‰
        borderColor = ImVec4(
            1.0f,
            0.6f + pulseIntensity * 0.3f,
            0.2f + pulseIntensity * 0.3f,
            1.0f
        );
        borderWidth = 2.5f + pulseIntensity * 1.5f; // 2.5ï½ž4.0ã§å¤‰åŒ–

        // ãƒŽãƒ¼ãƒ‰èƒŒæ™¯è‰²ã‚‚å°‘ã—æ˜Žã‚‹ã
        nodeColor = ImVec4(
            node.color.x * 0.7f + pulseIntensity * 0.1f,
            node.color.y * 0.7f + pulseIntensity * 0.1f,
            node.color.z * 0.7f + pulseIntensity * 0.1f,
            1.0f
        );
    }

    // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
    ed::PushStyleColor(ed::StyleColor_NodeBg, ImColor(nodeColor));
    ed::PushStyleColor(ed::StyleColor_NodeBorder, ImColor(borderColor));
    ed::PushStyleVar(ed::StyleVar_NodeRounding, 5.0f);
    ed::PushStyleVar(ed::StyleVar_NodeBorderWidth, borderWidth);

    ed::BeginNode(node.id);

    ImGui::PushID(node.id);

    // ãƒŽãƒ¼ãƒ‰å…¨ä½“ã®å¹…ã‚’çµ±ä¸€
    const float nodeWidth = 200.0f;
    const float barHeight = 24.0f;

    // ========== å…¥åŠ›ãƒ”ãƒ³ãƒãƒ¼ï¼ˆä¸Šéƒ¨ï¼‰ ==========
    if (!node.inputPinIds.empty()) {
        // ãƒãƒ¼èƒŒæ™¯ã‚’æ‰‹å‹•æç”»
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 barMin = ImGui::GetCursorScreenPos();
        ImVec2 barMax = ImVec2(barMin.x + nodeWidth, barMin.y + barHeight);
        drawList->AddRectFilled(barMin, barMax, IM_COL32(30, 30, 30, 255), 3.0f);

        // ãƒ”ãƒ³é ˜åŸŸã‚’ç¢ºä¿
        ImGui::Dummy(ImVec2(nodeWidth, barHeight));

        // å…¥åŠ›ãƒ”ãƒ³ã‚’é…ç½®
        ImVec2 savedPos = ImGui::GetCursorPos();
        ImGui::SetCursorPos(ImVec2(savedPos.x, savedPos.y - barHeight + 4));

        for (int pinId : node.inputPinIds) {
            const EditorPin* pin = FindPinById(pinId);
            if (pin) {
                // ä¸­å¤®ã«é…ç½®ï¼ˆDummy + SameLineæ–¹å¼ï¼‰
                float textWidth = ImGui::CalcTextSize("Input").x;
                ImGui::Dummy(ImVec2((nodeWidth - textWidth) * 0.5f, 0));
                ImGui::SameLine(0, 0);
                DrawPin(*pin);
            }
        }

        ImGui::SetCursorPos(savedPos);
    }

    // ========== ãƒŽãƒ¼ãƒ‰æœ¬ä½“ï¼ˆä¸­å¤®ï¼‰ ==========
    ImGui::Spacing();

    // ãƒŽãƒ¼ãƒ‰åã‚’è¡¨ç¤ºï¼ˆä¸­å¤®æƒãˆï¼‰
    const char* titleText = node.displayName.c_str();
    float titleWidth = ImGui::CalcTextSize(titleText).x;
    ImGui::Dummy(ImVec2((nodeWidth - titleWidth) * 0.5f, 0));
    ImGui::SameLine(0, 0);
    ImGui::Text("%s", titleText);

    // ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’å°ã•ãè¡¨ç¤ºï¼ˆä¸­å¤®æƒãˆï¼‰
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 0.5f, 0.5f, 1.0f));
    ImGui::SetWindowFontScale(0.85f);
    float typeWidth = ImGui::CalcTextSize(node.nodeType.c_str()).x * 0.85f;
    ImGui::Dummy(ImVec2((nodeWidth - typeWidth) * 0.5f, 0));
    ImGui::SameLine(0, 0);
    ImGui::Text("%s", node.nodeType.c_str());
    ImGui::SetWindowFontScale(1.0f);
    ImGui::PopStyleColor();

    ImGui::Spacing();

    // ========== å‡ºåŠ›ãƒ”ãƒ³ãƒãƒ¼ï¼ˆä¸‹éƒ¨ï¼‰ ==========
    if (!node.outputPinIds.empty()) {
        // ãƒãƒ¼èƒŒæ™¯ã‚’æ‰‹å‹•æç”»
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 barMin = ImGui::GetCursorScreenPos();
        ImVec2 barMax = ImVec2(barMin.x + nodeWidth, barMin.y + barHeight);
        drawList->AddRectFilled(barMin, barMax, IM_COL32(30, 30, 30, 255), 3.0f);

        // ãƒ”ãƒ³é ˜åŸŸã‚’ç¢ºä¿
        ImGui::Dummy(ImVec2(nodeWidth, barHeight));

        // å‡ºåŠ›ãƒ”ãƒ³ã‚’é…ç½®
        ImVec2 savedPos = ImGui::GetCursorPos();
        ImGui::SetCursorPos(ImVec2(savedPos.x, savedPos.y - barHeight + 4));

        int pinCount = static_cast<int>(node.outputPinIds.size());

        if (pinCount == 1 && !node.outputPinIds.empty()) {
            // å˜ä¸€ãƒ”ãƒ³ã¯ä¸­å¤®é…ç½®ï¼ˆç¯„å›²ãƒã‚§ãƒƒã‚¯è¿½åŠ ï¼‰
            const EditorPin* pin = FindPinById(node.outputPinIds[0]);
            if (pin) {
                float textWidth = ImGui::CalcTextSize("Output").x;
                ImGui::Dummy(ImVec2((nodeWidth - textWidth) * 0.5f, 0));
                ImGui::SameLine(0, 0);
                DrawPin(*pin);
            }
        }
        else if (pinCount > 1 && node.outputPinIds.size() >= static_cast<size_t>(pinCount)) {
            // è¤‡æ•°ãƒ”ãƒ³ã¯æ¨ªä¸¦ã³ï¼ˆç¯„å›²ãƒã‚§ãƒƒã‚¯è¿½åŠ ï¼‰
            float spacing = nodeWidth / (pinCount + 1);

            for (int i = 0; i < pinCount && i < static_cast<int>(node.outputPinIds.size()); i++) {
                const EditorPin* pin = FindPinById(node.outputPinIds[i]);
                if (pin) {
                    float offset = spacing * (i + 1) - 20; // ãƒ”ãƒ³å¹…ã‚’è€ƒæ…®
                    ImGui::Dummy(ImVec2(offset, 0));
                    ImGui::SameLine(0, 0);
                    DrawPin(*pin);
                    if (i < pinCount - 1) {
                        ImGui::SameLine();
                    }
                }
            }
        }

        ImGui::SetCursorPos(savedPos);
    }

    ImGui::PopID();

    ed::EndNode();

    // Push/Popã®å¯¾å¿œã‚’æ­£ã—ãä¿ã¤ï¼ˆå¸¸ã«2è‰²ã€2å¤‰æ•°ï¼‰
    ed::PopStyleVar(2);
    ed::PopStyleColor(2);

    // åˆå›žãƒ•ãƒ¬ãƒ¼ãƒ ã®ã¿ãƒŽãƒ¼ãƒ‰ä½ç½®ã‚’è¨­å®šï¼ˆCreateNodeæ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ç”¨ï¼‰
    // LoadFromJSONæ™‚ã¯LoadFromJSONå†…ã§è¨­å®šã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯è¨­å®šã—ãªã„
    if (firstFrame_ && nodes_.size() <= 1 && (node.position.x != 0 || node.position.y != 0)) {
        ed::SetNodePosition(node.id, node.position);
    }
}

/// <summary>
/// ãƒ”ãƒ³ã®æç”»ï¼ˆæ”¹å–„ç‰ˆï¼‰
/// </summary>
void BossNodeEditor::DrawPin(const EditorPin& pin) {
    // ãƒ”ãƒ³ã®ã‚«ãƒ©ãƒ¼è¨­å®š
    ImColor pinColor = pin.isInput ? ImColor(150, 150, 200) : ImColor(150, 200, 150);
    ImColor borderColor = ImColor(200, 200, 200, 200);

    // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãƒ—ãƒƒã‚·ãƒ¥
    ed::PushStyleColor(ed::StyleColor_PinRect, pinColor);
    ed::PushStyleColor(ed::StyleColor_PinRectBorder, borderColor);

    ed::BeginPin(pin.id, pin.isInput ? ed::PinKind::Input : ed::PinKind::Output);

    ImGui::PushID(pin.id);

    // ãƒ”ãƒ³ã®çŸ©å½¢é ˜åŸŸé–‹å§‹ä½ç½®ã‚’è¨˜éŒ²
    ImVec2 pinRectMin = ImGui::GetCursorScreenPos();

    // ãƒ”ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º
    ImGui::Text("    ");


    // ãƒ”ãƒ³ã®çŸ©å½¢é ˜åŸŸçµ‚äº†ä½ç½®ã‚’è¨˜éŒ²
    ImVec2 pinRectMax = ImVec2(
        ImGui::GetItemRectMax().x,
        ImGui::GetItemRectMax().y
    );

    // ãƒ”ãƒ³ã®çŸ©å½¢é ˜åŸŸã‚’å®šç¾©ï¼ˆã‚¯ãƒªãƒƒã‚¯åˆ¤å®šç”¨ï¼‰
    ed::PinRect(pinRectMin, pinRectMax);

    // ãƒ”ãƒ³ã‚¢ã‚¤ã‚³ãƒ³ã®é…ç½®ä½ç½®ã‚’è¨­å®š
    // å…¥åŠ›ãƒ”ãƒ³ã¯å·¦å´ï¼ˆ0.0fï¼‰ã€å‡ºåŠ›ãƒ”ãƒ³ã¯å³å´ï¼ˆ1.0fï¼‰ã«é…ç½®
    ImVec2 alignment = pin.isInput ? ImVec2(0.5f, 0.0f) : ImVec2(0.5f, 1.0f);
    ed::PinPivotAlignment(alignment);
    ed::PinPivotSize(ImVec2(0, 0)); // è‡ªå‹•ã‚µã‚¤ã‚º

    ImGui::PopID();

    ed::EndPin();

    // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãƒãƒƒãƒ—
    ed::PopStyleColor(2);
}

/// <summary>
/// ãƒªãƒ³ã‚¯ã®æç”»
/// </summary>
void BossNodeEditor::DrawLinks() {
    for (const auto& link : links_) {
        ed::Link(link.id, link.startPinId, link.endPinId, ImColor(200, 200, 200), 2.0f);
    }
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ä½œæˆå‡¦ç†
/// </summary>
void BossNodeEditor::HandleNodeCreation() {
    // HandleLinkCreationå†…ã®BeginCreateã¨ç«¶åˆã—ãªã„ã‚ˆã†ã«ã€
    // ã“ã®é–¢æ•°ã¯ç¾åœ¨ç©ºå®Ÿè£…ã®ã¾ã¾ã¨ã™ã‚‹ã€‚
    // ãƒŽãƒ¼ãƒ‰ä½œæˆã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰è¡Œã†ã€‚
}

/// <summary>
/// ãƒªãƒ³ã‚¯ä½œæˆå‡¦ç†ï¼ˆä»®å®Ÿè£…ï¼‰
/// </summary>
void BossNodeEditor::HandleLinkCreation() {
    if (ed::BeginCreate()) {
        ed::PinId inputPinId, outputPinId;

        if (ed::QueryNewLink(&inputPinId, &outputPinId)) {
            // ãƒ”ãƒ³ã®æ¤œè¨¼
            EditorPin* inputPin = FindPinById(static_cast<int>(inputPinId.Get()));
            EditorPin* outputPin = FindPinById(static_cast<int>(outputPinId.Get()));

            if (inputPin && outputPin) {
                // å…¥åŠ›ã¨å‡ºåŠ›ãŒé€†ã®å ´åˆã¯å…¥ã‚Œæ›¿ãˆã‚‹
                if (inputPin->isInput == false && outputPin->isInput == true) {
                    std::swap(inputPin, outputPin);
                    std::swap(inputPinId, outputPinId);
                }

                // ãƒªãƒ³ã‚¯ä½œæˆã®æ¤œè¨¼
                bool canCreateLink = inputPin->isInput != outputPin->isInput;

                // å¾ªç’°å‚ç…§ãƒã‚§ãƒƒã‚¯
                if (canCreateLink) {
                    canCreateLink = !HasCyclicDependency(outputPin->nodeId, inputPin->nodeId);
                }

                if (canCreateLink && ed::AcceptNewItem()) {
                    // ãƒªãƒ³ã‚¯ä½œæˆ
                    EditorLink newLink;
                    newLink.id = nextLinkId_++;
                    newLink.startPinId = static_cast<int>(outputPinId.Get());
                    newLink.endPinId = static_cast<int>(inputPinId.Get());
                    newLink.startNodeId = outputPin->nodeId;
                    newLink.endNodeId = inputPin->nodeId;

                    links_.push_back(newLink);
                }
                else if (!canCreateLink) {
                    // ãƒªãƒ³ã‚¯ä½œæˆã‚’æ‹’å¦ï¼ˆèµ¤è‰²ã§è¡¨ç¤ºï¼‰
                    ed::RejectNewItem(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), 2.0f);
                }
            }
        }
    }
    ed::EndCreate();
}

/// <summary>
/// å‰Šé™¤å‡¦ç†ï¼ˆä»®å®Ÿè£…ï¼‰
/// </summary>
void BossNodeEditor::HandleDeletion() {
    if (ed::BeginDelete()) {
        // ãƒªãƒ³ã‚¯ã®å‰Šé™¤
        ed::LinkId deletedLinkId;
        while (ed::QueryDeletedLink(&deletedLinkId)) {
            if (ed::AcceptDeletedItem()) {
                links_.erase(
                    std::remove_if(links_.begin(), links_.end(),
                        [deletedLinkId](const EditorLink& link) {
                            return link.id == static_cast<int>(deletedLinkId.Get());
                        }),
                    links_.end()
                );
            }
        }

        // ãƒŽãƒ¼ãƒ‰ã®å‰Šé™¤
        ed::NodeId deletedNodeId;
        while (ed::QueryDeletedNode(&deletedNodeId)) {
            if (ed::AcceptDeletedItem()) {
                int nodeId = static_cast<int>(deletedNodeId.Get());

                // ãƒŽãƒ¼ãƒ‰ã«é–¢é€£ã™ã‚‹ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤
                links_.erase(
                    std::remove_if(links_.begin(), links_.end(),
                        [nodeId](const EditorLink& link) {
                            return link.startNodeId == nodeId || link.endNodeId == nodeId;
                        }),
                    links_.end()
                );

                // ãƒŽãƒ¼ãƒ‰ã®ãƒ”ãƒ³ã‚’å‰Šé™¤
                EditorNode* node = FindNodeById(nodeId);
                if (node) {
                    for (int pinId : node->inputPinIds) {
                        pins_.erase(
                            std::remove_if(pins_.begin(), pins_.end(),
                                [pinId](const EditorPin& pin) {
                                    return pin.id == pinId;
                                }),
                            pins_.end()
                        );
                    }
                    for (int pinId : node->outputPinIds) {
                        pins_.erase(
                            std::remove_if(pins_.begin(), pins_.end(),
                                [pinId](const EditorPin& pin) {
                                    return pin.id == pinId;
                                }),
                            pins_.end()
                        );
                    }
                }

                // ãƒŽãƒ¼ãƒ‰è‡ªä½“ã‚’å‰Šé™¤
                nodes_.erase(
                    std::remove_if(nodes_.begin(), nodes_.end(),
                        [nodeId](const EditorNode& node) {
                            return node.id == nodeId;
                        }),
                    nodes_.end()
                );
            }
        }
    }
    ed::EndDelete();
}

/// <summary>
/// ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®æç”»
/// </summary>
void BossNodeEditor::DrawContextMenu() {
    // ã‚¨ãƒ‡ã‚£ã‚¿ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸€æ™‚åœæ­¢ï¼ˆImGuiãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ãŸã‚ï¼‰
    ed::Suspend();

    // èƒŒæ™¯å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼
    if (ed::ShowBackgroundContextMenu()) {
        ImGui::OpenPopup("CreateNodeMenu");
    }

    // ãƒŽãƒ¼ãƒ‰å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼
    ed::NodeId contextNodeId;
    if (ed::ShowNodeContextMenu(&contextNodeId)) {
        ImGui::OpenPopup("NodeContextMenu");
        ImGui::SetNextWindowSize(ImVec2(200, 0));
    }

    // ãƒŽãƒ¼ãƒ‰ä½œæˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
    if (ImGui::BeginPopup("CreateNodeMenu")) {
        ImVec2 mousePos = ImGui::GetMousePos();
        ImVec2 canvasPos = ed::ScreenToCanvas(mousePos);

        ImGui::Text("Create Node");
        ImGui::Separator();

        // ã‚«ãƒ†ã‚´ãƒªã”ã¨ã«ãƒŽãƒ¼ãƒ‰ã‚’è¡¨ç¤º
        // CompositeãƒŽãƒ¼ãƒ‰
        if (ImGui::BeginMenu("Composite Nodes")) {
            auto compositeTypes = BossNodeFactory::GetNodeTypesByCategory(BossNodeFactory::NodeCategory::Composite);
            for (const auto& nodeType : compositeTypes) {
                std::string displayName = BossNodeFactory::GetNodeDisplayName(nodeType);
                if (ImGui::MenuItem(displayName.c_str())) {
                    CreateNode(nodeType, canvasPos);
                }
            }
            ImGui::EndMenu();
        }

        // ActionãƒŽãƒ¼ãƒ‰
        if (ImGui::BeginMenu("Action Nodes")) {
            auto actionTypes = BossNodeFactory::GetNodeTypesByCategory(BossNodeFactory::NodeCategory::Action);
            for (const auto& nodeType : actionTypes) {
                std::string displayName = BossNodeFactory::GetNodeDisplayName(nodeType);
                if (ImGui::MenuItem(displayName.c_str())) {
                    CreateNode(nodeType, canvasPos);
                }
            }
            ImGui::EndMenu();
        }

        // ConditionãƒŽãƒ¼ãƒ‰
        if (ImGui::BeginMenu("Condition Nodes")) {
            auto conditionTypes = BossNodeFactory::GetNodeTypesByCategory(BossNodeFactory::NodeCategory::Condition);
            for (const auto& nodeType : conditionTypes) {
                std::string displayName = BossNodeFactory::GetNodeDisplayName(nodeType);
                if (ImGui::MenuItem(displayName.c_str())) {
                    CreateNode(nodeType, canvasPos);
                }
            }
            ImGui::EndMenu();
        }

        ImGui::EndPopup();
    }

    // ãƒŽãƒ¼ãƒ‰å€‹åˆ¥ãƒ¡ãƒ‹ãƒ¥ãƒ¼
    if (ImGui::BeginPopup("NodeContextMenu")) {
        if (ImGui::MenuItem("Delete")) {
            // å‰Šé™¤ã¯æ—¢ã«HandleDeletion()ã§å‡¦ç†ã•ã‚Œã‚‹ã®ã§ã€ã“ã“ã§ã¯ä½•ã‚‚ã—ãªã„
            // ã¾ãŸã¯ã€å‰Šé™¤ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹å‡¦ç†ã‚’è¿½åŠ 
        }
        ImGui::EndPopup();
    }

    // ã‚¨ãƒ‡ã‚£ã‚¿ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å†é–‹
    ed::Resume();
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ã®æç”»
/// </summary>
void BossNodeEditor::DrawNodeInspector() {
    // ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ãƒ‘ãƒãƒ«ï¼ˆåˆ¥ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã¨ã—ã¦è¡¨ç¤ºï¼‰
    if (!ImGui::Begin("Node Inspector##BNE")) {
        ImGui::End();
        return;
    }

    ImGui::Text("Inspector");
    ImGui::Separator();

    if (selectedNodeId_ < 0) {
        ImGui::TextDisabled("No node selected");
        ImGui::End();
        return;
    }

    EditorNode* node = FindNodeById(selectedNodeId_);
    if (!node) {
        ImGui::TextDisabled("Invalid selection");
        ImGui::End();
        return;
    }

    // åŸºæœ¬æƒ…å ±
    ImGui::Text("ID: %d", node->id);
    ImGui::Text("Type: %s", node->nodeType.c_str());

    // è¡¨ç¤ºåç·¨é›†
    char nameBuf[256];
    strncpy_s(nameBuf, node->displayName.c_str(), sizeof(nameBuf) - 1);
    if (ImGui::InputText("Name##inspector", nameBuf, sizeof(nameBuf))) {
        node->displayName = nameBuf;
    }

    ImGui::Separator();
    ImGui::Text("Parameters");

    // ãƒŽãƒ¼ãƒ‰è‡ªèº«ã®DrawImGuiã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†
    if (node->runtimeNode) {
        if (!node->runtimeNode->DrawImGui()) {
            ImGui::TextDisabled("No editable parameters");
        }
    } else {
        ImGui::TextDisabled("No runtime node");
    }

    ImGui::End();
}

/// <summary>
/// JSONã‹ã‚‰èª­ã¿è¾¼ã¿
/// </summary>
bool BossNodeEditor::LoadFromJSON(const std::string& filepath) {
    try {
        std::ifstream file(filepath);
        if (!file.is_open()) {
            DebugUIManager::GetInstance()->AddLog(
                "[BossNodeEditor] Failed to open file for reading: " + filepath,
                DebugUIManager::LogType::Error);
            return false;
        }

        nlohmann::json json;
        file >> json;
        file.close();

        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
        if (!json.contains("version") || json["version"] != "1.0") {
            DebugUIManager::GetInstance()->AddLog(
                "[BossNodeEditor] Unsupported file version",
                DebugUIManager::LogType::Error);
            return false;
        }

        // æ—¢å­˜ã®ã‚¨ãƒ‡ã‚£ã‚¿ã‚’ã‚¯ãƒªã‚¢
        Clear();

        // IDãƒžãƒƒãƒ”ãƒ³ã‚°ï¼ˆå¤ã„ID â†’ æ–°ã—ã„IDï¼‰
        std::unordered_map<int, int> oldToNewNodeIdMap;
        std::unordered_map<int, int> oldToNewPinIdMap;

        // ãƒŽãƒ¼ãƒ‰ã‚’å¾©å…ƒ
        if (json.contains("nodes")) {
            for (const auto& nodeJson : json["nodes"]) {
                int oldId = nodeJson["id"];
                std::string nodeType = nodeJson["type"];
                std::string displayName = nodeJson.value("displayName", nodeType);
                ImVec2 position(
                    nodeJson["position"]["x"],
                    nodeJson["position"]["y"]
                );

                // ãƒŽãƒ¼ãƒ‰ã‚’ä½œæˆï¼ˆIDã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ï¼‰
                int newId = CreateNodeWithId(nextNodeId_++, nodeType, position);
                if (newId != -1) {
                    oldToNewNodeIdMap[oldId] = newId;

                    // è¡¨ç¤ºåã‚’è¨­å®š
                    auto* node = FindNodeById(newId);
                    if (node) {
                        node->displayName = displayName;

                        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
                        if (nodeJson.contains("parameters")) {
                            ApplyNodeParameters(*node, nodeJson["parameters"]);
                        }

                        // ãƒ”ãƒ³IDã®ãƒžãƒƒãƒ”ãƒ³ã‚°ã‚‚ä½œæˆ
                        // å…¥åŠ›ãƒ”ãƒ³
                        for (size_t i = 0; i < node->inputPinIds.size(); ++i) {
                            // å…ƒã®ãƒ”ãƒ³IDã¯ä¿å­˜ã•ã‚Œã¦ã„ãªã„ã®ã§ã€é †åºã§å¯¾å¿œä»˜ã‘
                            // TODO: ã‚ˆã‚Šæ­£ç¢ºãªãƒ”ãƒ³IDç®¡ç†ãŒå¿…è¦ãªå ´åˆã¯ã€JSONã«ãƒ”ãƒ³æƒ…å ±ã‚‚ä¿å­˜
                        }
                    }
                }
            }
        }

        // ãƒªãƒ³ã‚¯ã‚’å¾©å…ƒ
        if (json.contains("links")) {
            for (const auto& linkJson : json["links"]) {
                int oldSourceNodeId = linkJson["sourceNodeId"];
                int oldTargetNodeId = linkJson["targetNodeId"];

                // æ–°ã—ã„ãƒŽãƒ¼ãƒ‰IDã«å¤‰æ›
                auto sourceIt = oldToNewNodeIdMap.find(oldSourceNodeId);
                auto targetIt = oldToNewNodeIdMap.find(oldTargetNodeId);

                if (sourceIt != oldToNewNodeIdMap.end() &&
                    targetIt != oldToNewNodeIdMap.end()) {

                    int newSourceNodeId = sourceIt->second;
                    int newTargetNodeId = targetIt->second;

                    auto* sourceNode = FindNodeById(newSourceNodeId);
                    auto* targetNode = FindNodeById(newTargetNodeId);

                    if (sourceNode && targetNode &&
                        !sourceNode->outputPinIds.empty() &&
                        !targetNode->inputPinIds.empty()) {

                        // ãƒªãƒ³ã‚¯ã‚’ä½œæˆï¼ˆæœ€åˆã®å‡ºåŠ›ãƒ”ãƒ³ã¨æœ€åˆã®å…¥åŠ›ãƒ”ãƒ³ã‚’æŽ¥ç¶šï¼‰
                        EditorLink link;
                        link.id = nextLinkId_++;
                        link.startPinId = sourceNode->outputPinIds[0];
                        link.endPinId = targetNode->inputPinIds[0];
                        link.startNodeId = newSourceNodeId;
                        link.endNodeId = newTargetNodeId;

                        links_.push_back(link);
                    }
                }
            }
        }

        DebugUIManager::GetInstance()->AddLog(
            "[BossNodeEditor] Successfully loaded from: " + filepath,
            DebugUIManager::LogType::Info);
        DebugUIManager::GetInstance()->AddLog(
            "[BossNodeEditor] Loaded " + std::to_string(nodes_.size()) + " nodes and " + std::to_string(links_.size()) + " links",
            DebugUIManager::LogType::Info);
        return true;
    }
    catch (const std::exception& e) {
        DebugUIManager::GetInstance()->AddLog(
            "[BossNodeEditor] Failed to load JSON: " + std::string(e.what()),
            DebugUIManager::LogType::Error);
        return false;
    }
}

/// <summary>
/// JSONã«ä¿å­˜
/// </summary>
bool BossNodeEditor::SaveToJSON(const std::string& filepath) {
    try {
        nlohmann::json json;

        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±
        json["version"] = "1.0";

        // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;

        // Windowsç’°å¢ƒç”¨ã®localtime_sä½¿ç”¨
        struct tm timeinfo;
#ifdef _WIN32
        localtime_s(&timeinfo, &time_t);
#else
        localtime_r(&time_t, &timeinfo);
#endif
        ss << std::put_time(&timeinfo, "%Y-%m-%dT%H:%M:%S");

        json["metadata"]["name"] = "Boss Behavior Tree";
        json["metadata"]["created"] = ss.str();
        json["metadata"]["modified"] = ss.str();

        // ãƒŽãƒ¼ãƒ‰æƒ…å ±ã‚’ä¿å­˜
        json["nodes"] = nlohmann::json::array();
        for (const auto& node : nodes_) {
            nlohmann::json nodeJson;
            nodeJson["id"] = node.id;
            nodeJson["type"] = node.nodeType;
            nodeJson["displayName"] = node.displayName;
            nodeJson["position"]["x"] = node.position.x;
            nodeJson["position"]["y"] = node.position.y;

            // ãƒŽãƒ¼ãƒ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ä¿å­˜
            nodeJson["parameters"] = ExtractNodeParameters(node);

            json["nodes"].push_back(nodeJson);
        }

        // ãƒªãƒ³ã‚¯æƒ…å ±ã‚’ä¿å­˜
        json["links"] = nlohmann::json::array();
        for (const auto& link : links_) {
            nlohmann::json linkJson;
            linkJson["id"] = link.id;
            linkJson["sourceNodeId"] = link.startNodeId;
            linkJson["targetNodeId"] = link.endNodeId;
            linkJson["sourcePinId"] = link.startPinId;
            linkJson["targetPinId"] = link.endPinId;
            json["links"].push_back(linkJson);
        }

        // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
        std::filesystem::path filePath(filepath);
        std::filesystem::create_directories(filePath.parent_path());

        // ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã—
        std::ofstream file(filepath);
        if (!file.is_open()) {
            DebugUIManager::GetInstance()->AddLog(
                "[BossNodeEditor] Failed to open file for writing: " + filepath,
                DebugUIManager::LogType::Error);
            return false;
        }

        file << json.dump(2); // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ2ã§æ•´å½¢
        file.close();

        DebugUIManager::GetInstance()->AddLog(
            "[BossNodeEditor] Successfully saved to: " + filepath,
            DebugUIManager::LogType::Info);
        return true;
    }
    catch (const std::exception& e) {
        // ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°
        DebugUIManager::GetInstance()->AddLog(
            "[BossNodeEditor] Failed to save JSON: " + std::string(e.what()),
            DebugUIManager::LogType::Error);
        return false;
    }
}

/// <summary>
/// å®Ÿè¡Œæ™‚ãƒ„ãƒªãƒ¼ã‚’æ§‹ç¯‰
/// </summary>
BTNodePtr BossNodeEditor::BuildRuntimeTree() {
    // ãƒŽãƒ¼ãƒ‰ãŒå­˜åœ¨ã—ãªã„å ´åˆ
    if (nodes_.empty()) {
        return nullptr;
    }

    // ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰ã‚’æŽ¢ã™
    int rootId = FindRootNodeId();
    if (rootId == -1) {
        // ãƒ«ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€æœ€åˆã®ãƒŽãƒ¼ãƒ‰ã‚’ãƒ«ãƒ¼ãƒˆã¨ã™ã‚‹ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        rootId = nodes_[0].id;
    }

    // å†å¸°çš„ã«ãƒ„ãƒªãƒ¼ã‚’æ§‹ç¯‰
    BTNodePtr rootNode;
    BuildRuntimeTreeRecursive(rootId, rootNode);

    return rootNode;
}

/// <summary>
/// ç¾åœ¨å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºï¼ˆãƒ‘ãƒ«ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä»˜ãï¼‰
/// </summary>
void BossNodeEditor::HighlightRunningNode(const BTNodePtr& nodePtr) {
    if (!nodePtr) {
        highlightedNodeId_ = -1;
        return;
    }

    EditorNode* editorNode = FindNodeByRuntimeNode(nodePtr);
    if (editorNode) {
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒŽãƒ¼ãƒ‰ã‚’æ›´æ–°
        if (highlightedNodeId_ != editorNode->id) {
            highlightedNodeId_ = editorNode->id;
            highlightStartTime_ = static_cast<float>(ImGui::GetTime());
        }
    }
}

// ==========================================
// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã®å®Ÿè£…
// ==========================================

/// <summary>
/// IDã§ãƒŽãƒ¼ãƒ‰ã‚’æ¤œç´¢
/// </summary>
BossNodeEditor::EditorNode* BossNodeEditor::FindNodeById(int nodeId) {
    for (auto& node : nodes_) {
        if (node.id == nodeId) {
            return &node;
        }
    }
    return nullptr;
}

/// <summary>
/// IDã§ãƒŽãƒ¼ãƒ‰ã‚’æ¤œç´¢ï¼ˆconstç‰ˆï¼‰
/// </summary>
const BossNodeEditor::EditorNode* BossNodeEditor::FindNodeById(int nodeId) const {
    for (const auto& node : nodes_) {
        if (node.id == nodeId) {
            return &node;
        }
    }
    return nullptr;
}

/// <summary>
/// ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒŽãƒ¼ãƒ‰ã§ã‚¨ãƒ‡ã‚£ã‚¿ãƒŽãƒ¼ãƒ‰ã‚’æ¤œç´¢
/// </summary>
BossNodeEditor::EditorNode* BossNodeEditor::FindNodeByRuntimeNode(const BTNodePtr& node) {
    if (!node) return nullptr;

    auto it = runtimeNodeToEditorId_.find(node.get());
    if (it != runtimeNodeToEditorId_.end()) {
        return FindNodeById(it->second);
    }
    return nullptr;
}

/// <summary>
/// IDã§ãƒ”ãƒ³ã‚’æ¤œç´¢
/// </summary>
BossNodeEditor::EditorPin* BossNodeEditor::FindPinById(int pinId) {
    for (auto& pin : pins_) {
        if (pin.id == pinId) {
            return &pin;
        }
    }
    return nullptr;
}

/// <summary>
/// IDã§ãƒ”ãƒ³ã‚’æ¤œç´¢ï¼ˆconstç‰ˆï¼‰
/// </summary>
const BossNodeEditor::EditorPin* BossNodeEditor::FindPinById(int pinId) const {
    for (const auto& pin : pins_) {
        if (pin.id == pinId) {
            return &pin;
        }
    }
    return nullptr;
}

/// <summary>
/// IDã§ãƒªãƒ³ã‚¯ã‚’æ¤œç´¢
/// </summary>
BossNodeEditor::EditorLink* BossNodeEditor::FindLinkById(int linkId) {
    for (auto& link : links_) {
        if (link.id == linkId) {
            return &link;
        }
    }
    return nullptr;
}

/// <summary>
/// ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰IDã‚’æ¤œç´¢
/// </summary>
int BossNodeEditor::FindRootNodeId() const {
    // å…¥åŠ›ãƒªãƒ³ã‚¯ã‚’æŒãŸãªã„ãƒŽãƒ¼ãƒ‰ã‚’æŽ¢ã™
    for (const auto& node : nodes_) {
        bool hasInputLink = false;

        // ã“ã®ãƒŽãƒ¼ãƒ‰ãŒä½•ã‹ã®ãƒªãƒ³ã‚¯ã®çµ‚ç‚¹ã«ãªã£ã¦ã„ã‚‹ã‹ç¢ºèª
        for (const auto& link : links_) {
            if (link.endNodeId == node.id) {
                hasInputLink = true;
                break;
            }
        }

        // å…¥åŠ›ãƒªãƒ³ã‚¯ãŒãªã„ãƒŽãƒ¼ãƒ‰ãŒãƒ«ãƒ¼ãƒˆ
        if (!hasInputLink) {
            return node.id;
        }
    }

    // ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
    return -1;
}

/// <summary>
/// å­ãƒŽãƒ¼ãƒ‰IDãƒªã‚¹ãƒˆã‚’å–å¾—
/// </summary>
std::vector<int> BossNodeEditor::GetChildNodeIds(int parentNodeId) const {
    std::vector<int> childIds;

    // æŒ‡å®šãƒŽãƒ¼ãƒ‰ã‹ã‚‰å‡ºã¦ã„ã‚‹ãƒªãƒ³ã‚¯ã‚’æŽ¢ã™
    for (const auto& link : links_) {
        if (link.startNodeId == parentNodeId) {
            childIds.push_back(link.endNodeId);
        }
    }

    return childIds;
}

/// <summary>
/// å¾ªç’°å‚ç…§ãƒã‚§ãƒƒã‚¯
/// </summary>
bool BossNodeEditor::HasCyclicDependency(int startNodeId, int endNodeId) const {
    // startNodeIdã‹ã‚‰endNodeIdã¸ã®ãƒªãƒ³ã‚¯ã‚’ä½œæˆã—ãŸå ´åˆã«ã€
    // endNodeIdã‹ã‚‰startNodeIdã¸ã®ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯

    // BFSï¼ˆå¹…å„ªå…ˆæŽ¢ç´¢ï¼‰ã§å¾ªç’°å‚ç…§ã‚’ãƒã‚§ãƒƒã‚¯
    std::set<int> visited;
    std::queue<int> queue;
    queue.push(endNodeId);

    while (!queue.empty()) {
        int currentId = queue.front();
        queue.pop();

        // startNodeIdã«åˆ°é”ã—ãŸå ´åˆã€å¾ªç’°å‚ç…§ãŒç™ºç”Ÿ
        if (currentId == startNodeId) {
            return true;
        }

        // æ—¢ã«è¨ªå•æ¸ˆã¿ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        if (visited.find(currentId) != visited.end()) {
            continue;
        }
        visited.insert(currentId);

        // ç¾åœ¨ã®ãƒŽãƒ¼ãƒ‰ã®å­ãƒŽãƒ¼ãƒ‰ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
        std::vector<int> childIds = GetChildNodeIds(currentId);
        for (int childId : childIds) {
            queue.push(childId);
        }
    }

    // å¾ªç’°å‚ç…§ãªã—
    return false;
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ä½œæˆ
/// </summary>
void BossNodeEditor::CreateNode(const std::string& nodeType, const ImVec2& position) {
    CreateNodeWithId(nextNodeId_++, nodeType, position);
}

/// <summary>
/// æŒ‡å®šIDã§ãƒŽãƒ¼ãƒ‰ä½œæˆ
/// </summary>
int BossNodeEditor::CreateNodeWithId(int nodeId, const std::string& nodeType, const ImVec2& position) {
    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒŽãƒ¼ãƒ‰ã‚’ä½œæˆ
    EditorNode newNode;
    newNode.id = nodeId;
    newNode.position = position;
    newNode.nodeType = nodeType;
    newNode.displayName = BossNodeFactory::GetNodeDisplayName(nodeType);
    newNode.color = BossNodeFactory::GetNodeColor(nodeType);

    // ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒŽãƒ¼ãƒ‰ã‚’ä½œæˆï¼ˆä¾å­˜é–¢ä¿‚ãªã—ã§è©¦ã¿ã‚‹ï¼‰
    newNode.runtimeNode = BossNodeFactory::CreateNode(nodeType);
    if (!newNode.runtimeNode) {
        // ä¾å­˜é–¢ä¿‚ãŒå¿…è¦ãªå ´åˆã¯ã€ã¨ã‚Šã‚ãˆãšnullptrã§ã‚‚ä½œæˆ
        // å¾Œã§SetDependenciesã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã§è¨­å®šå¯èƒ½ã«ã™ã‚‹
        newNode.runtimeNode = BossNodeFactory::CreateNodeWithDependencies(nodeType, nullptr, nullptr);
    }

    // å…¥åŠ›ãƒ”ãƒ³ã‚’ä½œæˆï¼ˆå…¨ãƒŽãƒ¼ãƒ‰ã¯è¦ªã‚’æŒã¦ã‚‹ï¼‰
    EditorPin inputPin;
    inputPin.id = nextPinId_++;
    inputPin.nodeId = nodeId;
    inputPin.isInput = true;
    inputPin.name = "In";
    pins_.push_back(inputPin);
    newNode.inputPinIds.push_back(inputPin.id);

    // å‡ºåŠ›ãƒ”ãƒ³ã‚’ä½œæˆï¼ˆã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã®ã¿ï¼‰
    if (BossNodeFactory::IsCompositeNode(nodeType)) {
        EditorPin outputPin;
        outputPin.id = nextPinId_++;
        outputPin.nodeId = nodeId;
        outputPin.isInput = false;
        outputPin.name = "Out";
        pins_.push_back(outputPin);
        newNode.outputPinIds.push_back(outputPin.id);
    }

    // ãƒŽãƒ¼ãƒ‰ã‚’è¿½åŠ 
    nodes_.push_back(newNode);

    // ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒŽãƒ¼ãƒ‰ã¨ã‚¨ãƒ‡ã‚£ã‚¿IDã®ãƒžãƒƒãƒ”ãƒ³ã‚°
    if (newNode.runtimeNode) {
        runtimeNodeToEditorId_[newNode.runtimeNode.get()] = nodeId;
    }

    // ãƒŽãƒ¼ãƒ‰ä½ç½®ã‚’è¨­å®š
    //ed::SetNodePosition(nodeId, position);

    return nodeId;
}

/// <summary>
/// å†å¸°çš„ã«ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒ„ãƒªãƒ¼ã‚’æ§‹ç¯‰
/// </summary>
void BossNodeEditor::BuildRuntimeTreeRecursive(int nodeId, BTNodePtr& outNode) {
    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒŽãƒ¼ãƒ‰ã‚’å–å¾—
    EditorNode* editorNode = FindNodeById(nodeId);
    if (!editorNode || !editorNode->runtimeNode) {
        return;
    }

    // ã“ã®ãƒŽãƒ¼ãƒ‰ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨­å®š
    outNode = editorNode->runtimeNode;

    // ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒŽãƒ¼ãƒ‰ã®å ´åˆã€å­ãƒŽãƒ¼ãƒ‰ã‚’è¿½åŠ 
    if (BossNodeFactory::IsCompositeNode(editorNode->nodeType)) {
        auto compositeNode = std::dynamic_pointer_cast<BTComposite>(outNode);
        if (compositeNode) {
            // æ—¢å­˜ã®å­ã‚’ã‚¯ãƒªã‚¢
            compositeNode->ClearChildren();

            // ã“ã®ãƒŽãƒ¼ãƒ‰ã®å­ãƒŽãƒ¼ãƒ‰IDã‚’å–å¾—
            std::vector<int> childIds = GetChildNodeIds(nodeId);

            // å„å­ãƒŽãƒ¼ãƒ‰ã‚’å†å¸°çš„ã«æ§‹ç¯‰
            for (int childId : childIds) {
                BTNodePtr childNode;
                BuildRuntimeTreeRecursive(childId, childNode);
                if (childNode) {
                    compositeNode->AddChild(childNode);
                }
            }
        }
    }
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŠ½å‡º
/// </summary>
nlohmann::json BossNodeEditor::ExtractNodeParameters(const EditorNode& node) {
    if (!node.runtimeNode) return {};
    return node.runtimeNode->ExtractParameters();
}

/// <summary>
/// ãƒŽãƒ¼ãƒ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
/// </summary>
void BossNodeEditor::ApplyNodeParameters(EditorNode& node, const nlohmann::json& params) {
    if (!node.runtimeNode || params.empty()) return;
    node.runtimeNode->ApplyParameters(params);
}

/// <summary>
/// ãƒªãƒ³ã‚¯ä½œæˆãƒ˜ãƒ«ãƒ‘ãƒ¼
/// </summary>
bool BossNodeEditor::CreateLink(int sourceNodeId, int targetNodeId) {
    auto* sourceNode = FindNodeById(sourceNodeId);
    auto* targetNode = FindNodeById(targetNodeId);

    if (!sourceNode || !targetNode) {
        return false;
    }

    if (sourceNode->outputPinIds.empty() || targetNode->inputPinIds.empty()) {
        return false;
    }

    // ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
    EditorLink link;
    link.id = nextLinkId_++;
    link.startPinId = sourceNode->outputPinIds[0];
    link.endPinId = targetNode->inputPinIds[0];
    link.startNodeId = sourceNodeId;
    link.endNodeId = targetNodeId;

    links_.push_back(link);
    return true;
}

/// <summary>
/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ„ãƒªãƒ¼ã®ä½œæˆï¼ˆBuildActionTreeã¨åŒã˜æ§‹é€ ï¼‰
/// </summary>
void BossNodeEditor::CreateDefaultTree() {
    // æ—¢å­˜ã®ãƒŽãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢
    Clear();

    // ãƒŽãƒ¼ãƒ‰ä½œæˆ
    // 1. Root Sequence (MainLoop)
    int rootId = CreateNodeWithId(nextNodeId_++, "BTSequence", ImVec2(400, 100));
    auto* rootNode = FindNodeById(rootId);
    if (rootNode) {
        rootNode->displayName = "MainLoop";
    }

    // 2. BTBossIdle
    int idleId = CreateNodeWithId(nextNodeId_++, "BTBossIdle", ImVec2(250, 250));
    auto* idleNode = FindNodeById(idleId);
    if (idleNode) {
        idleNode->displayName = "Idle";
    }

    // 3. Action Selector
    int selectorId = CreateNodeWithId(nextNodeId_++, "BTSelector", ImVec2(550, 250));
    auto* selectorNode = FindNodeById(selectorId);
    if (selectorNode) {
        selectorNode->displayName = "ActionSelector";
    }

    // 4. Dash Sequence
    int dashSeqId = CreateNodeWithId(nextNodeId_++, "BTSequence", ImVec2(350, 400));
    auto* dashSeqNode = FindNodeById(dashSeqId);
    if (dashSeqNode) {
        dashSeqNode->displayName = "DashSequence";
    }

    // 5. Dash Condition (BTActionSelector with ActionType::Dash)
    int dashCondId = CreateNodeWithId(nextNodeId_++, "BTActionSelector", ImVec2(250, 550));
    auto* dashCondNode = FindNodeById(dashCondId);
    if (dashCondNode) {
        dashCondNode->displayName = "DashCondition";
        // ActionTypeã‚’Dashã«è¨­å®š
        if (dashCondNode->runtimeNode) {
            auto selector = std::dynamic_pointer_cast<BTActionSelector>(dashCondNode->runtimeNode);
            if (selector) {
                selector->SetActionType(BTActionSelector::ActionType::Dash);
            }
        }
    }

    // 6. Dash Action
    int dashActId = CreateNodeWithId(nextNodeId_++, "BTBossDash", ImVec2(450, 550));
    auto* dashActNode = FindNodeById(dashActId);
    if (dashActNode) {
        dashActNode->displayName = "DashAction";
    }

    // 7. Shoot Sequence
    int shootSeqId = CreateNodeWithId(nextNodeId_++, "BTSequence", ImVec2(750, 400));
    auto* shootSeqNode = FindNodeById(shootSeqId);
    if (shootSeqNode) {
        shootSeqNode->displayName = "ShootSequence";
    }

    // 8. Shoot Condition (BTActionSelector with ActionType::Shoot)
    int shootCondId = CreateNodeWithId(nextNodeId_++, "BTActionSelector", ImVec2(650, 550));
    auto* shootCondNode = FindNodeById(shootCondId);
    if (shootCondNode) {
        shootCondNode->displayName = "ShootCondition";
        // ActionTypeã‚’Shootã«è¨­å®š
        if (shootCondNode->runtimeNode) {
            auto selector = std::dynamic_pointer_cast<BTActionSelector>(shootCondNode->runtimeNode);
            if (selector) {
                selector->SetActionType(BTActionSelector::ActionType::Shoot);
            }
        }
    }

    // 9. Shoot Action
    int shootActId = CreateNodeWithId(nextNodeId_++, "BTBossShoot", ImVec2(850, 550));
    auto* shootActNode = FindNodeById(shootActId);
    if (shootActNode) {
        shootActNode->displayName = "ShootAction";
    }

    // ãƒªãƒ³ã‚¯ä½œæˆ
    // MainLoop -> Idle
    CreateLink(rootId, idleId);
    // MainLoop -> ActionSelector
    CreateLink(rootId, selectorId);
    // ActionSelector -> DashSequence
    CreateLink(selectorId, dashSeqId);
    // ActionSelector -> ShootSequence
    CreateLink(selectorId, shootSeqId);
    // DashSequence -> DashCondition
    CreateLink(dashSeqId, dashCondId);
    // DashSequence -> DashAction
    CreateLink(dashSeqId, dashActId);
    // ShootSequence -> ShootCondition
    CreateLink(shootSeqId, shootCondId);
    // ShootSequence -> ShootAction
    CreateLink(shootSeqId, shootActId);

    // è‡ªå‹•çš„ã«JSONã«ä¿å­˜
    SaveToJSON("resources/Json/BossTree.json");

    DebugUIManager::GetInstance()->AddLog(
        "[BossNodeEditor] Default tree created and saved to BossTree.json",
        DebugUIManager::LogType::Info);
}

#endif // _DEBUG

============================================================
File Path: GameProject/Object/Boss/BossNodeEditor/BossNodeEditor.h
============================================================
#pragma once

#ifdef _DEBUG

#include "ImGuiManager.h"
#include <../../../../TakoEngine/project/externals/imgui-node-editor/imgui_node_editor.h>
#include <vector>
#include <memory>
#include <unordered_map>
#include <unordered_set>
#include <deque>
#include <string>
#include <json.hpp>
#include "../../../BehaviorTree/Core/BTNode.h"

// åå‰ç©ºé–“ã‚¨ã‚¤ãƒªã‚¢ã‚¹
namespace ed = ax::NodeEditor;

class BossBehaviorTree;
class Boss;
class Player;

/// <summary>
/// ãƒœã‚¹ç”¨ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ãƒŽãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿
/// imgui-node-editorã‚’ç›´æŽ¥ä½¿ç”¨ã—ã¦ãƒ“ãƒ˜ã‚¤ãƒ“ã‚¢ãƒ„ãƒªãƒ¼ã‚’è¦–è¦šçš„ã«ç·¨é›†
/// </summary>
class BossNodeEditor {
public:
    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒŽãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚¨ãƒ‡ã‚£ã‚¿å°‚ç”¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼‰
    /// </summary>
    struct EditorNode {
        int id;                              // ã‚¨ãƒ‡ã‚£ã‚¿å›ºæœ‰IDï¼ˆ10000ç•ªå°ï¼‰
        ImVec2 position;                     // ã‚¨ãƒ‡ã‚£ã‚¿ä¸Šã®ä½ç½®
        std::string nodeType;                // ãƒŽãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åï¼ˆ"BTSelector", "BTSequence"ç­‰ï¼‰
        std::string displayName;             // è¡¨ç¤ºå
        BTNodePtr runtimeNode;               // å®Ÿéš›ã®å®Ÿè¡ŒãƒŽãƒ¼ãƒ‰
        std::vector<int> inputPinIds;        // å…¥åŠ›ãƒ”ãƒ³IDï¼ˆè¦ªæŽ¥ç¶šç”¨ï¼‰
        std::vector<int> outputPinIds;       // å‡ºåŠ›ãƒ”ãƒ³IDï¼ˆå­æŽ¥ç¶šç”¨ï¼‰
        ImVec4 color;                        // ãƒŽãƒ¼ãƒ‰ã‚«ãƒ©ãƒ¼
    };

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒªãƒ³ã‚¯ãƒ‡ãƒ¼ã‚¿
    /// </summary>
    struct EditorLink {
        int id;                              // ãƒªãƒ³ã‚¯å›ºæœ‰IDï¼ˆ30000ç•ªå°ï¼‰
        int startPinId;                      // é–‹å§‹ãƒ”ãƒ³ID
        int endPinId;                        // çµ‚äº†ãƒ”ãƒ³ID
        int startNodeId;                     // é–‹å§‹ãƒŽãƒ¼ãƒ‰ID
        int endNodeId;                       // çµ‚äº†ãƒŽãƒ¼ãƒ‰ID
    };

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ”ãƒ³ãƒ‡ãƒ¼ã‚¿
    /// </summary>
    struct EditorPin {
        int id;                              // ãƒ”ãƒ³å›ºæœ‰IDï¼ˆ20000ç•ªå°ï¼‰
        int nodeId;                          // æ‰€å±žãƒŽãƒ¼ãƒ‰ID
        bool isInput;                        // å…¥åŠ›ãƒ”ãƒ³ã‹ã©ã†ã‹
        std::string name;                    // ãƒ”ãƒ³å
    };

    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BossNodeEditor();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~BossNodeEditor();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ã®åˆæœŸåŒ–
    /// </summary>
    void Initialize();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ã®æ›´æ–°ãƒ»æç”»ï¼ˆImGuiã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ã§å‘¼ã¶ï¼‰
    /// </summary>
    void Update();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ã®çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
    /// </summary>
    /// <param name="visible">è¡¨ç¤ºã™ã‚‹ã‹ã©ã†ã‹</param>
    void SetVisible(bool visible) { isVisible_ = visible; }

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ã®è¡¨ç¤ºçŠ¶æ…‹å–å¾—
    /// </summary>
    /// <returns>è¡¨ç¤ºä¸­ãªã‚‰true</returns>
    bool IsVisible() const { return isVisible_; }

    /// <summary>
    /// ãƒ„ãƒªãƒ¼ã‚’JSONã‹ã‚‰èª­ã¿è¾¼ã¿
    /// </summary>
    /// <param name="filepath">JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <returns>æˆåŠŸã—ãŸã‚‰true</returns>
    bool LoadFromJSON(const std::string& filepath);

    /// <summary>
    /// ãƒ„ãƒªãƒ¼ã‚’JSONã«ä¿å­˜
    /// </summary>
    /// <param name="filepath">JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <returns>æˆåŠŸã—ãŸã‚‰true</returns>
    bool SaveToJSON(const std::string& filepath);

    /// <summary>
    /// å®Ÿè¡Œæ™‚ãƒ„ãƒªãƒ¼ã‚’æ§‹ç¯‰ï¼ˆBossBehaviorTreeã«æ¸¡ã™ç”¨ï¼‰
    /// </summary>
    /// <returns>ãƒ«ãƒ¼ãƒˆãƒŽãƒ¼ãƒ‰</returns>
    BTNodePtr BuildRuntimeTree();

    /// <summary>
    /// ç¾åœ¨å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    /// </summary>
    /// <param name="nodePtr">å®Ÿè¡Œä¸­ã®ãƒŽãƒ¼ãƒ‰</param>
    void HighlightRunningNode(const BTNodePtr& nodePtr);

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ã®ã‚¯ãƒªã‚¢
    /// </summary>
    void Clear();

    /// <summary>
    /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ„ãƒªãƒ¼ã®ä½œæˆï¼ˆBuildActionTreeã¨åŒã˜æ§‹é€ ï¼‰
    /// </summary>
    void CreateDefaultTree();

private:
    // ax::NodeEditor ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    ed::EditorContext* editorContext_;
    std::unique_ptr<ed::Config> editorConfig_;

    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ‡ãƒ¼ã‚¿
    std::vector<EditorNode> nodes_;
    std::vector<EditorLink> links_;
    std::vector<EditorPin> pins_;

    // IDç®¡ç†ï¼ˆIDç¯„å›²ã‚’åˆ†é›¢ã—ã¦ç«¶åˆã‚’é˜²ãï¼‰
    int nextNodeId_;    // 10000ç•ªå°
    int nextLinkId_;    // 30000ç•ªå°
    int nextPinId_;     // 20000ç•ªå°

    // ã‚¨ãƒ‡ã‚£ã‚¿çŠ¶æ…‹
    bool isVisible_;
    bool firstFrame_;
    int highlightedNodeId_;  // ç¾åœ¨ãƒã‚¤ãƒ©ã‚¤ãƒˆä¸­ã®ãƒŽãƒ¼ãƒ‰IDï¼ˆå®Ÿè¡Œãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    float highlightStartTime_;  // ãƒã‚¤ãƒ©ã‚¤ãƒˆé–‹å§‹æ™‚åˆ»ï¼ˆãƒ‘ãƒ«ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ï¼‰
    int selectedNodeId_ = -1;  // é¸æŠžä¸­ã®ãƒŽãƒ¼ãƒ‰IDï¼ˆã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ç”¨ï¼‰

    // å†…éƒ¨å‡¦ç†
    void DrawNodes();
    void DrawNode(const EditorNode& node);
    void DrawLinks();
    void DrawPin(const EditorPin& pin);
    void HandleNodeCreation();
    void HandleLinkCreation();
    void HandleDeletion();
    void DrawContextMenu();
    void DrawNodeInspector();
    void DrawToolbar();

    // ãƒŽãƒ¼ãƒ‰ä½œæˆ
    void CreateNode(const std::string& nodeType, const ImVec2& position);
    int CreateNodeWithId(int nodeId, const std::string& nodeType, const ImVec2& position);

    // ãƒªãƒ³ã‚¯ä½œæˆãƒ˜ãƒ«ãƒ‘ãƒ¼
    bool CreateLink(int sourceNodeId, int targetNodeId);

    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    EditorNode* FindNodeById(int nodeId);
    const EditorNode* FindNodeById(int nodeId) const;
    EditorNode* FindNodeByRuntimeNode(const BTNodePtr& node);
    EditorPin* FindPinById(int pinId);
    const EditorPin* FindPinById(int pinId) const;
    EditorLink* FindLinkById(int linkId);

    int FindRootNodeId() const;
    void BuildRuntimeTreeRecursive(int nodeId, BTNodePtr& outNode);
    bool HasCyclicDependency(int startNodeId, int endNodeId) const;
    std::vector<int> GetChildNodeIds(int parentNodeId) const;

    // ãƒŽãƒ¼ãƒ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ä¿å­˜ãƒ»å¾©å…ƒ
    nlohmann::json ExtractNodeParameters(const EditorNode& node);
    void ApplyNodeParameters(EditorNode& node, const nlohmann::json& params);

    // ãƒŽãƒ¼ãƒ‰ãƒ»ãƒ”ãƒ³IDãƒžãƒƒãƒ”ãƒ³ã‚°ç®¡ç†
    std::unordered_map<BTNode*, int> runtimeNodeToEditorId_;
};

#endif // _DEBUG

============================================================
File Path: GameProject/Object/Player/Player.cpp
============================================================
#include "Player.h"
#include "Object3d.h"
#include "Input.h"
#include "Camera.h"
#include "State/PlayerStateMachine.h"
#include "State/IdleState.h"
#include "State/MoveState.h"
#include "State/DashState.h"
#include "State/AttackState.h"
#include "State/ShootState.h"
#include "State/ParryState.h"
#include "Input/InputHandler.h"
#include "OBBCollider.h"
#include "../../Collision/MeleeAttackCollider.h"
#include "CollisionManager.h"
#include "../../Collision/CollisionTypeIdDef.h"
#include "../Boss/Boss.h"
#include "GlobalVariables.h"
#include "../../Common/GameConst.h"
#include "FrameTimer.h"
#include "Sprite.h"
#include "../../CameraSystem/CameraManager.h"
#include "PostEffectManager.h"
#include "PostEffectStruct.h"

#include <cmath>
#include <algorithm>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif


Player::Player()
    : camera_(nullptr)
    , targetAngle_(0.0f)
    , mode_(false)
{
    // å‹•çš„åˆ¶é™ã‚’åˆæœŸåŒ–ï¼ˆç„¡åŠ¹åŒ–ï¼‰
    ClearDynamicBounds();
}

Player::~Player()
{
}

void Player::Initialize()
{
    GlobalVariables* gv = GlobalVariables::GetInstance();

    model_ = std::make_unique<Object3d>();
    model_->Initialize();
    model_->SetModel("white_cube.gltf");

    transform_.translate = Vector3(0.0f, initialY_, initialZ_);
    transform_.rotate = Vector3(0.0f, 0.0f, 0.0f);
    transform_.scale = Vector3(1.0f, 1.0f, 1.0f);

    model_->SetTransform(transform_);

    // HPãƒãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
    hpBarSprite_ = std::make_unique<Sprite>();
    hpBarSprite_->Initialize("white.png");
    hpBarSize_ = Vector2(500.0f, 30.0f);
    hpBarSprite_->SetSize(hpBarSize_);
    hpBarSprite_->SetAnchorPoint(Vector2(1.0f, 0.0f));
    hpBarSprite_->SetColor({ 0.3f, 1.0f, 0.3f, 1.0f });
    hpBarSprite_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));

    hpBarBGSprite_ = std::make_unique<Sprite>();
    hpBarBGSprite_->Initialize("white.png");
    hpBarBGSprite_->SetSize(hpBarSize_);
    hpBarBGSprite_->SetAnchorPoint(Vector2(1.0f, 0.0f));
    hpBarBGSprite_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));

    // State Machineã®åˆæœŸåŒ–
    stateMachine_ = std::make_unique<PlayerStateMachine>(this);
    stateMachine_->RegisterState("Idle", std::make_unique<IdleState>());
    stateMachine_->RegisterState("Move", std::make_unique<MoveState>());
    stateMachine_->RegisterState("Dash", std::make_unique<DashState>());
    stateMachine_->RegisterState("Attack", std::make_unique<AttackState>());
    stateMachine_->RegisterState("Shoot", std::make_unique<ShootState>());
    stateMachine_->RegisterState("Parry", std::make_unique<ParryState>());
    stateMachine_->ChangeState("Idle");
    stateMachine_->Initialize();

    // Colliderã®åˆæœŸåŒ–
    SetupColliders();

    // æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã®åˆæœŸåŒ–
    attackBlock_ = std::make_unique<Object3d>();
    attackBlock_->Initialize();
    attackBlock_->SetModel("white_cube.gltf");
}

void Player::Finalize()
{
    // Colliderã‚’å‰Šé™¤
    if (bodyCollider_) {
        CollisionManager::GetInstance()->RemoveCollider(bodyCollider_.get());
    }
    if (meleeAttackCollider_) {
        CollisionManager::GetInstance()->RemoveCollider(meleeAttackCollider_.get());
    }
}

void Player::Update()
{
    // GlobalVariablesã‹ã‚‰å€¤ã‚’åŒæœŸ
    GlobalVariables* gv = GlobalVariables::GetInstance();
    speed_ = gv->GetValueFloat("Player", "Speed");
    attackMinDist_ = gv->GetValueFloat("Player", "AttackStartDistance");
    attackMoveRotationLerp_ = gv->GetValueFloat("Player", "AttackMoveRotationLerp");
    bossLookatLerp_ = gv->GetValueFloat("Player", "BossLookatLerp");
    attackMoveSpeed_ = gv->GetValueFloat("Player", "AttackMoveSpeed");

    // æ­»äº¡åˆ¤å®š
    if (hp_ <= 0.0f) isDead_ = true;

    // HPãƒãƒ¼ã®æ›´æ–°
    hpBarSprite_->SetSize(Vector2(hpBarSize_.x * (hp_ / kMaxHp), hpBarSize_.y));
    hpBarSprite_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));
    hpBarBGSprite_->SetPos(Vector2(
        WinApp::clientWidth * hpBarScreenXRatio_,
        WinApp::clientHeight * hpBarScreenYRatio_));
    hpBarSprite_->Update();
    hpBarBGSprite_->Update();

    // State Machineã®æ›´æ–°
    if (stateMachine_) {
        stateMachine_->HandleInput();
        stateMachine_->Update(FrameTimer::GetInstance()->GetDeltaTime());
    }

    // ãƒ•ã‚§ãƒ¼ã‚º2æ™‚ã¯ãƒœã‚¹æ–¹å‘ã‚’å‘ã
    LookAtBoss();

    // å®ŸåŠ¹çš„ãªåˆ¶é™ã‚’è¨ˆç®—ï¼ˆé™çš„åˆ¶é™ã¨å‹•çš„åˆ¶é™ã®äº¤å·®ï¼‰
    float effectiveXMin = std::max<float>(GameConst::kStageXMin, dynamicXMin_);
    float effectiveXMax = std::min<float>(GameConst::kStageXMax, dynamicXMax_);
    float effectiveZMin = std::max<float>(GameConst::kStageZMin, dynamicZMin_);
    float effectiveZMax = std::min<float>(GameConst::kStageZMax, dynamicZMax_);

    // ä½ç½®åˆ¶é™é©ç”¨
    transform_.translate.x = std::min<float>(transform_.translate.x, effectiveXMax);
    transform_.translate.x = std::max<float>(transform_.translate.x, effectiveXMin);
    transform_.translate.z = std::min<float>(transform_.translate.z, effectiveZMax);
    transform_.translate.z = std::max<float>(transform_.translate.z, effectiveZMin);

    // ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
    model_->SetTransform(transform_);
    model_->Update();

    // æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã®æ›´æ–°ï¼ˆè¡¨ç¤ºä¸­ã®ã¿ï¼‰
    if (attackBlockVisible_ && attackBlock_) {
        attackBlock_->Update();
    }

    // è¢«å¼¾Vignetteã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
    if (damageVignetteTimer_ > 0.0f) {
        float deltaTime = FrameTimer::GetInstance()->GetDeltaTime();
        damageVignetteTimer_ -= deltaTime;

        float t = damageVignetteTimer_ / kDamageVignetteDuration_;
        VignetteParam vignetteParam{};
        vignetteParam.power = kDamageVignettePower_ * t;
        vignetteParam.range = kDamageVignetteRange_;
        vignetteParam.color = Vector3{1.0f, 0.0f, 0.0f};
        PostEffectManager::GetInstance()->SetEffectParam("Vignette", vignetteParam);

        if (damageVignetteTimer_ <= 0.0f) {
            damageVignetteTimer_ = 0.0f;
            PostEffectManager::GetInstance()->RemoveEffectFromChain("Vignette");
        }
    }

    // æ”»æ’ƒç¯„å›²Colliderã®æ›´æ–°
    UpdateAttackCollider();
}

void Player::Draw()
{
    model_->Draw();

    // æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã®æç”»ï¼ˆè¡¨ç¤ºä¸­ã®ã¿ï¼‰
    if (attackBlockVisible_ && attackBlock_) {
        attackBlock_->Draw();
    }
}

void Player::DrawSprite()
{
    hpBarBGSprite_->Draw();
    hpBarSprite_->Draw();
}

void Player::Move(float speedMultiplier, bool isApplyDirCalulate)
{
    if (!inputHandlerPtr_) return;

    GlobalVariables* gv = GlobalVariables::GetInstance();
    float deadzone = gv->GetValueFloat("Player", "MoveInputDeadzone");
    float rotationLerpSpeed = gv->GetValueFloat("Player", "RotationLerpSpeed");

    Vector2 moveDir = inputHandlerPtr_->GetMoveDirection();
    if (moveDir.Length() < deadzone) return;

    // 3Dãƒ™ã‚¯ãƒˆãƒ«ã«å¤‰æ›
    velocity_ = { moveDir.x, 0.0f, moveDir.y };
    velocity_ = velocity_.Normalize() * speed_ * speedMultiplier;

    // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ç§»å‹•æ–¹å‘ã‚’èª¿æ•´
    if (mode_ && camera_) {
        Matrix4x4 rotationMatrix = Mat4x4::MakeRotateY(camera_->GetRotateY());
        velocity_ = Mat4x4::TransformNormal(rotationMatrix, velocity_);
    }

    // ä½ç½®ã‚’æ›´æ–°
    transform_.translate += velocity_;

    // ç§»å‹•æ–¹å‘ã‚’å‘ã
    if (velocity_.Length() > kVelocityEpsilon && isApplyDirCalulate) {
        targetAngle_ = std::atan2(velocity_.x, velocity_.z);
        transform_.rotate.y = Vec3::LerpShortAngle(transform_.rotate.y, targetAngle_, rotationLerpSpeed);
    }
}

void Player::MoveToTarget(Boss* target, float deltaTime)
{
    if (!target) return;

    // åˆå›žå‘¼ã³å‡ºã—æ™‚ã®åˆæœŸåŒ–
    if (!isMoveInitialized_) {
        moveStartPosition_ = transform_.translate;

        Vector3 targetPos = target->GetTransform().translate;
        Vector3 toTarget = targetPos - moveStartPosition_;
        toTarget.y = 0.0f;
        float distance = toTarget.Length();

        if (distance > attackMinDist_ && distance > kDirectionEpsilon) {
            Vector3 direction = toTarget.Normalize();

            // ç›®æ¨™ä½ç½® = ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‹ã‚‰ attackMinDist_ æ‰‹å‰
            float moveDistance = distance - attackMinDist_;
            moveTargetPosition_ = moveStartPosition_ + direction * moveDistance;
            moveTargetPosition_.y = moveStartPosition_.y;

            // æ‰€è¦æ™‚é–“ã‚’è¨ˆç®—
            moveDuration_ = moveDistance / attackMoveSpeed_;

            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ã‚’å‘ã
            targetAngle_ = std::atan2(direction.x, direction.z);
        }
        else {
            // æ—¢ã«æ”»æ’ƒç¯„å›²å†…
            moveTargetPosition_ = moveStartPosition_;
            moveDuration_ = 0.0f;
        }

        moveElapsedTime_ = 0.0f;
        isMoveInitialized_ = true;
    }

    // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ç§»å‹•
    if (moveDuration_ > 0.0f) {
        float t = moveElapsedTime_ / moveDuration_;
        t = std::clamp(t, 0.0f, 1.0f);

        // smoothstep ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°
        t = t * t * (kMoveEasingCoeffA - kMoveEasingCoeffB * t);

        Vector3 newPos = Vector3::Lerp(moveStartPosition_, moveTargetPosition_, t);
        transform_.translate = newPos;
    }

    // å›žè»¢ã®è£œé–“
    transform_.rotate.y = Vec3::LerpShortAngle(transform_.rotate.y, targetAngle_, attackMoveRotationLerp_);

    moveElapsedTime_ += deltaTime;
}

void Player::ResetMoveToTarget()
{
    isMoveInitialized_ = false;
    moveElapsedTime_ = 0.0f;
    moveDuration_ = 0.0f;
}

bool Player::HasReachedTarget() const
{
    static constexpr float kMoveArrivalThreshold = 0.5f;

    if (moveDuration_ <= 0.0f) return true;  // ç§»å‹•ä¸è¦

    Vector3 diff = transform_.translate - moveTargetPosition_;
    diff.y = 0.0f;
    return diff.Length() < kMoveArrivalThreshold;
}

void Player::SetupColliders()
{
    GlobalVariables* gv = GlobalVariables::GetInstance();
    float bodySize = gv->GetValueFloat("Player", "BodyColliderSize");
    float meleeX = gv->GetValueFloat("Player", "MeleeColliderX");
    float meleeY = gv->GetValueFloat("Player", "MeleeColliderY");
    float meleeZ = gv->GetValueFloat("Player", "MeleeColliderZ");
    float meleeOffsetZ = gv->GetValueFloat("Player", "MeleeColliderOffsetZ");

    // æœ¬ä½“ã®Collider
    bodyCollider_ = std::make_unique<OBBCollider>();
    bodyCollider_->SetTransform(&transform_);
    bodyCollider_->SetSize(Vector3(bodySize, bodySize, bodySize));
    bodyCollider_->SetOffset(Vector3(0.0f, 0.0f, 0.0f));
    bodyCollider_->SetTypeID(static_cast<uint32_t>(CollisionTypeId::PLAYER));
    bodyCollider_->SetOwner(this);

    // æ”»æ’ƒç¯„å›²ã®Collider
    meleeAttackCollider_ = std::make_unique<MeleeAttackCollider>(this);
    meleeAttackCollider_->SetTransform(&transform_);
    meleeAttackCollider_->SetSize(Vector3(meleeX, meleeY, meleeZ));
    meleeAttackCollider_->SetOffset(Vector3(0.0f, 0.0f, meleeOffsetZ));
    meleeAttackCollider_->SetActive(false);

    // CollisionManagerã«ç™»éŒ²
    CollisionManager* collisionManager = CollisionManager::GetInstance();
    collisionManager->AddCollider(bodyCollider_.get());
    collisionManager->AddCollider(meleeAttackCollider_.get());
}

void Player::UpdateAttackCollider()
{
    if (!meleeAttackCollider_) return;

    // æ”»æ’ƒçŠ¶æ…‹ã®æ™‚ã®ã¿å‰æ–¹ã«é…ç½®
    if (meleeAttackCollider_->IsActive()) {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›žè»¢è¡Œåˆ—ã‚’ä½œæˆï¼ˆYè»¸å›žè»¢ã®ã¿ï¼‰
        Matrix4x4 rotationMatrix = Mat4x4::MakeRotateY(transform_.rotate.y);
        meleeAttackCollider_->SetOrientation(rotationMatrix);
    }
}

void Player::LookAtBoss()
{
    // ãƒœã‚¹å‚ç…§ãŒãªã„ã€ã¾ãŸã¯ãƒ•ã‚§ãƒ¼ã‚º2ã§ãªã‘ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
    if (!targetEnemy_ || targetEnemy_->GetPhase() != 2) return;

    // ãƒœã‚¹ã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
    Vector3 toTarget = targetEnemy_->GetTransform().translate - transform_.translate;
    toTarget.y = 0.0f;  // Yè»¸ã¯ç„¡è¦–

    if (toTarget.Length() < 0.01f) return;  // è·é›¢ãŒè¿‘ã™ãŽã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—

    // ç›®æ¨™è§’åº¦ã‚’è¨ˆç®—
    float targetAngle = std::atan2(toTarget.x, toTarget.z);

    // ã‚¹ãƒ ãƒ¼ã‚ºã«è£œé–“ã—ã¦å›žè»¢
    transform_.rotate.y = Vec3::LerpShortAngle(transform_.rotate.y, targetAngle, bossLookatLerp_);
}

void Player::OnHit(float damage)
{
    if (IsInvincible()) return;

    hp_ -= damage;
    hp_ = std::max<float>(hp_, 0.0f);

    // ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ç™ºå‹•ï¼ˆè¢«å¼¾æ™‚ã¯å¼·ã‚ã«ï¼‰
    CameraManager::GetInstance()->StartShake(0.8f);

    // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒˆæŒ¯å‹•
    Input::GetInstance()->SetVibration(0.2f, 0.3f, 0.25f);

    // è¢«å¼¾Vignetteã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹
    damageVignetteTimer_ = kDamageVignetteDuration_;
    if (!PostEffectManager::GetInstance()->IsEffectInChain("Vignette")) {
        PostEffectManager::GetInstance()->AddEffectToChain("Vignette");
    }
    VignetteParam vignetteParam{};
    vignetteParam.power = kDamageVignettePower_;
    vignetteParam.range = kDamageVignetteRange_;
    vignetteParam.color = Vector3{1.0f, 0.0f, 0.0f};  // èµ¤
    PostEffectManager::GetInstance()->SetEffectParam("Vignette", vignetteParam);
}

void Player::DrawImGui()
{
#ifdef _DEBUG
    static int selectedTab = 0;  // ã‚¿ãƒ–ã®é¸æŠžçŠ¶æ…‹ã‚’ä¿æŒ

    // ã‚¿ãƒ–ãƒãƒ¼é–‹å§‹
    if (ImGui::BeginTabBar("PlayerDebugTabs", ImGuiTabBarFlags_None)) {

        // ========== General ã‚¿ãƒ– ==========
        if (ImGui::BeginTabItem("General")) {
            selectedTab = 0;

            // HP
            ImGui::Text("Health");
            ImGui::SliderFloat("HP", &hp_, 0.0f, 200.0f, "%.1f");
            ImGui::ProgressBar(hp_ / 100.0f, ImVec2(-1, 0), "");
            ImGui::Checkbox("Invincible", &isInvincible_);

            ImGui::Separator();

            // Transform
            if (ImGui::TreeNode("Transform")) {
                ImGui::DragFloat3("Position", &transform_.translate.x, 0.1f);
                ImGui::DragFloat3("Rotation", &transform_.rotate.x, 0.01f);
                ImGui::DragFloat3("Scale", &transform_.scale.x, 0.01f);
                ImGui::TreePop();
            }

            // Speed
            ImGui::Separator();
            ImGui::SliderFloat("Move Speed", &speed_, 0.0f, 2.0f);

            ImGui::EndTabItem();
        }

        // ========== States ã‚¿ãƒ– ==========
        if (ImGui::BeginTabItem("States")) {
            selectedTab = 1;

            // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ãƒˆæƒ…å ±
            if (stateMachine_) {
                PlayerState* currentState = stateMachine_->GetCurrentState();
                if (currentState) {
                    // ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆåã‚’å¼·èª¿è¡¨ç¤º
                    ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Active State: %s", currentState->GetName().c_str());
                }

                ImGui::Separator();

                // å…¨ã‚¹ãƒ†ãƒ¼ãƒˆè©³ç´°è¡¨ç¤ºï¼ˆæ–°æ©Ÿèƒ½ï¼‰
                if (ImGui::TreeNode("All States Details")) {
                    static std::string selectedStateName = "Idle";  // é¸æŠžä¸­ã®ã‚¹ãƒ†ãƒ¼ãƒˆåã‚’ä¿æŒ

                    // ã‚¹ãƒ†ãƒ¼ãƒˆé¸æŠžã‚³ãƒ³ãƒœãƒœãƒƒã‚¯ã‚¹
                    auto stateNames = stateMachine_->GetAllStateNames();
                    if (ImGui::BeginCombo("Select State", selectedStateName.c_str())) {
                        for (const auto& name : stateNames) {
                            bool isSelected = (selectedStateName == name);

                            // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¹ãƒ†ãƒ¼ãƒˆã«ã¯â˜…ãƒžãƒ¼ã‚¯ã‚’ä»˜ã‘ã‚‹
                            std::string displayName = name;
                            if (currentState && currentState->GetName() == name) {
                                displayName = name + " [ACTIVE]";
                            }

                            if (ImGui::Selectable(displayName.c_str(), isSelected)) {
                                selectedStateName = name;
                            }
                            if (isSelected) {
                                ImGui::SetItemDefaultFocus();
                            }
                        }
                        ImGui::EndCombo();
                    }

                    ImGui::Separator();

                    // é¸æŠžã•ã‚ŒãŸã‚¹ãƒ†ãƒ¼ãƒˆã®è©³ç´°è¡¨ç¤º
                    PlayerState* selectedState = stateMachine_->GetState(selectedStateName);
                    if (selectedState) {
                        // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ãƒˆãªã‚‰ç·‘è‰²ã€ãã†ã§ãªã‘ã‚Œã°é’è‰²ã§ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º
                        if (currentState && currentState->GetName() == selectedStateName) {
                            ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.1f, 0.4f, 0.1f, 1.0f));
                        }
                        else {
                            ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.2f, 0.3f, 0.4f, 1.0f));
                        }

                        if (ImGui::CollapsingHeader((selectedStateName + " State Details").c_str(),
                            ImGuiTreeNodeFlags_DefaultOpen)) {
                            // é¸æŠžã•ã‚ŒãŸã‚¹ãƒ†ãƒ¼ãƒˆã®DrawImGuiã‚’å‘¼ã³å‡ºã—
                            selectedState->DrawImGui(this);
                        }
                        ImGui::PopStyleColor();
                    }

                    ImGui::TreePop();
                }

                ImGui::Separator();

                // ã‚¹ãƒ†ãƒ¼ãƒˆæ‰‹å‹•åˆ‡ã‚Šæ›¿ãˆï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                if (ImGui::TreeNode("Manual State Change")) {
                    if (ImGui::Button("Idle")) stateMachine_->ChangeState("Idle");
                    ImGui::SameLine();
                    if (ImGui::Button("Move")) stateMachine_->ChangeState("Move");
                    ImGui::SameLine();
                    if (ImGui::Button("Dash")) stateMachine_->ChangeState("Dash");

                    if (ImGui::Button("Attack")) stateMachine_->ChangeState("Attack");
                    ImGui::SameLine();
                    if (ImGui::Button("Shoot")) stateMachine_->ChangeState("Shoot");
                    ImGui::SameLine();
                    if (ImGui::Button("Parry")) stateMachine_->ChangeState("Parry");

                    ImGui::TreePop();
                }
            }

            ImGui::EndTabItem();
        }

        // ========== Combat ã‚¿ãƒ– ==========
        if (ImGui::BeginTabItem("Combat")) {
            selectedTab = 2;

            // Body Collider
            if (ImGui::TreeNode("Body Collider")) {
                if (bodyCollider_) {
                    bool isActive = bodyCollider_->IsActive();
                    if (ImGui::Checkbox("Active", &isActive)) {
                        bodyCollider_->SetActive(isActive);
                    }

                    // å®Ÿéš›ã®ä¸­å¿ƒåº§æ¨™ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰
                    Vector3 actualCenter = bodyCollider_->GetCenter();
                    ImGui::Text("Actual Center: (%.2f, %.2f, %.2f)",
                        actualCenter.x, actualCenter.y, actualCenter.z);

                    // ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆèª¿æ•´å¯èƒ½ï¼‰
                    Vector3 offset = bodyCollider_->GetOffset();
                    if (ImGui::DragFloat3("Offset", &offset.x, 0.1f)) {
                        bodyCollider_->SetOffset(offset);
                    }

                    Vector3 size = bodyCollider_->GetSize();
                    if (ImGui::DragFloat3("Size", &size.x, 0.1f, 0.1f, 10.0f)) {
                        bodyCollider_->SetSize(size);
                    }
                }
                ImGui::TreePop();
            }

            // Attack Collider
            if (ImGui::TreeNode("Attack Collider")) {
                if (meleeAttackCollider_) {
                    bool isActive = meleeAttackCollider_->IsActive();
                    ImGui::Text("Active: %s", isActive ? "YES" : "NO");

                    // å®Ÿéš›ã®ä¸­å¿ƒåº§æ¨™ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰
                    Vector3 actualCenter = meleeAttackCollider_->GetCenter();
                    ImGui::Text("Actual Center: (%.2f, %.2f, %.2f)",
                        actualCenter.x, actualCenter.y, actualCenter.z);

                    // ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆèª¿æ•´å¯èƒ½ï¼‰
                    Vector3 offset = meleeAttackCollider_->GetOffset();
                    if (ImGui::DragFloat3("Offset", &offset.x, 0.1f)) {
                        meleeAttackCollider_->SetOffset(offset);
                    }

                    // ã‚µã‚¤ã‚ºï¼ˆèª¿æ•´å¯èƒ½ï¼‰
                    Vector3 size = meleeAttackCollider_->GetSize();
                    if (ImGui::DragFloat3("Size", &size.x, 0.1f, 0.1f, 50.0f)) {
                        meleeAttackCollider_->SetSize(size);
                    }

                    ImGui::Separator();
                    Boss* detectedEnemy = meleeAttackCollider_->GetDetectedEnemy();
                    if (detectedEnemy) {
                        ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Enemy Detected!");
                    }
                    else {
                        ImGui::Text("No Enemy Detected");
                    }
                    ImGui::Text("Collision Count: %d", meleeAttackCollider_->GetCollisionCount());
                }
                ImGui::TreePop();
            }

            // Combat Parameters
            if (ImGui::TreeNode("Combat Parameters")) {
                ImGui::SliderFloat("Attack Move Speed", &attackMoveSpeed_, 0.5f, 10.0f);
                ImGui::SliderFloat("Attack Start Distance", &attackMinDist_, 1.0f, 10.0f);
                ImGui::SliderFloat("Attack Move Rotation Lerp", &attackMoveRotationLerp_, 0.01f, 1.0f);
                ImGui::SliderFloat("Boss Lookat Lerp", &bossLookatLerp_, 0.01f, 2.0f);
                ImGui::TreePop();
            }

            // Initial Position (èª¿æ•´ç”¨)
            if (ImGui::TreeNode("Initial Position")) {
                ImGui::DragFloat("Initial Y", &initialY_, 0.1f, 0.0f, 10.0f);
                ImGui::DragFloat("Initial Z", &initialZ_, 1.0f, -200.0f, 0.0f);
                ImGui::TreePop();
            }

            ImGui::EndTabItem();
        }

        // ========== Physics ã‚¿ãƒ– ==========
        if (ImGui::BeginTabItem("Physics")) {
            selectedTab = 3;

            // Velocity
            ImGui::Text("Velocity");
            ImGui::Text("X: %.3f, Y: %.3f, Z: %.3f", velocity_.x, velocity_.y, velocity_.z);
            ImGui::Text("Magnitude: %.3f", velocity_.Length());

            // Velocity Graph
            static float velocityHistory[100] = { 0 };
            static int historyOffset = 0;
            velocityHistory[historyOffset] = velocity_.Length();
            historyOffset = (historyOffset + 1) % 100;
            ImGui::PlotLines("Velocity History", velocityHistory, 100, historyOffset, nullptr, 0.0f, 20.0f, ImVec2(0, 80));

            ImGui::Separator();

            // Target Angle
            ImGui::Text("Target Angle: %.2f degrees", targetAngle_ * 180.0f / 3.14159f);
            ImGui::Text("Current Y Rotation: %.2f degrees", transform_.rotate.y * 180.0f / 3.14159f);

            ImGui::Separator();

            // Movement Direction Visualization
            if (ImGui::TreeNode("Movement Visualization")) {
                float angle = transform_.rotate.y;
                ImDrawList* draw_list = ImGui::GetWindowDrawList();
                ImVec2 center = ImGui::GetCursorScreenPos();
                center.x += 50;
                center.y += 50;

                // Draw circle
                draw_list->AddCircle(center, 40, IM_COL32(100, 100, 100, 255));

                // Draw direction arrow
                float arrowX = cosf(angle) * 35;
                float arrowY = sinf(angle) * 35;
                draw_list->AddLine(center,
                    ImVec2(center.x + arrowX, center.y - arrowY),
                    IM_COL32(0, 255, 0, 255), 3.0f);

                ImGui::Dummy(ImVec2(100, 100));
                ImGui::TreePop();
            }

            ImGui::EndTabItem();
        }

        // ========== Debug ã‚¿ãƒ– ==========
        if (ImGui::BeginTabItem("Debug")) {
            selectedTab = 4;

            // Input Status
            if (ImGui::TreeNode("Input Status")) {
                if (inputHandlerPtr_) {
                    bool moving = inputHandlerPtr_->IsMoving();
                    bool attacking = inputHandlerPtr_->IsAttacking();
                    bool shooting = inputHandlerPtr_->IsShooting();
                    bool dashing = inputHandlerPtr_->IsDashing();
                    bool parrying = inputHandlerPtr_->IsParrying();

                    ImGui::Text("Moving: %s", moving ? "âœ“" : "âœ—");
                    ImGui::Text("Attacking: %s", attacking ? "âœ“" : "âœ—");
                    ImGui::Text("Shooting: %s", shooting ? "âœ“" : "âœ—");
                    ImGui::Text("Dashing: %s", dashing ? "âœ“" : "âœ—");
                    ImGui::Text("Parrying: %s", parrying ? "âœ“" : "âœ—");
                }
                ImGui::TreePop();
            }

            // Model Debug
            ImGui::Separator();
            if (ImGui::Button("Show Model Debug Info")) isDisModelDebugInfo_ = !isDisModelDebugInfo_;

            // Animation Control (TODO)
            if (ImGui::TreeNode("Animation Control")) {
                ImGui::Text("TODO: Animation system integration");
                // å°†æ¥çš„ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡UIã‚’è¿½åŠ 
                ImGui::TreePop();
            }

            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }

    if (isDisModelDebugInfo_) {
        model_->DrawImGui();
    }

#endif
}

bool Player::CanShoot() const
{
    if (isDead_) return false;
    if (targetEnemy_->GetPhase() == 2) return false; // ãƒ•ã‚§ãƒ¼ã‚º2ã§ã¯å°„æ’ƒä¸å¯

    return true;
}

void Player::SetDynamicBounds(float xMin, float xMax, float zMin, float zMax)
{
    dynamicXMin_ = xMin;
    dynamicXMax_ = xMax;
    dynamicZMin_ = zMin;
    dynamicZMax_ = zMax;
}

void Player::SetDynamicBoundsFromCenter(const Vector3& center, float xRange, float zRange)
{
    dynamicXMin_ = center.x - xRange;
    dynamicXMax_ = center.x + xRange;
    dynamicZMin_ = center.z - zRange;
    dynamicZMax_ = center.z + zRange;
}

void Player::ClearDynamicBounds()
{
    // éžå¸¸ã«å¤§ããªå€¤ã«è¨­å®šã—ã¦å®Ÿè³ªçš„ã«ç„¡åŠ¹åŒ–
    dynamicXMin_ = -kBoundaryDisabled;
    dynamicXMax_ = kBoundaryDisabled;
    dynamicZMin_ = -kBoundaryDisabled;
    dynamicZMax_ = kBoundaryDisabled;
}

void Player::RequestBulletSpawn(const Vector3& position, const Vector3& velocity)
{
    pendingBullets_.push_back({ position, velocity });
}

std::vector<Player::BulletSpawnRequest> Player::ConsumePendingBullets()
{
    return std::move(pendingBullets_);
}

============================================================
File Path: GameProject/Object/Player/Player.h
============================================================
#pragma once
#include <memory>
#include <vector>

#include "Collider.h"
#include "Transform.h"
#include "vector2.h"
#include "Vector3.h"

class Sprite;
class OBBCollider;
class Object3d;
class PlayerStateMachine;
class InputHandler;
class Camera;
class MeleeAttackCollider;
class Boss;

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹
/// ç§»å‹•ã€æ”»æ’ƒã€ã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†ãªã©ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹•ä½œã‚’åˆ¶å¾¡
/// </summary>
class Player
{
	//=========================================================================================
	// å®šæ•°
	//=========================================================================================
private:
	static constexpr float kVelocityEpsilon = 0.01f;   ///< é€Ÿåº¦åˆ¤å®šã®é–¾å€¤
	static constexpr float kBoundaryDisabled = 9999.0f; ///< å¢ƒç•Œç„¡åŠ¹åŒ–ãƒžãƒ¼ã‚«ãƒ¼
    // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ç”¨å®šæ•°
    static constexpr float kMoveArrivalThreshold = 0.5f;
    static constexpr float kMoveEasingCoeffA = 3.0f;
    static constexpr float kMoveEasingCoeffB = 2.0f;
    static constexpr float kDirectionEpsilon = 0.01f;

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    Player();
    ~Player();

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    void Initialize();

    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize();

    /// <summary>
    /// æ›´æ–°
    /// </summary>
    void Update();

    /// <summary>
    /// æç”»
    /// </summary>
    void Draw();

    /// <summary>
    /// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    /// </summary>
    void DrawSprite();

    /// <summary>
    /// ç§»å‹•
    /// </summary>
    /// <param name="speedMultiplier">é€Ÿåº¦å€çŽ‡ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ1.0ï¼‰</param>
    /// <param name="isApplyDirCalulate"> æ–¹å‘è¨ˆç®—ã‚’é©ç”¨ã™ã‚‹ã‹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆtrueï¼‰</param>
    void Move(float speedMultiplier = 1.0f, bool isApplyDirCalulate = true);

    /// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ç§»å‹•ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ç§»å‹•ï¼‰
    /// </summary>
    /// <param name="target">ç§»å‹•å…ˆã®ãƒœã‚¹ã‚¨ãƒãƒŸãƒ¼</param>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
    void MoveToTarget(Boss* target, float deltaTime);

    /// <summary>
    /// MoveToTargetã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void ResetMoveToTarget();

    /// <summary>
    /// ç›®æ¨™ä½ç½®ã«åˆ°é”ã—ãŸã‹åˆ¤å®š
    /// </summary>
    /// <returns>true: åˆ°é”, false: æœªåˆ°é”</returns>
    bool HasReachedTarget() const;

    /// <summary>
    /// ImGuiã®æç”»
    /// </summary>
    void DrawImGui();

    /// <summary>
    /// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®åˆæœŸè¨­å®š
    /// </summary>
    void SetupColliders();

    /// <summary>
    /// æ”»æ’ƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®æ›´æ–°
    /// </summary>
    void UpdateAttackCollider();

    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ã‚º2æ™‚ã«ãƒœã‚¹æ–¹å‘ã‚’å‘ã
    /// </summary>
    void LookAtBoss();

    /// <summary>
    /// è¿‘æŽ¥æ”»æ’ƒãƒ’ãƒƒãƒˆæ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    void OnHit(float damage);

    //-----------------------------Getters/Setters------------------------------//
    /// <summary>
    /// ç§»å‹•é€Ÿåº¦ã‚’è¨­å®š
    /// </summary>
    /// <param name="speed">æ–°ã—ã„ç§»å‹•é€Ÿåº¦</param>
    void SetSpeed(float speed) { speed_ = speed; }

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    /// </summary>
    /// <param name="camera">ä½¿ç”¨ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetCamera(Camera* camera) { camera_ = camera; }

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
    /// </summary>
    /// <param name="mode">true: ä¸€äººç§°è¦–ç‚¹, false: ãƒˆãƒƒãƒ—ãƒ€ã‚¦ãƒ³è¦–ç‚¹</param>
    void SetMode(bool mode) { mode_ = mode; }

    /// <summary>
    /// åº§æ¨™å¤‰æ›æƒ…å ±ã‚’è¨­å®š
    /// </summary>
    /// <param name="transform">æ–°ã—ã„åº§æ¨™å¤‰æ›æƒ…å ±</param>
    void SetTransform(const Transform& transform) { transform_ = transform; }

    /// <summary>
    /// å¹³è¡Œç§»å‹•æƒ…å ±ã‚’è¨­å®š
    /// </summary>
    /// <param name="translate">æ–°ã—ã„ä½ç½®æƒ…å ±</param>
    void SetTranslate(const Vector3& translate) { transform_.translate = translate; }

    /// <summary>
    /// å›žè»¢æƒ…å ±ã‚’è¨­å®š
    /// </summary>
    /// <param name="rotate">æ–°ã—ã„å›žè»¢æƒ…å ±ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</param>
    void SetRotate(const Vector3& rotate) { transform_.rotate = rotate; }

    /// <summary>
    /// ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’è¨­å®š
    /// </summary>
    /// <param name="scale">æ–°ã—ã„ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±</param>
    void SetScale(const Vector3& scale) { transform_.scale = scale; }

    /// <summary>
    /// HPã‚’è¨­å®š
    /// </summary>
    /// <param name="hp">æ–°ã—ã„HPå€¤ï¼ˆ0æœªæº€ã¯0ã«è£œæ­£ï¼‰</param>
    void SetHp(float hp) { hp_ = hp; if (hp_ < 0.f) hp_ = 0.f; }

    /// <summary>
    /// ç„¡æ•µãƒ•ãƒ©ã‚°ã‚’è¨­å®š
    /// </summary>
    /// <param name="isInvincible">æ–°ã—ã„ç„¡æ•µãƒ•ãƒ©ã‚°ã®å€¤</param>
    void SetInvincible(bool isInvincible) { isInvincible_ = isInvincible; }

    /// <summary>
    /// å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ã‚’è¨­å®š
    /// </summary>
    void SetInputHandler(InputHandler* inputHandler) { inputHandlerPtr_ = inputHandler; }

    /// <summary>
    /// ç§»å‹•é€Ÿåº¦ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ç§»å‹•é€Ÿåº¦</returns>
    float GetSpeed() const { return speed_; }

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    Camera* GetCamera() const { return camera_; }

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã‚’å–å¾—
    /// </summary>
    /// <returns>true: ä¸€äººç§°è¦–ç‚¹, false: ãƒˆãƒƒãƒ—ãƒ€ã‚¦ãƒ³è¦–ç‚¹</returns>
    bool GetMode() const { return mode_; }

    /// <summary>
    /// HPã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®HPå€¤</returns>
    float GetHp() const { return hp_; }

    /// <summary>
    /// æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’å–å¾—
    /// </summary>
    /// <returns>true: æ­»äº¡, false: ç”Ÿå­˜</returns>
    bool IsDead() const { return isDead_; }

    /// <summary>
    /// ç„¡æ•µãƒ•ãƒ©ã‚°ã‚’å–å¾—
    /// </summary>
    /// <returns>true: ç„¡æ•µ, false: é€šå¸¸çŠ¶æ…‹</returns>
    bool IsInvincible() const{ return isInvincible_; }

    /// <summary>
    /// Shootã§ãã‚‹ã‹
    /// </summary>
    /// <returns>true: å¯èƒ½, false: ä¸å¯èƒ½</returns>
    bool CanShoot() const;

    /// <summary>
    /// åº§æ¨™å¤‰æ›æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®åº§æ¨™å¤‰æ›æƒ…å ±ã®å‚ç…§</returns>
    const Transform& GetTransform() const { return transform_; }

    /// <summary>
    /// åº§æ¨™å¤‰æ›æƒ…å ±ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—
    /// </summary>
    /// <returns>åº§æ¨™å¤‰æ›æƒ…å ±ã¸ã®éžconstãƒã‚¤ãƒ³ã‚¿</returns>
    Transform* GetTransformPtr() { return &transform_; }

    /// <summary>
    /// å¹³è¡Œç§»å‹•æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ä½ç½®æƒ…å ±ã®å‚ç…§</returns>
    Vector3 GetTranslate() const { return transform_.translate; }

    /// <summary>
    /// å›žè»¢æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®å›žè»¢æƒ…å ±ã®å‚ç…§ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</returns>
    Vector3 GetRotate() const { return transform_.rotate; }

    /// <summary>
    /// ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã®å‚ç…§</returns>
    Vector3 GetScale() const { return transform_.scale; }

    /// <summary>
    /// 3Dãƒ¢ãƒ‡ãƒ«ã‚’å–å¾—
    /// </summary>
    /// <returns>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    Object3d* GetModel() const { return model_.get(); }

    /// <summary>
    /// ã‚¹ãƒ†ãƒ¼ãƒˆãƒžã‚·ãƒ³ã‚’å–å¾—
    /// </summary>
    /// <returns>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒˆãƒžã‚·ãƒ³ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    PlayerStateMachine* GetStateMachine() const { return stateMachine_.get(); }

    /// <summary>
    /// è¿‘æŽ¥æ”»æ’ƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å–å¾—
    /// </summary>
    /// <returns>è¿‘æŽ¥æ”»æ’ƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</returns>
    MeleeAttackCollider* GetMeleeAttackCollider() const { return meleeAttackCollider_.get(); }

    /// <summary>
    /// æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã‚’å–å¾—
    /// </summary>
    /// <returns>æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã®Object3dãƒã‚¤ãƒ³ã‚¿</returns>
    Object3d* GetAttackBlock() const { return attackBlock_.get(); }

    /// <summary>
    /// æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã®è¡¨ç¤º/éžè¡¨ç¤ºã‚’è¨­å®š
    /// </summary>
    /// <param name="visible">true: è¡¨ç¤º, false: éžè¡¨ç¤º</param>
    void SetAttackBlockVisible(bool visible) { attackBlockVisible_ = visible; }

    /// <summary>
    /// æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ãŒè¡¨ç¤ºä¸­ã‹å–å¾—
    /// </summary>
    /// <returns>true: è¡¨ç¤ºä¸­, false: éžè¡¨ç¤º</returns>
    bool IsAttackBlockVisible() const { return attackBlockVisible_; }

    /// <summary>
    /// Velocityã‚’å–å¾—
    /// </summary>
    /// <returns>ç¾åœ¨ã®Velocityå€¤ã®å‚ç…§</returns>
    Vector3& GetVelocity() { return velocity_; }

    /// <summary>
    /// InputHandlerã‚’å–å¾—
    /// </summary>
    /// <returns>InputHandlerã®ãƒã‚¤ãƒ³ã‚¿</returns>
    InputHandler* GetInputHandler() { return inputHandlerPtr_; };

    /// <summary>
    /// å‹•çš„ç§»å‹•ç¯„å›²ã‚’è¨­å®š
    /// </summary>
    /// <param name="xMin">Xåº§æ¨™ã®æœ€å°å€¤</param>
    /// <param name="xMax">Xåº§æ¨™ã®æœ€å¤§å€¤</param>
    /// <param name="zMin">Zåº§æ¨™ã®æœ€å°å€¤</param>
    /// <param name="zMax">Zåº§æ¨™ã®æœ€å¤§å€¤</param>
    void SetDynamicBounds(float xMin, float xMax, float zMin, float zMax);

    /// <summary>
    /// ä¸­å¿ƒç‚¹ã¨ç¯„å›²ã‹ã‚‰å‹•çš„ç§»å‹•ç¯„å›²ã‚’è¨­å®š
    /// </summary>
    /// <param name="center">ä¸­å¿ƒåº§æ¨™</param>
    /// <param name="xRange">Xæ–¹å‘ã®ç¯„å›²ï¼ˆç‰‡å´ï¼‰</param>
    /// <param name="zRange">Zæ–¹å‘ã®ç¯„å›²ï¼ˆç‰‡å´ï¼‰</param>
    void SetDynamicBoundsFromCenter(const Vector3& center, float xRange, float zRange);

    /// <summary>
    /// å‹•çš„ç§»å‹•ç¯„å›²ã‚’ã‚¯ãƒªã‚¢ï¼ˆç„¡åŠ¹åŒ–ï¼‰
    /// </summary>
    void ClearDynamicBounds();

    /// <summary>
    /// Bossã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«è¨­å®š
    /// </summary>
    void SetBoss(Boss* target) { targetEnemy_ = target; }

    /// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®Bossã‚’å–å¾—
    /// </summary>
    /// <returns>Bossã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆæœªè¨­å®šãªã‚‰nullptrï¼‰</returns>
    Boss* GetBoss() const { return targetEnemy_; }

    //-----------------------------å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ ------------------------------//
    /// <summary>
    /// å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆæ§‹é€ ä½“
    /// </summary>
    struct BulletSpawnRequest {
        Vector3 position;  ///< ç™ºå°„ä½ç½®
        Vector3 velocity;  ///< å¼¾ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
    };

    /// <summary>
    /// å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¿½åŠ 
    /// </summary>
    /// <param name="position">ç™ºå°„ä½ç½®</param>
    /// <param name="velocity">å¼¾ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«</param>
    void RequestBulletSpawn(const Vector3& position, const Vector3& velocity);

    /// <summary>
    /// ä¿ç•™ä¸­ã®å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å–å¾—ã—ã¦æ¶ˆè²»
    /// </summary>
    /// <returns>å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒªã‚¹ãƒˆ</returns>
    std::vector<BulletSpawnRequest> ConsumePendingBullets();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

    // å‹•çš„ç§»å‹•åˆ¶é™ï¼ˆãƒœã‚¹è¿‘æŽ¥æˆ¦é—˜ã‚¨ãƒªã‚¢ï¼‰
    float dynamicXMin_;
    float dynamicXMax_;
    float dynamicZMin_;
    float dynamicZMax_;

    std::unique_ptr<Object3d> model_; ///< ãƒ¢ãƒ‡ãƒ«
    Camera* camera_ = nullptr;        ///< ã‚«ãƒ¡ãƒ©
    Transform transform_{};           ///< å¤‰å½¢æƒ…å ±
    Vector3 velocity_{};              ///< é€Ÿåº¦
    float speed_ = 0.5f;              ///< ç§»å‹•é€Ÿåº¦
    float targetAngle_ = 0.f;         ///< ç›®æ¨™è§’åº¦
    float hp_ = 100.f;                ///< ä½“åŠ›
    bool isDead_ = false;             ///< æ­»äº¡ãƒ•ãƒ©ã‚°

    bool mode_ = false;               ///< true: ThirdPersonMode, false: TopDownMode
    bool isDisModelDebugInfo_ = false;///< ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®è¡¨ç¤º

    bool isInvincible_ = false;       ///< ç„¡æ•µãƒ•ãƒ©ã‚°

    // ã‚·ã‚¹ãƒ†ãƒ 
    std::unique_ptr<PlayerStateMachine> stateMachine_;
    InputHandler* inputHandlerPtr_;

    // Colliders
    std::unique_ptr<OBBCollider> bodyCollider_;
    std::unique_ptr<MeleeAttackCollider> meleeAttackCollider_;

    // æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯
    std::unique_ptr<Object3d> attackBlock_;  ///< æ”»æ’ƒæ™‚ã«è¡¨ç¤ºã•ã‚Œã‚‹å›žè»¢ãƒ–ãƒ­ãƒƒã‚¯
    bool attackBlockVisible_ = false;         ///< æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯è¡¨ç¤ºãƒ•ãƒ©ã‚°

    // æ”»æ’ƒé–¢é€£
    Boss* targetEnemy_ = nullptr;
    bool isAttackHit_ = false;
    float attackMoveSpeed_ = 2.0f;

    // MoveToTargetç”¨ã®çŠ¶æ…‹ç®¡ç†
    Vector3 moveStartPosition_;           ///< ç§»å‹•é–‹å§‹ä½ç½®
    Vector3 moveTargetPosition_;          ///< ç§»å‹•ç›®æ¨™ä½ç½®
    float moveElapsedTime_ = 0.0f;        ///< ç§»å‹•çµŒéŽæ™‚é–“
    float moveDuration_ = 0.0f;           ///< ç§»å‹•æ‰€è¦æ™‚é–“
    bool isMoveInitialized_ = false;      ///< ç§»å‹•åˆæœŸåŒ–æ¸ˆã¿ãƒ•ãƒ©ã‚°

    // å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ
    std::vector<BulletSpawnRequest> pendingBullets_;

    // è¢«å¼¾Vignetteã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    float damageVignetteTimer_ = 0.0f;                       ///< Vignetteãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¿ã‚¤ãƒžãƒ¼
    static constexpr float kDamageVignetteDuration_ = 0.25f; ///< ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆæ™‚é–“
    static constexpr float kDamageVignettePower_ = 0.2f;     ///< åˆæœŸVignetteå¼·åº¦
    static constexpr float kDamageVignetteRange_ = 45.0f;    ///< Vignetteç¯„å›²

    // èª¿æ•´å¯èƒ½ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆImGuiç·¨é›†ç”¨ï¼‰
    float initialY_ = 2.5f;                   ///< åˆæœŸYåº§æ¨™
    float initialZ_ = -120.0f;                ///< åˆæœŸZåº§æ¨™
    float attackMinDist_ = 10.0f;              ///< æ”»æ’ƒé–‹å§‹è·é›¢
    float attackMoveRotationLerp_ = 0.3f;     ///< æ”»æ’ƒç§»å‹•ä¸­ã®å›žè»¢è£œé–“é€Ÿåº¦
    float bossLookatLerp_ = 1.15f;            ///< ãƒœã‚¹è¦–ç·šè¿½å¾“è£œé–“é€Ÿåº¦

    // HPãƒãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
    std::unique_ptr<Sprite> hpBarSprite_;
    std::unique_ptr<Sprite> hpBarBGSprite_;
    Vector2 hpBarSize_{};

    // HPãƒãƒ¼ç”»é¢ä½ç½®ï¼ˆãƒ¡ãƒ³ãƒãƒ¼å¤‰æ•°ï¼‰
    float hpBarScreenXRatio_ = 0.35f;   ///< HPãƒãƒ¼Xåº§æ¨™ï¼ˆç”»é¢å¹…ã«å¯¾ã™ã‚‹æ¯”çŽ‡ï¼‰
    float hpBarScreenYRatio_ = 0.05f;   ///< HPãƒãƒ¼Yåº§æ¨™ï¼ˆç”»é¢é«˜ã•ã«å¯¾ã™ã‚‹æ¯”çŽ‡ï¼‰

    // HPæœ€å¤§å€¤
    static constexpr float kMaxHp = 100.0f;  ///< HPæœ€å¤§å€¤
};



============================================================
File Path: GameProject/Object/Player/State/AttackState.cpp
============================================================
#include "AttackState.h"
#include "PlayerStateMachine.h"
#include "../Player.h"
#include "Input/InputHandler.h"
#include "../../../Collision/MeleeAttackCollider.h"
#include "../../Boss/Boss.h"
#include "CollisionManager.h"
#include "Object3d.h"
#include "GlobalVariables.h"
#include <cmath>

#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

void AttackState::Enter(Player* player)
{
    // æ”»æ’ƒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
    // TODO: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆå¾Œã«å®Ÿè£…
    // player->GetModel()->PlayAnimation("Attack" + std::to_string(comboCount_));

    attackTimer_ = 0.0f;
    searchTimer_ = 0.0f;
    moveTimer_ = 0.0f;
    canCombo_ = false;
    phase_ = SearchTarget;
    targetEnemy_ = nullptr;

    // æ”»æ’ƒç¯„å›²Colliderã‚’æœ‰åŠ¹åŒ–
    if (player->GetMeleeAttackCollider()) {
        player->GetMeleeAttackCollider()->SetActive(true);
        player->GetMeleeAttackCollider()->Reset();
    }

    // æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã‚’è¡¨ç¤ºã—ã¦åˆæœŸä½ç½®è¨­å®š
    if (player->GetAttackBlock()) {
        player->SetAttackBlockVisible(true);
        blockAngle_ = GetStartAngle();
        UpdateBlockPosition(player);
    }

    // MoveToTargetçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    player->ResetMoveToTarget();

    // SearchForTargetã¯Updateã®SearchTargetãƒ•ã‚§ãƒ¼ã‚ºã§å‘¼ã°ã‚Œã‚‹
}

void AttackState::Update(Player* player, float deltaTime)
{
    // GlobalVariablesã‹ã‚‰å€¤ã‚’åŒæœŸ
    GlobalVariables* gv = GlobalVariables::GetInstance();
    maxSearchTime_ = gv->GetValueFloat("AttackState", "SearchTime");
    maxMoveTime_ = gv->GetValueFloat("AttackState", "MoveTime");
    attackDuration_ = gv->GetValueFloat("AttackState", "AttackDuration");
    maxCombo_ = gv->GetValueInt("AttackState", "MaxCombo");
    comboWindow_ = gv->GetValueFloat("AttackState", "ComboWindow");
    blockRadius_ = gv->GetValueFloat("AttackState", "BlockRadius");
    blockScale_ = gv->GetValueFloat("AttackState", "BlockScale");

    switch (phase_) {
    case SearchTarget:
        // å¾…æ©Ÿæ™‚é–“ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        searchTimer_ += deltaTime;

        // æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ•µã‚’æ¤œç´¢
        SearchForTarget(player);

        // ä¸€å®šæ™‚é–“å¾…æ©Ÿå¾Œã€æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã¸
        if (searchTimer_ >= maxSearchTime_) {
            if (targetEnemy_) {
                phase_ = MoveToTarget;
            }
            else {
                phase_ = ExecuteAttack;
            }
        }
        break;

    case MoveToTarget:
        ProcessMoveToTarget(player, deltaTime);
        break;

    case ExecuteAttack:
        ProcessExecuteAttack(player, deltaTime);
        break;

    case Recovery:
        attackTimer_ += deltaTime;
        if (attackTimer_ >= attackDuration_) {
            PlayerStateMachine* stateMachine = player->GetStateMachine();
            if (stateMachine) {
                stateMachine->ChangeState("Idle");
            }
        }
        break;
    }
}

void AttackState::Exit(Player* player)
{
    // æ”»æ’ƒç¯„å›²Colliderã‚’ç„¡åŠ¹åŒ–
    if (player->GetMeleeAttackCollider()) {
        player->GetMeleeAttackCollider()->SetActive(false);
    }

    // æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯ã‚’éžè¡¨ç¤º
    player->SetAttackBlockVisible(false);

    // ã‚³ãƒ³ãƒœã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
    if (attackTimer_ >= attackDuration_) {
        comboCount_ = 0;
    }

    canCombo_ = false;

    targetEnemy_ = nullptr;
}

void AttackState::HandleInput(Player* player)
{
    InputHandler* input = player->GetInputHandler();
    if (!input) return;

    // æ”»æ’ƒå®Ÿè¡Œä¸­ã®ã¿ã‚³ãƒ³ãƒœå—ä»˜
    if (phase_ == ExecuteAttack && canCombo_ && input->IsAttacking() && comboCount_ < maxCombo_) {
        comboCount_ += 1;
        Enter(player); // æ¬¡ã®æ”»æ’ƒã‚’é–‹å§‹
    }
}

void AttackState::SearchForTarget(Player* player)
{
    if (!player->GetMeleeAttackCollider()) return;

    targetEnemy_ = player->GetMeleeAttackCollider()->GetDetectedEnemy();
}

void AttackState::ProcessMoveToTarget(Player* player, float deltaTime)
{
    if (!targetEnemy_) {
        phase_ = ExecuteAttack;
        return;
    }

    // ç§»å‹•å®Ÿè¡Œ
    player->MoveToTarget(targetEnemy_, deltaTime);

    // ä½ç½®ãƒ™ãƒ¼ã‚¹ã®çµ‚äº†åˆ¤å®š
    if (player->HasReachedTarget()) {
        phase_ = ExecuteAttack;
    }
}

void AttackState::ProcessExecuteAttack(Player* player, float deltaTime)
{
    attackTimer_ += deltaTime;

    // ãƒ–ãƒ­ãƒƒã‚¯ã‚’å›žè»¢ã•ã›ã‚‹ï¼ˆå¶æ•°ã‚³ãƒ³ãƒœ: +æ–¹å‘ã€å¥‡æ•°ã‚³ãƒ³ãƒœ: -æ–¹å‘ï¼‰
    float direction = (comboCount_ % 2 == 0) ? 1.0f : -1.0f;
    blockAngle_ += blockSwingAngle_ / attackDuration_ * deltaTime * direction;
    UpdateBlockPosition(player);

    // ã‚³ãƒ³ãƒœå—ä»˜æ™‚é–“ã®åˆ¤å®š
    if (attackTimer_ >= attackDuration_ - comboWindow_ && attackTimer_ < attackDuration_) {
        player->GetMeleeAttackCollider()->Damage();
        canCombo_ = true;
    }

    // æ”»æ’ƒæ™‚é–“ãŒçµ‚äº†ã—ãŸã‚‰ç¡¬ç›´ã¸
    if (attackTimer_ >= attackDuration_) {
        phase_ = Recovery;
        attackTimer_ = 0.0f;
    }
}

float AttackState::GetStartAngle() const
{
    // å¶æ•°ã‚³ãƒ³ãƒœ: å³å´é–‹å§‹ï¼ˆ-Ï€/2ï¼‰ã€å¥‡æ•°ã‚³ãƒ³ãƒœ: å·¦å´é–‹å§‹ï¼ˆÏ€/2ï¼‰
    return (comboCount_ % 2 == 0) ? -kBlockStartAngle : kBlockStartAngle;
}

void AttackState::UpdateBlockPosition(Player* player)
{
    Object3d* block = player->GetAttackBlock();
    if (!block) return;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã‚’è€ƒæ…®ã—ãŸå›žè»¢è§’åº¦
    float playerRotY = player->GetRotate().y;
    float worldAngle = playerRotY + blockAngle_;

    // ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã‚’è¨ˆç®—ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸­å¿ƒã‹ã‚‰åŠå¾„blockRadius_ã®å††å‘¨ä¸Šï¼‰
    Vector3 playerPos = player->GetTranslate();
    Vector3 blockPos = {
        playerPos.x + sinf(worldAngle) * blockRadius_,
        playerPos.y,
        playerPos.z + cosf(worldAngle) * blockRadius_
    };

    // ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ è¨­å®š
    Transform blockTransform;
    blockTransform.translate = blockPos;
    blockTransform.rotate = { 0.0f, worldAngle, 0.0f };
    blockTransform.scale = { blockScale_, blockScale_, blockScale_ };

    block->SetTransform(blockTransform);
}

void AttackState::DrawImGui(Player* player)
{
#ifdef _DEBUG
    ImGui::Text("=== Attack State Details ===");
    ImGui::Separator();

    // ãƒ•ã‚§ãƒ¼ã‚ºæƒ…å ±
    const char* phaseNames[] = { "SearchTarget", "MoveToTarget", "ExecuteAttack", "Recovery" };
    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Phase: %s", phaseNames[phase_]);

    // ã‚¿ã‚¤ãƒžãƒ¼æƒ…å ±
    if (ImGui::TreeNode("Timers")) {
        ImGui::Text("Search Timer: %.2f / %.2f", searchTimer_, maxSearchTime_);
        ImGui::ProgressBar(searchTimer_ / maxSearchTime_);

        ImGui::Text("Move Timer: %.2f / %.2f", moveTimer_, maxMoveTime_);
        ImGui::ProgressBar(moveTimer_ / maxMoveTime_);

        ImGui::Text("Attack Timer: %.2f / %.2f", attackTimer_, attackDuration_);
        ImGui::ProgressBar(attackTimer_ / attackDuration_);

        ImGui::TreePop();
    }

    // ã‚³ãƒ³ãƒœæƒ…å ±
    if (ImGui::TreeNode("Combo System")) {
        ImGui::Text("Combo Count: %d / %d", comboCount_, maxCombo_);
        ImGui::SliderInt("Max Combo", &maxCombo_, 1, 5);

        ImGui::Text("Combo Window: %.2f", comboWindow_);
        ImGui::SliderFloat("Combo Window", &comboWindow_, 0.1f, 2.0f);

        if (canCombo_) {
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Can Combo: YES");
        }
        else {
            ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Can Combo: NO");
        }

        ImGui::TreePop();
    }

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæƒ…å ±
    if (ImGui::TreeNode("Target Info")) {
        if (targetEnemy_) {
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Target: DETECTED");
            // TODO: ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®è©³ç´°æƒ…å ±ï¼ˆä½ç½®ã€è·é›¢ãªã©ï¼‰ã‚’è¡¨ç¤º
        }
        else {
            ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Target: NONE");
        }

        ImGui::TreePop();
    }

    // èª¿æ•´å¯èƒ½ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    if (ImGui::TreeNode("Attack Parameters")) {
        ImGui::SliderFloat("Attack Duration", &attackDuration_, 0.1f, 2.0f);
        ImGui::SliderFloat("Max Search Time", &maxSearchTime_, 0.05f, 1.0f);
        ImGui::SliderFloat("Max Move Time", &maxMoveTime_, 0.1f, 2.0f);

        ImGui::TreePop();
    }

    // ãƒ–ãƒ­ãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    if (ImGui::TreeNode("Block Parameters")) {
        ImGui::SliderFloat("Block Radius", &blockRadius_, 1.0f, 10.0f);
        ImGui::SliderFloat("Block Swing Angle", &blockSwingAngle_, 0.5f, 6.28f);
        ImGui::SliderFloat("Block Scale", &blockScale_, 0.1f, 2.0f);
        ImGui::Text("Current Block Angle: %.2f", blockAngle_);

        ImGui::TreePop();
    }
#endif
}

============================================================
File Path: GameProject/Object/Player/State/AttackState.h
============================================================
#pragma once
#include "PlayerState.h"

/// <summary>
/// æ”»æ’ƒçŠ¶æ…‹ã‚¯ãƒ©ã‚¹
/// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ¤œç´¢ã€ç§»å‹•ã€æ”»æ’ƒå®Ÿè¡Œã€ã‚³ãƒ³ãƒœç®¡ç†ã‚’åˆ¶å¾¡
/// </summary>
class AttackState : public PlayerState
{
	//=========================================================================================
	// å®šæ•°
	//=========================================================================================
private:
    static constexpr float kBlockStartAngle = 1.5708f;  ///< ãƒ–ãƒ­ãƒƒã‚¯é–‹å§‹è§’åº¦ï¼ˆÏ€/2ï¼‰

public:
	AttackState() : PlayerState("Attack") {}

	void Enter(Player* player) override;
	void Update(Player* player, float deltaTime) override;
	void Exit(Player* player) override;
	void HandleInput(Player* player) override;

private:
	/// <summary>
	/// æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚º
	/// </summary>
	enum AttackPhase {
		SearchTarget,    ///< ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ¤œç´¢ãƒ•ã‚§ãƒ¼ã‚º
		MoveToTarget,    ///< ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚º
		ExecuteAttack,   ///< æ”»æ’ƒå®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚º
		Recovery         ///< ç¡¬ç›´ãƒ•ã‚§ãƒ¼ã‚º
	};

	AttackPhase phase_ = SearchTarget;                ///< ç¾åœ¨ã®æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚º
	class Boss* targetEnemy_ = nullptr;               ///< æ”»æ’ƒå¯¾è±¡ã®ãƒœã‚¹
	float searchTimer_ = 0.0f;                        ///< SearchTargetå¾…æ©Ÿæ™‚é–“
	float maxSearchTime_ = 0.1f;                      ///< æœ€å¤§æ¤œç´¢æ™‚é–“
	float moveTimer_ = 0.0f;                          ///< ç§»å‹•ã‚¿ã‚¤ãƒžãƒ¼
	float maxMoveTime_ = 0.1f;                        ///< æœ€å¤§ç§»å‹•æ™‚é–“

	float attackTimer_ = 0.0f;                        ///< æ”»æ’ƒã‚¿ã‚¤ãƒžãƒ¼
	float attackDuration_ = 0.1f;                     ///< æ”»æ’ƒæŒç¶šæ™‚é–“
	int comboCount_ = 0;                              ///< ç¾åœ¨ã®ã‚³ãƒ³ãƒœæ•°
	int maxCombo_ = 2;                                ///< æœ€å¤§ã‚³ãƒ³ãƒœæ•°
	float comboWindow_ = 1.f;                         ///< ã‚³ãƒ³ãƒœå—ä»˜æ™‚é–“
	bool canCombo_ = false;                           ///< ã‚³ãƒ³ãƒœå¯èƒ½ãƒ•ãƒ©ã‚°

	// æ”»æ’ƒãƒ–ãƒ­ãƒƒã‚¯å›žè»¢åˆ¶å¾¡
	float blockAngle_ = 0.0f;                         ///< ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯å›žè»¢è§’åº¦
	float blockRadius_ = 4.0f;                        ///< ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®è·é›¢
	float blockSwingAngle_ = 3.14159f;                ///< æŒ¯ã‚Šå¹…ï¼ˆÏ€ = 180åº¦ï¼‰
	float blockScale_ = 0.5f;                         ///< ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¹ã‚±ãƒ¼ãƒ«

	/// <summary>
	/// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ¤œç´¢å‡¦ç†
	/// æ”»æ’ƒç¯„å›²å†…ã®æœ€ã‚‚è¿‘ã„æ•µã‚’æ¤œç´¢ã—ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«è¨­å®šã™ã‚‹
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void SearchForTarget(Player* player);

	/// <summary>
	/// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®ç§»å‹•å‡¦ç†
	/// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å‘ã‹ã£ã¦ç§»å‹•ã—ã€æ”»æ’ƒç¯„å›²å†…ã«åˆ°é”ã—ãŸã‚‰æ”»æ’ƒå®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	/// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
	void ProcessMoveToTarget(Player* player, float deltaTime);

	/// <summary>
	/// æ”»æ’ƒå®Ÿè¡Œå‡¦ç†
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šã€ã‚³ãƒ³ãƒœç®¡ç†ã‚’è¡Œã†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	/// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
	void ProcessExecuteAttack(Player* player, float deltaTime);

	/// <summary>
	/// ã‚³ãƒ³ãƒœæ•°ã«åŸºã¥ã„ã¦é–‹å§‹è§’åº¦ã‚’å–å¾—
	/// å¶æ•°ã‚³ãƒ³ãƒœ: å³å´é–‹å§‹ï¼ˆ-Ï€/2ï¼‰ã€å¥‡æ•°ã‚³ãƒ³ãƒœ: å·¦å´é–‹å§‹ï¼ˆÏ€/2ï¼‰
	/// </summary>
	/// <returns>é–‹å§‹è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</returns>
	float GetStartAngle() const;

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ä½ç½®ã‚’æ›´æ–°
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã¨å‘ãã«åŸºã¥ã„ã¦ãƒ–ãƒ­ãƒƒã‚¯ã®ä½ç½®ã‚’è¨ˆç®—
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void UpdateBlockPosition(Player* player);

public:
	/// <summary>
	/// ç¾åœ¨ã®æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚ºã‚’å–å¾—ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
	/// </summary>
	/// <returns>ç¾åœ¨ã®æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚º</returns>
	AttackPhase GetPhase() const { return phase_; }

	/// <summary>
	/// ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ•µã‚’å–å¾—ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
	/// </summary>
	/// <returns>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ•µã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆnullptrã®å ´åˆã‚‚ã‚ã‚‹ï¼‰</returns>
	Boss* GetTargetEnemy() const { return targetEnemy_; }

	/// <summary>
	/// æ”»æ’ƒã‚¿ã‚¤ãƒžãƒ¼ã‚’å–å¾—ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
	/// </summary>
	/// <returns>ç¾åœ¨ã®æ”»æ’ƒã‚¿ã‚¤ãƒžãƒ¼å€¤ï¼ˆç§’ï¼‰</returns>
	float GetAttackTimer() const { return attackTimer_; }

	/// <summary>
	/// æ¤œç´¢ã‚¿ã‚¤ãƒžãƒ¼ã‚’å–å¾—ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
	/// </summary>
	/// <returns>ç¾åœ¨ã®æ¤œç´¢ã‚¿ã‚¤ãƒžãƒ¼å€¤ï¼ˆç§’ï¼‰</returns>
	float GetSearchTimer() const { return searchTimer_; }

	/// <summary>
	/// ImGuiãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æç”»
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void DrawImGui(Player* player) override;

	// DrawImGuiç”¨ã®ã‚²ãƒƒã‚¿ãƒ¼è¿½åŠ 
	int GetComboCount() const { return comboCount_; }
	int GetMaxCombo() const { return maxCombo_; }
	float GetMoveTimer() const { return moveTimer_; }
	float GetMaxMoveTime() const { return maxMoveTime_; }
	float GetAttackDuration() const { return attackDuration_; }
	float GetComboWindow() const { return comboWindow_; }
	bool CanCombo() const { return canCombo_; }

	// DrawImGuiç”¨ã®ã‚»ãƒƒã‚¿ãƒ¼è¿½åŠ ï¼ˆãƒ‡ãƒãƒƒã‚°èª¿æ•´ç”¨ï¼‰
	void SetMaxCombo(int combo) { maxCombo_ = combo; }
	void SetAttackDuration(float duration) { attackDuration_ = duration; }
	void SetMaxMoveTime(float time) { maxMoveTime_ = time; }
	void SetComboWindow(float window) { comboWindow_ = window; }
};

============================================================
File Path: GameProject/Object/Player/State/DashState.cpp
============================================================
#include "DashState.h"
#include "PlayerStateMachine.h"
#include "../Player.h"
#include "Input/InputHandler.h"
#include "GlobalVariables.h"
#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

void DashState::Enter(Player* player)
{
	// ãƒ€ãƒƒã‚·ãƒ¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
	// TODO: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆå¾Œã«å®Ÿè£…
	// player->GetModel()->PlayAnimation("Dash");

	timer_ = 0.0f;
}

void DashState::Update(Player* player, float deltaTime)
{
	// GlobalVariablesã‹ã‚‰å€¤ã‚’åŒæœŸ
	GlobalVariables* gv = GlobalVariables::GetInstance();
	duration_ = gv->GetValueFloat("DashState", "Duration");
	speed_ = gv->GetValueFloat("DashState", "Speed");

	timer_ += deltaTime;

	// ãƒ€ãƒƒã‚·ãƒ¥ç§»å‹•å‡¦ç†
	player->Move(speed_);
	
	// ãƒ€ãƒƒã‚·ãƒ¥æ™‚é–“ãŒçµ‚äº†ã—ãŸã‚‰å…ƒã®çŠ¶æ…‹ã«æˆ»ã‚‹
	if (timer_ >= duration_)
	{
		PlayerStateMachine* stateMachine = player->GetStateMachine();
		if (stateMachine)
		{
			// ç§»å‹•å…¥åŠ›ãŒã‚ã‚Œã°Walkã€ãªã‘ã‚Œã°Idleã«é·ç§»
			InputHandler* input = player->GetInputHandler();
			if (input && input->IsMoving())
			{
				stateMachine->ChangeState("Move");
			}
			else
			{
				stateMachine->ChangeState("Idle");
			}
		}
	}
}

void DashState::Exit(Player* player)
{
	timer_ = 0.0f;
}

void DashState::HandleInput(Player* player)
{
	// ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã¯å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„
}

void DashState::DrawImGui(Player* player)
{
#ifdef _DEBUG
	ImGui::Text("=== Dash State Details ===");
	ImGui::Separator();

	// ãƒ€ãƒƒã‚·ãƒ¥é€²è¡ŒçŠ¶æ³
	float progress = (duration_ > 0.0f) ? (timer_ / duration_) : 0.0f;
	ImGui::Text("Dash Progress: %.1f%%", progress * 100.0f);
	ImGui::ProgressBar(progress);

	// ã‚¿ã‚¤ãƒžãƒ¼æƒ…å ±
	ImGui::Text("Timer: %.3f / %.3f", timer_, duration_);

	// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
	if (ImGui::TreeNode("Dash Parameters")) {
		ImGui::SliderFloat("Duration", &duration_, 0.01f, 0.5f, "%.3f");
		ImGui::SliderFloat("Speed", &speed_, 1.0f, 50.0f, "%.1f");

		// æŽ¨å¥¨å€¤ã®ãƒ—ãƒªã‚»ãƒƒãƒˆ
		if (ImGui::Button("Fast Dash")) {
			duration_ = 0.05f;
			speed_ = 10.0f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Long Dash")) {
			duration_ = 0.2f;
			speed_ = 5.0f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Teleport")) {
			duration_ = 0.01f;
			speed_ = 50.0f;
		}

		ImGui::TreePop();
	}

	// ãƒ‡ãƒãƒƒã‚°æƒ…å ±
	if (ImGui::TreeNode("Debug Info")) {
		ImGui::Text("Actual Distance: %.2f", timer_ * speed_);
		ImGui::Text("Frame Count: %d", (int)(timer_ * 60.0f));
		ImGui::TreePop();
	}
#endif
}

============================================================
File Path: GameProject/Object/Player/State/DashState.h
============================================================
#pragma once
#include "PlayerState.h"

/// <summary>
/// ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã‚¯ãƒ©ã‚¹
/// çŸ­æ™‚é–“ã®é«˜é€Ÿç§»å‹•ã‚’åˆ¶å¾¡
/// </summary>
class DashState : public PlayerState
{
public:
	DashState() : PlayerState("Dash") {}

	void Enter(Player* player) override;
	void Update(Player* player, float deltaTime) override;
	void Exit(Player* player) override;
	void HandleInput(Player* player) override;

	/// <summary>
	/// ImGuiãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æç”»
	/// </summary>
	void DrawImGui(Player* player) override;

	// DrawImGuiç”¨ã®ã‚²ãƒƒã‚¿ãƒ¼
	float GetTimer() const { return timer_; }
	float GetDuration() const { return duration_; }
	float GetSpeed() const { return speed_; }

	// DrawImGuiç”¨ã®ã‚»ãƒƒã‚¿ãƒ¼ï¼ˆãƒ‡ãƒãƒƒã‚°èª¿æ•´ç”¨ï¼‰
	void SetDuration(float duration) { duration_ = duration; }
	void SetSpeed(float speed) { speed_ = speed; }

private:
	float timer_ = 0.0f;        ///< ãƒ€ãƒƒã‚·ãƒ¥çµŒéŽæ™‚é–“
	float duration_ = 0.05f;    ///< ãƒ€ãƒƒã‚·ãƒ¥æŒç¶šæ™‚é–“
	float speed_ = 10.0f;       ///< ãƒ€ãƒƒã‚·ãƒ¥é€Ÿåº¦
};

============================================================
File Path: GameProject/Object/Player/State/IdleState.cpp
============================================================
#include "IdleState.h"
#include "PlayerStateMachine.h"
#include "../Player.h"
#include "Input.h"
#include "Input/InputHandler.h"
#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

void IdleState::Enter(Player* player)
{
	// ãƒ¢ãƒ‡ãƒ«ã®ã‚¢ã‚¤ãƒ‰ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
  // TODO: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆå¾Œã«å®Ÿè£…
	// player->GetModel()->PlayAnimation("Idle");
	idleTime_ = 0.0f;
}

void IdleState::Update(Player* player, float deltaTime)
{
	// ã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹ã§ã®å‡¦ç†
	idleTime_ += deltaTime;
}

void IdleState::Exit(Player* player)
{
	// ã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹çµ‚äº†æ™‚ã®å‡¦ç†
	idleTime_ = 0.0f;
}

void IdleState::HandleInput(Player* player)
{
	InputHandler* input = player->GetInputHandler();
	if (!input) return;
	
	PlayerStateMachine* stateMachine = player->GetStateMachine();
	if (!stateMachine) return;
	
	// å„ªå…ˆåº¦é †ã«çŠ¶æ…‹é·ç§»ã‚’ãƒã‚§ãƒƒã‚¯
	
	// ãƒ‘ãƒªã‚£
	if (input->IsParrying())
	{
		stateMachine->ChangeState("Parry");
		return;
	}
	
	// æ”»æ’ƒ
	if (input->IsAttacking())
	{
		stateMachine->ChangeState("Attack");
		return;
	}
	
	// å°„æ’ƒ
    if (input->IsShooting() && player->CanShoot())
	{
		stateMachine->ChangeState("Shoot");
		return;
	}
	
	// ãƒ€ãƒƒã‚·ãƒ¥
	if (input->IsDashing())
	{
		stateMachine->ChangeState("Dash");
		return;
	}
	
	// ç§»å‹•
	if (input->IsMoving())
	{
		stateMachine->ChangeState("Move");
		return;
	}
}

void IdleState::DrawImGui(Player* player)
{
#ifdef _DEBUG
	ImGui::Text("=== Idle State Details ===");
	ImGui::Separator();

	// å¾…æ©Ÿæ™‚é–“
	ImGui::Text("Idle Time: %.2f seconds", idleTime_);

	// å¾…æ©Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±
	if (ImGui::TreeNode("Animation Info")) {
		ImGui::Text("Animation: Idle");
		ImGui::Text("TODO: Add idle animation variations");
		ImGui::TreePop();
	}

	// åˆ©ç”¨å¯èƒ½ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
	if (ImGui::TreeNode("Available Actions")) {
		ImGui::BulletText("Press W/A/S/D to Move");
		ImGui::BulletText("Press Z to Attack");
		ImGui::BulletText("Press Left Ctrl to Shoot");
		ImGui::BulletText("Press Space to Dash");
		ImGui::BulletText("Press F to Parry");
		ImGui::TreePop();
	}
#endif
}

============================================================
File Path: GameProject/Object/Player/State/IdleState.h
============================================================
#pragma once
#include "PlayerState.h"

/// <summary>
/// å¾…æ©ŸçŠ¶æ…‹ã‚¯ãƒ©ã‚¹
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒä½•ã‚‚æ“ä½œã—ã¦ã„ãªã„æ™‚ã®çŠ¶æ…‹
/// </summary>
class IdleState : public PlayerState
{
public:
	IdleState() : PlayerState("Idle") {}

	/// <summary>
	/// å¾…æ©ŸçŠ¶æ…‹é–‹å§‹æ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void Enter(Player* player) override;

	/// <summary>
	/// å¾…æ©ŸçŠ¶æ…‹ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	/// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
	void Update(Player* player, float deltaTime) override;

	/// <summary>
	/// å¾…æ©ŸçŠ¶æ…‹çµ‚äº†æ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void Exit(Player* player) override;

	/// <summary>
	/// å¾…æ©ŸçŠ¶æ…‹ã§ã®å…¥åŠ›å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void HandleInput(Player* player) override;

	/// <summary>
	/// ImGuiãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æç”»
	/// </summary>
	void DrawImGui(Player* player) override;

private:
	float idleTime_ = 0.0f;  ///< å¾…æ©ŸçŠ¶æ…‹ã®ç¶™ç¶šæ™‚é–“
};

============================================================
File Path: GameProject/Object/Player/State/MoveState.cpp
============================================================
#include "MoveState.h"
#include "PlayerStateMachine.h"
#include "../Player.h"
#include "Input/InputHandler.h"
#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

void MoveState::Enter(Player* player)
{
	// ãƒ¢ãƒ‡ãƒ«ã®æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
  // TODO: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆå¾Œã«å®Ÿè£…
	// player->GetModel()->PlayAnimation("Walk");
	moveTime_ = 0.0f;
}

void MoveState::Update(Player* player, float deltaTime)
{
	// é€šå¸¸é€Ÿåº¦ã§ç§»å‹•
	player->Move(1.0f);
	moveTime_ += deltaTime;
}

void MoveState::Exit(Player* player)
{
	// æ­©è¡ŒçŠ¶æ…‹çµ‚äº†æ™‚ã®å‡¦ç†
	moveTime_ = 0.0f;
}

void MoveState::HandleInput(Player* player)
{
	InputHandler* input = player->GetInputHandler();
	if (!input) return;
	
	PlayerStateMachine* stateMachine = player->GetStateMachine();
	if (!stateMachine) return;
	
	// å„ªå…ˆåº¦é †ã«çŠ¶æ…‹é·ç§»ã‚’ãƒã‚§ãƒƒã‚¯
	
	// ãƒ‘ãƒªã‚£
	if (input->IsParrying())
	{
		stateMachine->ChangeState("Parry");
		return;
	}
	
	// æ”»æ’ƒ
	if (input->IsAttacking())
	{
		stateMachine->ChangeState("Attack");
		return;
	}
	
	// å°„æ’ƒ
    if (input->IsShooting() && player->CanShoot())
	{
		stateMachine->ChangeState("Shoot");
		return;
	}
	
	// ãƒ€ãƒƒã‚·ãƒ¥
	if (input->IsDashing())
	{
		stateMachine->ChangeState("Dash");
		return;
	}
	
	// ç§»å‹•å…¥åŠ›ãŒãªã‘ã‚Œã°Idleã¸
	if (!input->IsMoving())
	{
		stateMachine->ChangeState("Idle");
		return;
	}
}

void MoveState::DrawImGui(Player* player)
{
#ifdef _DEBUG
	ImGui::Text("=== Move State Details ===");
	ImGui::Separator();

	// ç§»å‹•æ™‚é–“
	ImGui::Text("Move Time: %.2f seconds", moveTime_);

	// ç§»å‹•é€Ÿåº¦æƒ…å ±
	if (player) {
		ImGui::Text("Current Speed: %.2f", player->GetSpeed());
		const Vector3& velocity = player->GetVelocity();
		ImGui::Text("Velocity: (%.2f, %.2f, %.2f)", velocity.x, velocity.y, velocity.z);
		ImGui::Text("Velocity Magnitude: %.2f", velocity.Length());
	}

	// ç§»å‹•æ–¹å‘
	if (ImGui::TreeNode("Movement Direction")) {
		InputHandler* input = player->GetInputHandler();
		if (input && input->IsMoving()) {
			ImGui::Text("Input Active: YES");
			// TODO: Display actual input direction vector
		} else {
			ImGui::Text("Input Active: NO");
		}
		ImGui::TreePop();
	}

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±
	if (ImGui::TreeNode("Animation Info")) {
		ImGui::Text("Animation: Walk");
		ImGui::Text("TODO: Add walk/run animation blending");
		ImGui::TreePop();
	}

	// åˆ©ç”¨å¯èƒ½ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
	if (ImGui::TreeNode("Available Actions")) {
		ImGui::BulletText("Press Space to Dash");
		ImGui::BulletText("Press Z to Attack");
		ImGui::BulletText("Press Left Ctrl to Shoot");
		ImGui::BulletText("Press F to Parry");
		ImGui::BulletText("Release movement keys to stop");
		ImGui::TreePop();
	}
#endif
}

============================================================
File Path: GameProject/Object/Player/State/MoveState.h
============================================================
#pragma once
#include "PlayerState.h"

/// <summary>
/// ç§»å‹•çŠ¶æ…‹ã‚¯ãƒ©ã‚¹
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ­©è¡Œãƒ»èµ°è¡Œã—ã¦ã„ã‚‹æ™‚ã®çŠ¶æ…‹
/// </summary>
class MoveState : public PlayerState
{
public:
	MoveState() : PlayerState("Walk") {}

	void Enter(Player* player) override;
	void Update(Player* player, float deltaTime) override;
	void Exit(Player* player) override;
	void HandleInput(Player* player) override;

	/// <summary>
	/// ImGuiãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æç”»
	/// </summary>
	void DrawImGui(Player* player) override;

private:
	float moveTime_ = 0.0f;  ///< ç§»å‹•ç¶™ç¶šæ™‚é–“
};

============================================================
File Path: GameProject/Object/Player/State/ParryState.cpp
============================================================
#include "ParryState.h"
#include "PlayerStateMachine.h"
#include "../Player.h"
#include "Input/InputHandler.h"
#include "GlobalVariables.h"
#include <algorithm>  // for std::min
#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

void ParryState::Enter(Player* player)
{
	// ãƒ‘ãƒªã‚£ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
	// TODO: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆå¾Œã«å®Ÿè£…
	// player->GetModel()->PlayAnimation("Parry");

	parryTimer_ = 0.0f;
	perfectParryActive_ = false;
}

void ParryState::Update(Player* player, float deltaTime)
{
	// GlobalVariablesã‹ã‚‰å€¤ã‚’åŒæœŸ
	GlobalVariables* gv = GlobalVariables::GetInstance();
	parryWindow_ = gv->GetValueFloat("ParryState", "ParryWindow");
	parryDuration_ = gv->GetValueFloat("ParryState", "ParryDuration");

	parryTimer_ += deltaTime;

	// ãƒ‘ãƒªã‚£æ™‚é–“ãŒçµ‚äº†ã—ãŸã‚‰å…ƒã®çŠ¶æ…‹ã«æˆ»ã‚‹
	if (parryTimer_ >= parryDuration_)
	{
		PlayerStateMachine* stateMachine = player->GetStateMachine();
		if (stateMachine)
		{
			stateMachine->ChangeState("Idle");
		}
	}
}

void ParryState::Exit(Player* player)
{
	parryTimer_ = 0.0f;
	perfectParryActive_ = false;
}

void ParryState::HandleInput(Player* player)
{
	// ãƒ‘ãƒªã‚£ä¸­ã¯å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„
}

void ParryState::OnParrySuccess(Player* player)
{
	if (IsInParryWindow())
	{
		// ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ãƒªã‚£æˆåŠŸ
		perfectParryActive_ = true;

		// ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼æ”»æ’ƒã¸ã®é·ç§»
		PlayerStateMachine* stateMachine = player->GetStateMachine();
		if (stateMachine)
		{
			stateMachine->ChangeState("Attack");
		}
	}
}

void ParryState::DrawImGui(Player* player)
{
#ifdef _DEBUG
	ImGui::Text("=== Parry State Details ===");
	ImGui::Separator();

	// ãƒ‘ãƒªã‚£ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¡¨ç¤º
	bool inWindow = IsInParryWindow();
	if (inWindow) {
		ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "PERFECT PARRY WINDOW!");
	} else {
		ImGui::Text("Normal Parry");
	}

	// ã‚¿ã‚¤ãƒžãƒ¼æƒ…å ±
	ImGui::Text("Parry Timer: %.3f / %.3f", parryTimer_, parryDuration_);

	// ãƒ‘ãƒªã‚£ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¦–è¦šåŒ–
	float windowProgress = (parryWindow_ > 0.0f) ? std::min<float>(1.0f, parryTimer_ / parryWindow_) : 0.0f;
	ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Perfect Window:");
	ImGui::ProgressBar(windowProgress, ImVec2(-1, 0), "");

	// å…¨ä½“ã®é€²è¡ŒçŠ¶æ³
	float totalProgress = (parryDuration_ > 0.0f) ? (parryTimer_ / parryDuration_) : 0.0f;
	ImGui::Text("Total Progress:");
	ImGui::ProgressBar(totalProgress);

	// ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ãƒªã‚£ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	if (perfectParryActive_) {
		ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "PERFECT PARRY ACTIVE!");
	}

	// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
	if (ImGui::TreeNode("Parry Parameters")) {
		ImGui::SliderFloat("Parry Window", &parryWindow_, 0.05f, 0.5f, "%.3f sec");
		ImGui::SliderFloat("Parry Duration", &parryDuration_, 0.2f, 2.0f, "%.2f sec");

		// ãƒ—ãƒªã‚»ãƒƒãƒˆ
		if (ImGui::Button("Easy")) {
			parryWindow_ = 0.3f;
			parryDuration_ = 0.8f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Normal")) {
			parryWindow_ = 0.2f;
			parryDuration_ = 0.5f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Hard")) {
			parryWindow_ = 0.1f;
			parryDuration_ = 0.3f;
		}

		ImGui::TreePop();
	}

	// ãƒ•ãƒ¬ãƒ¼ãƒ æƒ…å ±
	if (ImGui::TreeNode("Frame Data")) {
		ImGui::Text("Perfect Window Frames: %d", (int)(parryWindow_ * 60.0f));
		ImGui::Text("Total Frames: %d", (int)(parryDuration_ * 60.0f));
		ImGui::Text("Current Frame: %d", (int)(parryTimer_ * 60.0f));
		ImGui::TreePop();
	}
#endif
}

============================================================
File Path: GameProject/Object/Player/State/ParryState.h
============================================================
#pragma once
#include "PlayerState.h"

/// <summary>
/// ãƒ‘ãƒªã‚£çŠ¶æ…‹ã‚¯ãƒ©ã‚¹
/// æ•µã®æ”»æ’ƒã‚’é˜²å¾¡ãƒ»åæ’ƒã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ç®¡ç†
/// </summary>
class ParryState : public PlayerState
{
public:
	ParryState() : PlayerState("Parry") {}

	void Enter(Player* player) override;
	void Update(Player* player, float deltaTime) override;
	void Exit(Player* player) override;
	void HandleInput(Player* player) override;
	
	/// <summary>
	/// ãƒ‘ãƒªã‚£æˆåŠŸæ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void OnParrySuccess(Player* player);

	/// <summary>
	/// ãƒ‘ãƒªã‚£å—ä»˜æ™‚é–“å†…ã‹åˆ¤å®š
	/// </summary>
	/// <returns>ãƒ‘ãƒªã‚£ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ã®å ´åˆtrue</returns>
	bool IsInParryWindow() const { return parryTimer_ <= parryWindow_; }

	/// <summary>
	/// ImGuiãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æç”»
	/// </summary>
	void DrawImGui(Player* player) override;

	// DrawImGuiç”¨ã®ã‚²ãƒƒã‚¿ãƒ¼
	float GetParryTimer() const { return parryTimer_; }
	float GetParryWindow() const { return parryWindow_; }
	float GetParryDuration() const { return parryDuration_; }
	bool IsPerfectParryActive() const { return perfectParryActive_; }

	// DrawImGuiç”¨ã®ã‚»ãƒƒã‚¿ãƒ¼ï¼ˆãƒ‡ãƒãƒƒã‚°èª¿æ•´ç”¨ï¼‰
	void SetParryWindow(float window) { parryWindow_ = window; }
	void SetParryDuration(float duration) { parryDuration_ = duration; }

private:
	float parryTimer_ = 0.0f;          ///< ãƒ‘ãƒªã‚£çµŒéŽæ™‚é–“
	float parryWindow_ = 0.2f;         ///< ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ãƒªã‚£ã®å—ä»˜æ™‚é–“
	float parryDuration_ = 0.5f;       ///< ãƒ‘ãƒªã‚£å…¨ä½“ã®é•·ã•
	bool perfectParryActive_ = false;  ///< ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ãƒªã‚£æˆåŠŸãƒ•ãƒ©ã‚°
};

============================================================
File Path: GameProject/Object/Player/State/PlayerState.cpp
============================================================
#include "PlayerState.h"
#include "PlayerStateMachine.h"

void PlayerState::ChangeState(PlayerStateMachine* stateMachine, PlayerState* newState)
{
	if (stateMachine && newState)
	{
		stateMachine->ChangeState(newState);
	}
}

============================================================
File Path: GameProject/Object/Player/State/PlayerState.h
============================================================
#pragma once
#include <string>

class Player;
class PlayerStateMachine;

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒˆåŸºåº•ã‚¯ãƒ©ã‚¹
/// å„çŠ¶æ…‹ã®åŸºæœ¬ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©
/// </summary>
class PlayerState
{
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="name">çŠ¶æ…‹å</param>
	PlayerState(const std::string& name) : stateName_(name) {}

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	virtual ~PlayerState() = default;

	/// <summary>
	/// çŠ¶æ…‹é–‹å§‹æ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	virtual void Enter(Player* player) = 0;

	/// <summary>
	/// çŠ¶æ…‹ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	/// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
	virtual void Update(Player* player, float deltaTime) = 0;

	/// <summary>
	/// çŠ¶æ…‹çµ‚äº†æ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	virtual void Exit(Player* player) = 0;

	/// <summary>
	/// å…¥åŠ›å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	virtual void HandleInput(Player* player) {}

	/// <summary>
	/// æŒ‡å®šçŠ¶æ…‹ã¸ã®é·ç§»å¯å¦ã‚’åˆ¤å®š
	/// </summary>
	/// <param name="stateName">é·ç§»å…ˆã®çŠ¶æ…‹å</param>
	/// <returns>é·ç§»å¯èƒ½ãªå ´åˆtrue</returns>
	virtual bool CanTransitionTo(const std::string& stateName) const { return true; }

	/// <summary>
	/// çŠ¶æ…‹åã‚’å–å¾—
	/// </summary>
	/// <returns>çŠ¶æ…‹åã®å‚ç…§</returns>
	const std::string& GetName() const { return stateName_; }

	/// <summary>
	/// ImGuiã‚’ä½¿ç”¨ã—ãŸãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æç”»
	/// å„ã‚¹ãƒ†ãƒ¼ãƒˆå›ºæœ‰ã®ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ä½¿ç”¨
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	virtual void DrawImGui(Player* player) {}

protected:
	/// <summary>
	/// çŠ¶æ…‹ã‚’å¤‰æ›´
	/// ç¾åœ¨ã®çŠ¶æ…‹ã‹ã‚‰Exit()ã‚’å‘¼ã³å‡ºã—ã€æ–°ã—ã„çŠ¶æ…‹ã®Enter()ã‚’å‘¼ã³å‡ºã™
	/// </summary>
	/// <param name="stateMachine">çŠ¶æ…‹ç®¡ç†ã‚’è¡Œã†ã‚¹ãƒ†ãƒ¼ãƒˆãƒžã‚·ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	/// <param name="newState">é·ç§»å…ˆã®æ–°ã—ã„çŠ¶æ…‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆPlayerStateã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ï¼‰</param>
	void ChangeState(PlayerStateMachine* stateMachine, PlayerState* newState);

private:
	std::string stateName_;
};

============================================================
File Path: GameProject/Object/Player/State/PlayerStateMachine.cpp
============================================================
#include "PlayerStateMachine.h"
#include "PlayerState.h"
#include "../Player.h"
#include <assert.h>
#include <vector>
#include <algorithm>

PlayerStateMachine::PlayerStateMachine(Player* player)
	: player_(player)
	, currentState_(nullptr)
	, previousState_(nullptr)
{
}

PlayerStateMachine::~PlayerStateMachine()
{
	if (currentState_)
	{
		currentState_->Exit(player_);
	}
}

void PlayerStateMachine::Initialize()
{
	if (!states_.empty() && !currentState_)
	{
		currentState_ = states_.begin()->second.get();
		currentState_->Enter(player_);
	}
}

void PlayerStateMachine::Update(float deltaTime)
{
	if (currentState_)
	{
		currentState_->Update(player_, deltaTime);
	}
}

void PlayerStateMachine::HandleInput()
{
	if (currentState_)
	{
		currentState_->HandleInput(player_);
	}
}

void PlayerStateMachine::ChangeState(const std::string& stateName)
{
	auto it = states_.find(stateName);
	if (it != states_.end())
	{
		ChangeState(it->second.get());
	}
}

void PlayerStateMachine::ChangeState(PlayerState* newState)
{
	if (!newState || newState == currentState_)
	{
		return;
	}

	if (currentState_ && !currentState_->CanTransitionTo(newState->GetName()))
	{
		return;
	}

	if (currentState_)
	{
		currentState_->Exit(player_);
	}

	previousState_ = currentState_;
	currentState_ = newState;
	currentState_->Enter(player_);
}

void PlayerStateMachine::RegisterState(const std::string& name, std::unique_ptr<PlayerState> state)
{
	states_[name] = std::move(state);
}

PlayerState* PlayerStateMachine::GetState(const std::string& name) const
{
	auto it = states_.find(name);
	return (it != states_.end()) ? it->second.get() : nullptr;
}

std::vector<std::string> PlayerStateMachine::GetAllStateNames() const
{
	std::vector<std::string> names;
	names.reserve(states_.size());

	for (const auto& [name, state] : states_) {
		names.push_back(name);
	}

	// ã‚½ãƒ¼ãƒˆã—ã¦ä¸€å®šã®é †åºã‚’ä¿è¨¼
	std::sort(names.begin(), names.end());

	return names;
}

============================================================
File Path: GameProject/Object/Player/State/PlayerStateMachine.h
============================================================
#pragma once
#include <memory>
#include <unordered_map>
#include <string>

class Player;
class PlayerState;

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹ç®¡ç†ãƒžã‚·ãƒ³
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å„çŠ¶æ…‹ã‚’ç®¡ç†ã—ã€çŠ¶æ…‹é·ç§»ã‚’åˆ¶å¾¡
/// </summary>
class PlayerStateMachine
{
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="player">ç®¡ç†å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</param>
	PlayerStateMachine(Player* player);

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~PlayerStateMachine();

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
	void Update(float deltaTime);

	/// <summary>
	/// å…¥åŠ›å‡¦ç†
	/// </summary>
	void HandleInput();

	/// <summary>
	/// çŠ¶æ…‹ã‚’åå‰ã§å¤‰æ›´
	/// </summary>
	/// <param name="stateName">é·ç§»å…ˆã®çŠ¶æ…‹å</param>
	void ChangeState(const std::string& stateName);

	/// <summary>
	/// çŠ¶æ…‹ã‚’ãƒã‚¤ãƒ³ã‚¿ã§å¤‰æ›´
	/// </summary>
	/// <param name="newState">é·ç§»å…ˆã®çŠ¶æ…‹ãƒã‚¤ãƒ³ã‚¿</param>
	void ChangeState(PlayerState* newState);

	/// <summary>
	/// çŠ¶æ…‹ã‚’ç™»éŒ²
	/// </summary>
	/// <param name="name">çŠ¶æ…‹å</param>
	/// <param name="state">çŠ¶æ…‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void RegisterState(const std::string& name, std::unique_ptr<PlayerState> state);

	/// <summary>
	/// ç¾åœ¨ã®çŠ¶æ…‹ã‚’å–å¾—
	/// </summary>
	/// <returns>ç¾åœ¨ã®çŠ¶æ…‹ãƒã‚¤ãƒ³ã‚¿</returns>
	PlayerState* GetCurrentState() const { return currentState_; }

	/// <summary>
	/// åå‰ã§çŠ¶æ…‹ã‚’å–å¾—
	/// </summary>
	/// <param name="name">å–å¾—ã™ã‚‹çŠ¶æ…‹å</param>
	/// <returns>çŠ¶æ…‹ãƒã‚¤ãƒ³ã‚¿ï¼ˆè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯nullptrï¼‰</returns>
	PlayerState* GetState(const std::string& name) const;

	/// <summary>
	/// å…¨ã¦ã®ç™»éŒ²æ¸ˆã¿çŠ¶æ…‹åã‚’å–å¾—
	/// </summary>
	/// <returns>çŠ¶æ…‹åã®ãƒ™ã‚¯ã‚¿ãƒ¼ï¼ˆã‚½ãƒ¼ãƒˆæ¸ˆã¿ï¼‰</returns>
	std::vector<std::string> GetAllStateNames() const;

private:
	Player* player_;
	PlayerState* currentState_;
	PlayerState* previousState_;
	std::unordered_map<std::string, std::unique_ptr<PlayerState>> states_;
};

============================================================
File Path: GameProject/Object/Player/State/ShootState.cpp
============================================================
#include "ShootState.h"
#include "PlayerStateMachine.h"
#include "../Player.h"
#include "Input/InputHandler.h"
#include "Camera.h"
#include "Object/Boss/Boss.h"
#include "Matrix4x4.h"
#include "Mat4x4Func.h"
#include "Vec3Func.h"
#include "GlobalVariables.h"
#include <algorithm>  // for std::max
#include <cmath>
#ifdef _DEBUG
#include "ImGuiManager.h"
#endif

void ShootState::Enter(Player* player)
{
	// å°„æ’ƒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
	// TODO: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆå¾Œã«å®Ÿè£…
	// player->GetModel()->PlayAnimation("Shoot");

	fireRateTimer_ = 0.0f;
}

void ShootState::Update(Player* player, float deltaTime)
{
	// GlobalVariablesã‹ã‚‰å€¤ã‚’åŒæœŸ
	GlobalVariables* gv = GlobalVariables::GetInstance();
	fireRate_ = gv->GetValueFloat("ShootState", "FireRate");
	moveSpeedMultiplier_ = gv->GetValueFloat("ShootState", "MoveSpeedMultiplier");

	// ãƒ•ã‚§ãƒ¼ã‚º2ã§ã¯å°„æ’ƒã‚’ç„¡åŠ¹åŒ–
	Boss* boss = player->GetBoss();
	if (boss && boss->GetPhase() == 2) {
		// å°„æ’ƒã›ãšã«Idle/Moveã«æˆ»ã‚‹
		PlayerStateMachine* stateMachine = player->GetStateMachine();
		InputHandler* input = player->GetInputHandler();
		if (stateMachine && input) {
			if (input->IsMoving()) {
				stateMachine->ChangeState("Move");
			} else {
				stateMachine->ChangeState("Idle");
			}
		}
		return;
	}

	// ç™ºå°„ãƒ¬ãƒ¼ãƒˆã‚¿ã‚¤ãƒžãƒ¼ã®æ›´æ–°
	if (fireRateTimer_ > 0.0f)
	{
		fireRateTimer_ -= deltaTime;
	}

	// ã‚¨ã‚¤ãƒ æ–¹å‘ã®è¨ˆç®—
	CalculateAimDirection(player);

	// å°„æ’ƒå¯èƒ½ãªã‚‰ç™ºå°„
	if (fireRateTimer_ <= 0.0f)
	{
		Fire(player);
		fireRateTimer_ = fireRate_;
	}

	// ç§»å‹•å‡¦ç†
    player->Move(moveSpeedMultiplier_, false);
}

void ShootState::Exit(Player* player)
{
	fireRateTimer_ = 0.0f;
}

void ShootState::HandleInput(Player* player)
{
	InputHandler* input = player->GetInputHandler();
	if (!input) return;
	
	// å°„æ’ƒãƒœã‚¿ãƒ³ãŒé›¢ã•ã‚ŒãŸã‚‰å…ƒã®çŠ¶æ…‹ã«æˆ»ã‚‹
	if (!input->IsShooting())
	{
		PlayerStateMachine* stateMachine = player->GetStateMachine();
		if (stateMachine)
		{
			if (input->IsMoving())
			{
				stateMachine->ChangeState("Move");
			}
			else
			{
				stateMachine->ChangeState("Idle");
			}
		}
	}
}

void ShootState::CalculateAimDirection(Player* player)
{
	InputHandler* input = player->GetInputHandler();
	if (!input || !input->IsShooting()) {
		// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ãªã— â†’ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‰æ–¹
		float yaw = player->GetRotate().y;
		aimDirection_ = Vector3(std::sin(yaw), 0.0f, std::cos(yaw));
		return;
	}

	// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯æ–¹å‘ã‚’å–å¾—
	Vector2 stick = input->GetAimDirection();

	// ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ã‚’3Dãƒ™ã‚¯ãƒˆãƒ«ã«å¤‰æ›ï¼ˆX=å·¦å³, Y=å‰å¾Œ â†’ X=X, Z=Yï¼‰
	Vector3 localDirection = Vector3(stick.x, 0.0f, stick.y);

	// ã‚«ãƒ¡ãƒ©ã®Yå›žè»¢ã‚’åŸºæº–ã«ã™ã‚‹ï¼ˆã‚«ãƒ¡ãƒ©ç›¸å¯¾åº§æ¨™ç³»ï¼‰
	Camera* camera = player->GetCamera();
	float cameraYaw = camera ? camera->GetRotateY() : player->GetRotate().y;
	Matrix4x4 rotationMatrix = Mat4x4::MakeRotateY(cameraYaw);

	// ãƒ­ãƒ¼ã‚«ãƒ«æ–¹å‘ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰æ–¹å‘ã«å¤‰æ›
	aimDirection_ = Mat4x4::TransformNormal(rotationMatrix, localDirection);

	// æ­£è¦åŒ–
    aimDirection_ = aimDirection_.Normalize();

    // ç™ºå°„æ–¹å‘ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‘ã‘ã‚‹
    if (aimDirection_.Length() > 0.01f) {
        float targetAngle = std::atan2(aimDirection_.x, aimDirection_.z);
        float aimRotationLerp = GlobalVariables::GetInstance()->GetValueFloat("ShootState", "AimRotationLerp");
        if (aimRotationLerp <= 0.0f) {
            aimRotationLerp = 0.3f;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        }
        Transform* transform = player->GetTransformPtr();
        transform->rotate.y = Vec3::LerpShortAngle(transform->rotate.y, targetAngle, aimRotationLerp);
    }
}

void ShootState::Fire(Player* player)
{
	// ç™ºå°„ä½ç½®ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸­å¿ƒï¼‰
	Vector3 position = player->GetTranslate();

	// å¼¾é€Ÿåº¦ã‚’è¨ˆç®—
	GlobalVariables* gv = GlobalVariables::GetInstance();
	float bulletSpeed = gv->GetValueFloat("PlayerBullet", "Speed");
	if (bulletSpeed <= 0.0f) {
		bulletSpeed = 30.0f;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
	}
	Vector3 velocity = aimDirection_ * bulletSpeed;

	// å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¿½åŠ 
	player->RequestBulletSpawn(position, velocity);
}

void ShootState::DrawImGui(Player* player)
{
#ifdef _DEBUG
	ImGui::Text("=== Shoot State Details ===");
	ImGui::Separator();

	// ç™ºå°„ãƒ¬ãƒ¼ãƒˆæƒ…å ±
	ImGui::Text("Fire Rate: %.2f (%.1f shots/sec)", fireRate_, 1.0f / fireRate_);
	ImGui::Text("Next Shot In: %.2f", std::max<float>(0.0f, fireRate_ - fireRateTimer_));

	// ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼
	float progress = (fireRate_ > 0.0f) ? (fireRateTimer_ / fireRate_) : 0.0f;
	ImGui::ProgressBar(progress, ImVec2(-1, 0), "Reload");

	// ç…§æº–æ–¹å‘
	if (ImGui::TreeNode("Aim Direction")) {
		ImGui::Text("X: %.3f", aimDirection_.x);
		ImGui::Text("Y: %.3f", aimDirection_.y);
		ImGui::Text("Z: %.3f", aimDirection_.z);
		ImGui::Text("Length: %.3f", aimDirection_.Length());
		ImGui::TreePop();
	}

	// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
	if (ImGui::TreeNode("Shooting Parameters")) {
		ImGui::SliderFloat("Fire Rate", &fireRate_, 0.05f, 2.0f, "%.2f sec");

		// ãƒ—ãƒªã‚»ãƒƒãƒˆ
		if (ImGui::Button("Rapid Fire")) {
			fireRate_ = 0.05f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Normal")) {
			fireRate_ = 0.2f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Slow")) {
			fireRate_ = 0.5f;
		}

		ImGui::TreePop();
	}
#endif
}

============================================================
File Path: GameProject/Object/Player/State/ShootState.h
============================================================
#pragma once
#include "PlayerState.h"
#include "Vector3.h"

/// <summary>
/// å°„æ’ƒçŠ¶æ…‹ã‚¯ãƒ©ã‚¹
/// é è·é›¢æ”»æ’ƒã®ç…§æº–ã¨ç™ºå°„ã‚’åˆ¶å¾¡
/// </summary>
class ShootState : public PlayerState
{
public:
	ShootState() : PlayerState("Shoot") {}

	void Enter(Player* player) override;
	void Update(Player* player, float deltaTime) override;
	void Exit(Player* player) override;
	void HandleInput(Player* player) override;

	/// <summary>
	/// ImGuiãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æç”»
	/// </summary>
	void DrawImGui(Player* player) override;

	// DrawImGuiç”¨ã®ã‚²ãƒƒã‚¿ãƒ¼
	float GetFireRate() const { return fireRate_; }
	float GetFireRateTimer() const { return fireRateTimer_; }
	const Vector3& GetAimDirection() const { return aimDirection_; }

	// DrawImGuiç”¨ã®ã‚»ãƒƒã‚¿ãƒ¼ï¼ˆãƒ‡ãƒãƒƒã‚°èª¿æ•´ç”¨ï¼‰
	void SetFireRate(float rate) { fireRate_ = rate; }

private:
	float fireRate_ = 0.2f;              ///< ç™ºå°„ãƒ¬ãƒ¼ãƒˆï¼ˆç§’é–“éš”ï¼‰
	float fireRateTimer_ = 0.0f;         ///< ç™ºå°„é–“éš”ã‚¿ã‚¤ãƒžãƒ¼
	float moveSpeedMultiplier_ = 0.5f;   ///< å°„æ’ƒä¸­ã®ç§»å‹•é€Ÿåº¦å€çŽ‡
	Vector3 aimDirection_;                ///< ç…§æº–æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«

	/// <summary>
	/// ç…§æº–æ–¹å‘ã‚’è¨ˆç®—
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void CalculateAimDirection(Player* player);

	/// <summary>
	/// å¼¾ã‚’ç™ºå°„
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	void Fire(Player* player);
};

============================================================
File Path: GameProject/Object/Projectile/BossBullet.cpp
============================================================
#include "BossBullet.h"
#include "../../Collision/BossBulletCollider.h"
#include "../../Object/Player/Player.h"
#include "../../Common/GameConst.h"
#include "ModelManager.h"
#include "Object3d.h"
#include "CollisionManager.h"
#include "EmitterManager.h"
#include "RandomEngine.h"
#include "GlobalVariables.h"

uint32_t BossBullet::id = 0;

BossBullet::BossBullet(EmitterManager* emittermanager) {
    // GlobalVariablesã‹ã‚‰å€¤ã‚’å–å¾—
    GlobalVariables* gv = GlobalVariables::GetInstance();

    // å¼¾ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®šï¼ˆGlobalVariablesã‹ã‚‰å–å¾—ï¼‰
    damage_ = gv->GetValueFloat("BossBullet", "Damage");
    lifeTime_ = gv->GetValueFloat("BossBullet", "Lifetime");

    // ãƒ©ãƒ³ãƒ€ãƒ ãªå›žè»¢é€Ÿåº¦ã‚’è¨­å®š
    RandomEngine* rng = RandomEngine::GetInstance();

    rotationSpeed_ = Vector3(
        rng->GetFloat(rotationSpeedMin_, rotationSpeedMax_),
        rng->GetFloat(rotationSpeedMin_, rotationSpeedMax_),
        rng->GetFloat(rotationSpeedMin_, rotationSpeedMax_)
    );

    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®è¨­å®š
    emitterManager_ = emittermanager;

    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ãƒ­ãƒ¼ãƒ‰
    if (emitterManager_) {
        bulletEmitterName_ = "boss_bullet" + std::to_string(id);
        explodeEmitterName_ = "boss_bullet_explode" + std::to_string(id);
        emitterManager_->LoadPreset("boss_bullet", bulletEmitterName_);
        emitterManager_->SetEmitterActive(bulletEmitterName_, false);
        emitterManager_->LoadPreset("boss_bullet_explode", explodeEmitterName_);
        emitterManager_->SetEmitterActive(explodeEmitterName_, false);
    }

    id++;

    if (id > kIdResetThreshold) {
        id = 0; // IDã®ãƒªã‚»ãƒƒãƒˆ
    }
}

BossBullet::~BossBullet() = default;

void BossBullet::Initialize(const Vector3& position, const Vector3& velocity) {
    // è¦ªã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–
    Projectile::Initialize(position, velocity);

    // ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
    SetModel();

    model_->Update();

    // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨­å®šï¼ˆçƒä½“ãƒ¢ãƒ‡ãƒ«ã®ã‚µã‚¤ã‚ºèª¿æ•´ï¼‰
    transform_.scale = Vector3(kInitialScale, kInitialScale, kInitialScale);

    // å¼¾ã®è‰²ã‚’è¨­å®šï¼ˆèµ¤ã£ã½ã„è‰²ï¼‰
    //if (model_) {
    //    model_->SetMaterialColor(Vector4(1.0f, 0.3f, 0.3f, 1.0f));
    //    model_->SetTransform(transform_);
    //}

    if (emitterManager_) {
        emitterManager_->SetEmitterActive(bulletEmitterName_, true);
        emitterManager_->SetEmitterPosition(bulletEmitterName_, position);
    }

    // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¨­å®š
    if (!collider_) {
        collider_ = std::make_unique<BossBulletCollider>(this);
    }
    float colliderRadius = GlobalVariables::GetInstance()->GetValueFloat("BossBullet", "ColliderRadius");
    collider_->SetTransform(&transform_);
    collider_->SetRadius(colliderRadius);
    collider_->SetOffset(Vector3(0.0f, 0.0f, 0.0f));
    collider_->SetTypeID(static_cast<uint32_t>(CollisionTypeId::BOSS_ATTACK));
    collider_->SetOwner(this);
    collider_->SetActive(true);
    collider_->Reset();  // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ

    // CollisionManagerã«ç™»éŒ²
    CollisionManager::GetInstance()->AddCollider(collider_.get());
}

void BossBullet::Finalize() {
    // CollisionManagerã‹ã‚‰å‰Šé™¤
    if (collider_) {
        CollisionManager::GetInstance()->RemoveCollider(collider_.get());
    }

    if (emitterManager_) {
        emitterManager_->CreateTemporaryEmitterFrom(
            explodeEmitterName_,
            explodeEmitterName_ + "temp",
            0.5f);
        emitterManager_->RemoveEmitter(bulletEmitterName_);
        emitterManager_->RemoveEmitter(explodeEmitterName_);
    }
}

void BossBullet::Update(float deltaTime) {
    if (!isActive_) {
        return;
    }

    // è¦ªã‚¯ãƒ©ã‚¹ã®æ›´æ–°å‡¦ç†
    Projectile::Update(deltaTime);

    // å›žè»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    transform_.rotate += rotationSpeed_ * deltaTime;

    // ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
    //if (model_) {
    //    model_->SetTransform(transform_);
    //}

    // è»Œè·¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    if (emitterManager_) {
        emitterManager_->SetEmitterPosition(bulletEmitterName_, transform_.translate);
        emitterManager_->SetEmitterPosition(explodeEmitterName_, transform_.translate);
    }

    // ã‚¨ãƒªã‚¢å¤–ã«å‡ºãŸã‚‰éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    Vector3 pos = transform_.translate;
    if (pos.x < GameConst::kStageXMin || pos.x > GameConst::kStageXMax ||
        pos.z < GameConst::kStageZMin || pos.z > GameConst::kStageZMax ||
        pos.y < yBoundaryMin_ || pos.y > yBoundaryMax_) {
        isActive_ = false;
    }
}

void BossBullet::SetModel() {
    if (model_) {
        // ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
        model_->SetModel("sphere.gltf");

        if (!model_->GetModel()) {
            // sphereãƒ¢ãƒ‡ãƒ«ãŒãªã„å ´åˆã¯ã€ä»£æ›¿ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
            model_->SetModel("white_cube.gltf");
        }
    }
}

============================================================
File Path: GameProject/Object/Projectile/BossBullet.h
============================================================
#pragma once

#include "Projectile.h"
#include "../../../GameProject/Collision/CollisionTypeIdDef.h"
#include <memory>
#include <string>

class EmitterManager;
class ModelManager;
class BossBulletCollider;

/// <summary>
/// ãƒœã‚¹ã®å¼¾ã‚¯ãƒ©ã‚¹
/// </summary>
class BossBullet : public Projectile {
    //=========================================================================================
    // å®šæ•°
    //=========================================================================================
private:
    static constexpr uint32_t kIdResetThreshold = 10000;///< ID ãƒªã‚»ãƒƒãƒˆé–¾å€¤
    static constexpr float kInitialScale = 0.0f;        ///< åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    BossBullet(EmitterManager* emittermanager);

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~BossBullet() override;

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    /// <param name="position">åˆæœŸä½ç½®</param>
    /// <param name="velocity">åˆæœŸé€Ÿåº¦</param>
    void Initialize(const Vector3& position, const Vector3& velocity) override;

    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize();

    /// <summary>
    /// æ›´æ–°
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
    void Update(float deltaTime) override;

    /// <summary>
    /// ã‚³ãƒªã‚¸ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—IDã‚’å–å¾—
    /// </summary>
    CollisionTypeId GetTypeId() const { return CollisionTypeId::BOSS_ATTACK; }

    /// <summary>
    /// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å–å¾—
    /// </summary>
    BossBulletCollider* GetCollider() const { return collider_.get(); }

private:
    // ãƒ¢ãƒ‡ãƒ«ã‚’è¨­å®š
    void SetModel();

private:
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã®å›žè»¢é€Ÿåº¦
    Vector3 rotationSpeed_;

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¿ã‚¤ãƒžãƒ¼
    float particleTimer_ = 0.0f;

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆé–“éš”
    float particleInterval_ = 0.05f;

    // å°‚ç”¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
    std::unique_ptr<BossBulletCollider> collider_;

    // ã‚¨ãƒŸãƒƒã‚¿ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ£ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿
    EmitterManager* emitterManager_ = nullptr;

    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®åå‰
    std::string bulletEmitterName_ = "";
    std::string explodeEmitterName_ = "";

    // id
    static uint32_t id;

    // èª¿æ•´å¯èƒ½ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    float rotationSpeedMin_ = -10.0f;  ///< å›žè»¢é€Ÿåº¦ã®æœ€å°å€¤
    float rotationSpeedMax_ = 10.0f;   ///< å›žè»¢é€Ÿåº¦ã®æœ€å¤§å€¤
    float yBoundaryMin_ = -10.0f;      ///< Yåº§æ¨™ã®ä¸‹é™
    float yBoundaryMax_ = 50.0f;       ///< Yåº§æ¨™ã®ä¸Šé™
};

============================================================
File Path: GameProject/Object/Projectile/PlayerBullet.cpp
============================================================
#include "PlayerBullet.h"
#include "../../Collision/PlayerBulletCollider.h"
#include "../../Common/GameConst.h"
#include "ModelManager.h"
#include "Object3d.h"
#include "CollisionManager.h"
#include "EmitterManager.h"
#include "GlobalVariables.h"

uint32_t PlayerBullet::id = 0;

PlayerBullet::PlayerBullet(EmitterManager* emitterManager) {
    // GlobalVariablesã‹ã‚‰å€¤ã‚’å–å¾—
    GlobalVariables* gv = GlobalVariables::GetInstance();

    // å¼¾ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®šï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨ã€GlobalVariablesã«æœªç™»éŒ²ã®å ´åˆã«å‚™ãˆã‚‹ï¼‰
    damage_ = gv->GetValueFloat("PlayerBullet", "Damage");
    lifeTime_ = gv->GetValueFloat("PlayerBullet", "Lifetime");

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®šï¼ˆGlobalVariablesã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰
    if (damage_ <= 0.0f) {
        damage_ = 10.0f;
    }
    if (lifeTime_ <= 0.0f) {
        lifeTime_ = 3.0f;
    }

    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®è¨­å®š
    emitterManager_ = emitterManager;

    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ãƒ­ãƒ¼ãƒ‰
    if (emitterManager_) {
        bulletEmitterName_ = "player_bullet" + std::to_string(id);
        explodeEmitterName_ = "player_bullet_explode" + std::to_string(id);
        emitterManager_->LoadPreset("player_bullet", bulletEmitterName_);
        emitterManager_->SetEmitterActive(bulletEmitterName_, false);
        emitterManager_->LoadPreset("player_bullet_explode", explodeEmitterName_);
        emitterManager_->SetEmitterActive(explodeEmitterName_, false);
    }

    id++;

    if (id > kIdResetThreshold) {
        id = 0; // IDã®ãƒªã‚»ãƒƒãƒˆ
    }
}

PlayerBullet::~PlayerBullet() = default;

void PlayerBullet::Initialize(const Vector3& position, const Vector3& velocity) {
    // è¦ªã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–
    Projectile::Initialize(position, velocity);

    // ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
    SetModel();

    model_->Update();

    // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨­å®šï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»ã®ãŸã‚0ã«è¨­å®šï¼‰
    transform_.scale = Vector3(kInitialScale, kInitialScale, kInitialScale);

    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚’æœ‰åŠ¹åŒ–
    if (emitterManager_) {
        emitterManager_->SetEmitterActive(bulletEmitterName_, true);
        emitterManager_->SetEmitterPosition(bulletEmitterName_, position);
    }

    // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¨­å®š
    if (!collider_) {
        collider_ = std::make_unique<PlayerBulletCollider>(this);
    }

    GlobalVariables* gv = GlobalVariables::GetInstance();
    float colliderRadius = gv->GetValueFloat("PlayerBullet", "ColliderRadius");
    if (colliderRadius <= 0.0f) {
        colliderRadius = 0.5f; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
    }

    collider_->SetTransform(&transform_);
    collider_->SetRadius(colliderRadius);
    collider_->SetOffset(Vector3(0.0f, 0.0f, 0.0f));
    collider_->SetTypeID(static_cast<uint32_t>(CollisionTypeId::PLAYER_ATTACK));
    collider_->SetOwner(this);
    collider_->SetActive(true);
    collider_->Reset();

    // CollisionManagerã«ç™»éŒ²
    CollisionManager::GetInstance()->AddCollider(collider_.get());
}

void PlayerBullet::Finalize() {
    // CollisionManagerã‹ã‚‰å‰Šé™¤
    if (collider_) {
        CollisionManager::GetInstance()->RemoveCollider(collider_.get());
    }

    // çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
    if (emitterManager_) {
        emitterManager_->CreateTemporaryEmitterFrom(
            explodeEmitterName_,
            explodeEmitterName_ + "temp",
            0.5f);
        emitterManager_->RemoveEmitter(bulletEmitterName_);
        emitterManager_->RemoveEmitter(explodeEmitterName_);
    }
}

void PlayerBullet::Update(float deltaTime) {
    if (!isActive_) {
        return;
    }

    // è¦ªã‚¯ãƒ©ã‚¹ã®æ›´æ–°å‡¦ç†
    Projectile::Update(deltaTime);

    // è»Œè·¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½ç½®ã‚’åŒæœŸ
    if (emitterManager_) {
        emitterManager_->SetEmitterPosition(bulletEmitterName_, transform_.translate);
        emitterManager_->SetEmitterPosition(explodeEmitterName_, transform_.translate);
    }

    // ã‚¨ãƒªã‚¢å¤–ã«å‡ºãŸã‚‰éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    Vector3 pos = transform_.translate;
    if (pos.x < GameConst::kStageXMin || pos.x > GameConst::kStageXMax ||
        pos.z < GameConst::kStageZMin || pos.z > GameConst::kStageZMax ||
        pos.y < yBoundaryMin_ || pos.y > yBoundaryMax_) {
        isActive_ = false;
    }
}

void PlayerBullet::SetModel() {
    if (model_) {
        // ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆå®Ÿéš›ã«ã¯éžè¡¨ç¤ºã ãŒã€Object3dã®åˆæœŸåŒ–ã«å¿…è¦ï¼‰
        model_->SetModel("sphere.gltf");

        if (!model_->GetModel()) {
            // sphereãƒ¢ãƒ‡ãƒ«ãŒãªã„å ´åˆã¯ã€ä»£æ›¿ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
            model_->SetModel("white_cube.gltf");
        }
    }
}


============================================================
File Path: GameProject/Object/Projectile/PlayerBullet.h
============================================================
#pragma once

#include "Projectile.h"
#include "../../../GameProject/Collision/CollisionTypeIdDef.h"
#include <memory>
#include <string>

class EmitterManager;
class PlayerBulletCollider;

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã‚¯ãƒ©ã‚¹
/// BossBulletã¨å¯¾ç§°ã®è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³
/// </summary>
class PlayerBullet : public Projectile {
    //=========================================================================================
    // å®šæ•°
    //=========================================================================================
private:
    static constexpr uint32_t kIdResetThreshold = 10000; ///< ID ãƒªã‚»ãƒƒãƒˆé–¾å€¤
    static constexpr float kInitialScale = 0.0f;         ///< åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»ã®ãŸã‚0ï¼‰

public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    /// <param name="emitterManager">ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼</param>
    PlayerBullet(EmitterManager* emitterManager);

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ~PlayerBullet() override;

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    /// <param name="position">åˆæœŸä½ç½®</param>
    /// <param name="velocity">åˆæœŸé€Ÿåº¦</param>
    void Initialize(const Vector3& position, const Vector3& velocity) override;

    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize();

    /// <summary>
    /// æ›´æ–°
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
    void Update(float deltaTime) override;

    /// <summary>
    /// ã‚³ãƒªã‚¸ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—IDã‚’å–å¾—
    /// </summary>
    CollisionTypeId GetTypeId() const { return CollisionTypeId::PLAYER_ATTACK; }

    /// <summary>
    /// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å–å¾—
    /// </summary>
    PlayerBulletCollider* GetCollider() const { return collider_.get(); }

private:
    // ãƒ¢ãƒ‡ãƒ«ã‚’è¨­å®š
    void SetModel();

private:
    // å°‚ç”¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
    std::unique_ptr<PlayerBulletCollider> collider_;

    // ã‚¨ãƒŸãƒƒã‚¿ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿
    EmitterManager* emitterManager_ = nullptr;

    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®åå‰
    std::string bulletEmitterName_ = "";
    std::string explodeEmitterName_ = "";

    // idï¼ˆè¤‡æ•°å¼¾ã®è­˜åˆ¥ç”¨ï¼‰
    static uint32_t id;

    // èª¿æ•´å¯èƒ½ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    float yBoundaryMin_ = -10.0f;  ///< Yåº§æ¨™ã®ä¸‹é™
    float yBoundaryMax_ = 50.0f;   ///< Yåº§æ¨™ã®ä¸Šé™
};


============================================================
File Path: GameProject/Object/Projectile/Projectile.cpp
============================================================
#include "Projectile.h"
#include "Object3d.h"
#include "Model.h"

Projectile::Projectile() {
}

Projectile::~Projectile() {
}

void Projectile::Initialize(const Vector3& position, const Vector3& velocity) {
    // ä½ç½®ã¨é€Ÿåº¦ã‚’è¨­å®š
    transform_.translate = position;
    velocity_ = velocity;

    // ãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
    if (!model_) {
        model_ = std::make_unique<Object3d>();
        model_->Initialize();
    }

    // ãƒ¢ãƒ‡ãƒ«ã«Transformã‚’è¨­å®š
    model_->SetTransform(transform_);

    // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
    elapsedTime_ = 0.0f;

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    isActive_ = true;
}

void Projectile::Update(float deltaTime) {
    if (!isActive_) {
        return;
    }

    // ç”Ÿå­˜æ™‚é–“ã‚’æ›´æ–°
    UpdateLifetime(deltaTime);

    // ç§»å‹•å‡¦ç†
    Move(deltaTime);

    // ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
    if (model_) {
        model_->SetTransform(transform_);
        model_->Update();
    }
}

void Projectile::Draw() {
    if (!isActive_ || !model_) {
        return;
    }

    // ãƒ¢ãƒ‡ãƒ«ã‚’æç”»
    model_->Draw();
}

void Projectile::UpdateLifetime(float deltaTime) {
    elapsedTime_ += deltaTime;

    // ç”Ÿå­˜æ™‚é–“ã‚’è¶…ãˆãŸã‚‰éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    if (elapsedTime_ >= lifeTime_) {
        isActive_ = false;
    }
}

void Projectile::Move(float deltaTime) {
    // é€Ÿåº¦ã«åŸºã¥ã„ã¦ç§»å‹•
    transform_.translate += velocity_ * deltaTime;
}

============================================================
File Path: GameProject/Object/Projectile/Projectile.h
============================================================
#pragma once

#include "Transform.h"
#include "Vector3.h"
#include <memory>

class Object3d;
class Model;

/// <summary>
/// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚¿ã‚¤ãƒ«ï¼ˆå¼¾ï¼‰åŸºåº•ã‚¯ãƒ©ã‚¹
/// ç§»å‹•ã¨ç”Ÿå­˜æ™‚é–“ã®ç®¡ç†ã®ã¿ã‚’æ‹…å½“
/// è¡çªåˆ¤å®šã¯æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§å®Ÿè£…
/// </summary>
class Projectile {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    Projectile();

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~Projectile();

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    /// <param name="position">åˆæœŸä½ç½®</param>
    /// <param name="velocity">åˆæœŸé€Ÿåº¦</param>
    virtual void Initialize(const Vector3& position, const Vector3& velocity);

    /// <summary>
    /// æ›´æ–°
    /// </summary>
    /// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
    virtual void Update(float deltaTime);

    /// <summary>
    /// æç”»
    /// </summary>
    virtual void Draw();

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
    /// </summary>
    bool IsActive() const { return isActive_; }

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š
    /// </summary>
    void SetActive(bool active) { isActive_ = active; }

    /// <summary>
    /// ãƒ€ãƒ¡ãƒ¼ã‚¸é‡ã‚’å–å¾—
    /// </summary>
    float GetDamage() const { return damage_; }

    /// <summary>
    /// ãƒ€ãƒ¡ãƒ¼ã‚¸é‡ã‚’è¨­å®š
    /// </summary>
    void SetDamage(float damage) { damage_ = damage; }

    /// <summary>
    /// é€Ÿåº¦ã‚’å–å¾—
    /// </summary>
    const Vector3& GetVelocity() const { return velocity_; }

    /// <summary>
    /// é€Ÿåº¦ã‚’è¨­å®š
    /// </summary>
    void SetVelocity(const Vector3& velocity) { velocity_ = velocity; }

    /// <summary>
    /// Transformã‚’å–å¾—
    /// </summary>
    const Transform& GetTransform() const { return transform_; }

    /// <summary>
    /// Transformå‚ç…§ã‚’å–å¾—ï¼ˆã‚³ãƒ©ã‚¤ãƒ€ãƒ¼è¨­å®šç”¨ï¼‰
    /// </summary>
    Transform* GetTransformPtr() { return &transform_; }

    /// <summary>
    /// ãƒ¢ãƒ‡ãƒ«ã‚’å–å¾—
    /// </summary>
    Object3d* GetModel() const { return model_.get(); }

protected:
    /// <summary>
    /// ç”Ÿå­˜æ™‚é–“ã‚’æ›´æ–°
    /// </summary>
    void UpdateLifetime(float deltaTime);

    /// <summary>
    /// ç§»å‹•å‡¦ç†
    /// </summary>
    virtual void Move(float deltaTime);

protected:
    /// <summary>
    /// 3Dãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆæç”»ç”¨ï¼‰
    /// </summary>
    std::unique_ptr<Object3d> model_;

    /// <summary>
    /// åº§æ¨™å¤‰æ›æƒ…å ±
    /// </summary>
    Transform transform_{};

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°
    /// </summary>
    bool isActive_ = false;

    /// <summary>
    /// é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
    /// </summary>
    Vector3 velocity_;

    /// <summary>
    /// ãƒ€ãƒ¡ãƒ¼ã‚¸é‡
    /// </summary>
    float damage_ = 10.0f;

    /// <summary>
    /// ç”Ÿå­˜æ™‚é–“
    /// </summary>
    float lifeTime_ = 5.0f;

    /// <summary>
    /// çµŒéŽæ™‚é–“
    /// </summary>
    float elapsedTime_ = 0.0f;
};

============================================================
File Path: GameProject/main.cpp
============================================================
#include"TakoFramework.h"
#include "MyGame/MyGame.h"
#include <memory>

//Windowsãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
  auto game = std::make_unique<MyGame>();

  game->Run();

  return 0;
}

============================================================
File Path: GameProject/scene/ClearScene.cpp
============================================================
#include "ClearScene.h"

#include "Draw2D.h"
#include "GPUParticle.h"
#include "Input.h"
#include "Object3dBasic.h"
#include "SceneManager.h"
#include "Sprite.h"
#include "SpriteBasic.h"

#ifdef _DEBUG
#include"ImGui.h"
#include "DebugCamera.h"
#endif

void ClearScene::Initialize()
{
#ifdef _DEBUG
    DebugCamera::GetInstance()->Initialize();
    Object3dBasic::GetInstance()->SetDebug(false);
    Draw2D::GetInstance()->SetDebug(false);
    GPUParticle::GetInstance()->SetIsDebug(false);
#endif

    /// ================================== ///
    ///              åˆæœŸåŒ–å‡¦ç†              ///
    /// ================================== ///

    // ã‚«ãƒ¡ãƒ©ã®å›žè»¢ã¨ä½ç½®ã‚’è¨­å®š
    (*Object3dBasic::GetInstance()->GetCamera())->SetRotate(Vector3(0.2f, 0.0f, 0.0f));
    (*Object3dBasic::GetInstance()->GetCamera())->SetTranslate(Vector3(0.0f, cameraHiddenY_, -34.0f));

    // spriteã®åˆæœŸåŒ–
    backGround_ = std::make_unique<Sprite>();
    backGround_->Initialize("black.png");
    backGround_->SetPos(Vector2(0.f, 0.f));
    backGround_->SetSize(Vector2(static_cast<float>(WinApp::clientWidth), static_cast<float>(WinApp::clientHeight)));

    titleText_ = std::make_unique<Sprite>();
    titleText_->Initialize("gameClear_Text.png");
    titleText_->SetPos(Vector2(WinApp::clientWidth / 2.f - titleTextHalfWidth_, titleTextY_));

    pressButtonText_ = std::make_unique<Sprite>();
    pressButtonText_->Initialize("title_button.png");
    pressButtonText_->SetPos(Vector2(
        WinApp::clientWidth / 2.f - pressButtonText_->GetSize().x / 2.f,
        WinApp::clientHeight - buttonBottomOffset_));

}


void ClearScene::Finalize()
{

}

void ClearScene::Update()
{
    /// ================================== ///
    ///              æ›´æ–°å‡¦ç†               ///
    /// ================================== ///

    backGround_->Update();
    titleText_->Update();
    pressButtonText_->Update();

    if (Input::GetInstance()->TriggerKey(DIK_SPACE))
    {
        SceneManager::GetInstance()->ChangeScene("title");
    }

    if (Input::GetInstance()->TriggerButton(XButtons.A)) {
        SceneManager::GetInstance()->ChangeScene("title");
    }
}

void ClearScene::Draw()
{
    /// ================================== ///
    ///              æç”»å‡¦ç†               ///
    /// ================================== ///
    //------------------èƒŒæ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();

    // èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    backGround_->Draw();


    //-------------------Modelã®æç”»-------------------//
    // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
    Object3dBasic::GetInstance()->SetCommonRenderSetting();




    //------------------å‰æ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();

    // ã‚¿ã‚¤ãƒˆãƒ«ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    titleText_->Draw();

    // ãƒ—ãƒ¬ã‚¹ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    pressButtonText_->Draw();

}

void ClearScene::DrawWithoutEffect()
{
    /// ================================== ///
    ///              æç”»å‡¦ç†               ///
    /// ================================== ///

    //------------------èƒŒæ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();




    //-------------------Modelã®æç”»-------------------//
    // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
    Object3dBasic::GetInstance()->SetCommonRenderSetting();





    //------------------å‰æ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();




}

void ClearScene::DrawImGui()
{
#ifdef _DEBUG

    /// ================================== ///
    ///             ImGuiã®æç”»              ///
    /// ================================== ///


#endif // _DEBUG
}

============================================================
File Path: GameProject/scene/ClearScene.h
============================================================
#pragma once
#include <memory>

#include "BaseScene.h"
#include "vector2.h"
#include "CameraSystem/CameraConfig.h"

class Sprite;

/// <summary>
/// ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹
/// ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ™‚ã®æ¼”å‡ºã¨çµæžœè¡¨ç¤ºã‚’ç®¡ç†
/// </summary>
class ClearScene : public BaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

  /// <summary>
  /// åˆæœŸåŒ–
  /// </summary>
  void Initialize() override;

  /// <summary>
  /// çµ‚äº†å‡¦ç†
  /// </summary>
  void Finalize() override;

  /// <summary>
  /// æ›´æ–°
  /// </summary>
  void Update() override;

  /// <summary>
  /// æç”»
  /// </summary>
  void Draw() override;
  void DrawWithoutEffect() override;

  /// <summary>
  /// ImGuiã®æç”»
  /// </summary>
  void DrawImGui() override;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

    // sprite
    std::unique_ptr<Sprite> backGround_ = nullptr;
    std::unique_ptr<Sprite> titleText_ = nullptr;
    std::unique_ptr<Sprite> pressButtonText_ = nullptr;

    // ã‚«ãƒ¡ãƒ©éžè¡¨ç¤ºYåº§æ¨™
    float cameraHiddenY_ = CameraConfig::HIDDEN_Y;

    // UIä½ç½®ãƒ»ã‚µã‚¤ã‚ºç”¨å¤‰æ•°
    float titleTextHalfWidth_ = 250.0f;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆåŠå¹…ï¼ˆã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°ç”¨ï¼‰
    float titleTextY_ = 300.0f;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆYåº§æ¨™
    float buttonBottomOffset_ = 300.0f;  ///< ãƒœã‚¿ãƒ³ä¸‹ç«¯ã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
};



============================================================
File Path: GameProject/scene/GameScene.cpp
============================================================
// Engine includes
#include "GameScene.h"
#include "ModelManager.h"
#include "Object3dBasic.h"
#include "SpriteBasic.h"
#include "Sprite.h"
#include "Input.h"
#include "Draw2D.h"
#include "FrameTimer.h"
#include "GPUParticle.h"
#include "SceneManager.h"
#include "EmitterManager.h"
#include "Object3d.h"
#include "Model.h"
#include "ShadowRenderer.h"
#include "CollisionManager.h"
#include "GlobalVariables.h"
#include "Vec3Func.h"

// Game includes
#include "../Collision/CollisionTypeIdDef.h"
#include "CameraSystem/CameraManager.h"
#include "CameraSystem/Controller/ThirdPersonController.h"
#include "CameraSystem/Controller/TopDownController.h"
#include "CameraSystem/Controller/CameraAnimationController.h"
#include "../Object/Projectile/BossBullet.h"
#include "Object/Player/State/PlayerState.h"
#include "Object/Player/State/PlayerStateMachine.h"

#include <algorithm>
#include <cmath>

// Debug includes
#ifdef _DEBUG
#include"ImGui.h"
#include "DebugCamera.h"
#include "DebugUIManager.h"
#include "CameraSystem/CameraDebugUI.h"
#endif

void GameScene::Initialize()
{
    // CollisionManagerã‚’å–å¾—
    CollisionManager* collisionManager = CollisionManager::GetInstance();
    collisionManager->Initialize();

    // GlobalVariablesã‚’å–å¾—
    GlobalVariables* gvScene = GlobalVariables::GetInstance();

    // EmitterManagerã®ç”Ÿæˆ
    emitterManager_ = std::make_unique<EmitterManager>(GPUParticle::GetInstance());

#ifdef _DEBUG
    DebugCamera::GetInstance()->Initialize();
    Object3dBasic::GetInstance()->SetDebug(false);
    Draw2D::GetInstance()->SetDebug(false);
    GPUParticle::GetInstance()->SetIsDebug(false);

    // ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã§ã¯ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼è¡¨ç¤ºã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ON
    collisionManager->SetDebugDrawEnabled(true);

    // DebugUIManagerã«ã‚·ãƒ¼ãƒ³åã‚’è¨­å®š
    DebugUIManager::GetInstance()->SetSceneName("GameScene");

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’DebugUIManagerã«ç™»éŒ²
    DebugUIManager::GetInstance()->RegisterGameObject("Player",
        [this]() { if (player_) player_->DrawImGui(); });
    DebugUIManager::GetInstance()->RegisterGameObject("Boss",
        [this]() { if (boss_) boss_->DrawImGui(); });

    // CameraSystemãƒ‡ãƒãƒƒã‚°UIç™»éŒ²
    DebugUIManager::GetInstance()->RegisterGameObject("CameraSystem",
        []() { CameraDebugUI::Draw(); });

    // CameraAnimationEditorãƒ‡ãƒãƒƒã‚°UIç™»éŒ²
    DebugUIManager::GetInstance()->RegisterGameObject("CameraAnimationEditor",
        []() {
            CameraDebugUI::DrawAnimationEditorOnly();
            // æ›´æ–°å‡¦ç†ã‚‚å‘¼ã³å‡ºã™
            CameraDebugUI::UpdateAnimationEditor(
                FrameTimer::GetInstance()->GetDeltaTime());
        });

    DebugUIManager::GetInstance()->SetEmitterManager(emitterManager_.get());
#endif
    /// ================================== ///
    ///              åˆæœŸåŒ–å‡¦ç†             ///
    /// ================================== ///

    // Input Handlerã®åˆæœŸåŒ–
    inputHandler_ = std::make_unique<InputHandler>();
    inputHandler_->Initialize();

    /// ----------------------GlobalVariablesè¨­å®š----------------------------------------------------///
    // GlobalVariablesç™»éŒ²ï¼ˆæç”»å“è³ªè¨­å®š
    gvScene->CreateGroup("GameScene");
    gvScene->AddItem("GameScene", "ShadowMaxDistance", 100.0f);
    gvScene->AddItem("GameScene", "DirectionalLightZ", -0.05f);
    // ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ç™»éŒ²
    gvScene->CreateGroup("DashEffect");
    gvScene->AddItem("DashEffect", "LerpSpeed", 35.0f);

    /// ----------------------ã‚·ãƒ¼ãƒ³ã®æç”»è¨­å®š---------------------------------------------------------///
    // ã‚·ãƒ£ãƒ‰ã‚¦ãƒžãƒƒãƒ”ãƒ³ã®æœ€å¤§æç”»è·é›¢ã®è¨­å®š
    float shadowMaxDist = gvScene->GetValueFloat("GameScene", "ShadowMaxDistance");
    ShadowRenderer::GetInstance()->SetMaxShadowDistance(shadowMaxDist);
    // å¹³è¡Œå…‰æºã®æ–¹å‘ã®è¨­å®š
    float lightZ = gvScene->GetValueFloat("GameScene", "DirectionalLightZ");
    Object3dBasic::GetInstance()->SetDirectionalLightDirection(Vector3(0.0f, -1.0f, lightZ));

    /// ----------------------ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–------------------------------------------------------ ///
    // ã‚¿ã‚¤ãƒˆãƒ«ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åˆæœŸåŒ–
    toTitleSprite_ = std::make_unique<Sprite>();
    toTitleSprite_->Initialize("game_button_text.png");
    toTitleSprite_->SetPos(Vector2(WinApp::clientWidth / 2.f - toTitleSprite_->GetSize().x / 2.f, 200.f));

    /// ----------------------3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–--------------------------------------------------- ///
    // SkyBoxã®åˆæœŸåŒ–
    skyBox_ = std::make_unique<SkyBox>();
    skyBox_->Initialize("my_skybox.dds");

    // åºŠãƒ¢ãƒ‡ãƒ«ã®UVå¤‰æ›è¨­å®š
    groundUvTransform_.translate = Vector3(0.0f, 0.0f, 0.0f);
    groundUvTransform_.rotate = Vector3(0.0f, 0.0f, 0.0f);
    groundUvTransform_.scale = Vector3(100.0f, 100.0f, 100.0f);
    // åºŠãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
    ground_ = std::make_unique<Object3d>();
    ground_->Initialize();
    ground_->SetModel("ground_black.gltf");
    ground_->SetUvTransform(groundUvTransform_);
    ground_->SetEnableHighlight(false);

    //-----------Playerã®åˆæœŸåŒ–----------------//
    player_ = std::make_unique<Player>();
    player_->Initialize();
    player_->SetCamera((*Object3dBasic::GetInstance()->GetCamera()));
    player_->SetInputHandler(inputHandler_.get());

    //-----------Bossã®åˆæœŸåŒ–--------------------//
    boss_ = std::make_unique<Boss>();
    boss_->Initialize();
    // ãƒœã‚¹ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‚ç…§ã‚’è¨­å®š
    boss_->SetPlayer(player_.get());
    // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã®æ¼”å‡ºãŒçµ‚ã‚ã‚‹ã¾ã§ä¸€æ™‚åœæ­¢çŠ¶æ…‹ã«è¨­å®š
    boss_->SetIsPause(true);

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒœã‚¹ã®å‚ç…§ã‚’è¨­å®š
    player_->SetBoss(boss_.get());

    /// ----------------------ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–------------------------------------------------- ///
    // ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
    cameraManager_ = CameraManager::GetInstance();
    cameraManager_->Initialize((*Object3dBasic::GetInstance()->GetCamera()));

    // ThirdPersonControllerã‚’ç™»éŒ²
    auto tpController = std::make_unique<ThirdPersonController>();
    firstPersonController_ = tpController.get();
    firstPersonController_->SetTarget(&player_->GetTransform());
    // ãƒœã‚¹ã‚’ã‚»ã‚«ãƒ³ãƒ€ãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦è¨­å®šã—ã€æ³¨è¦–æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–
    firstPersonController_->SetSecondaryTarget(&boss_->GetTransform());
    firstPersonController_->EnableLookAtTarget(true);
    cameraManager_->RegisterController("ThirdPerson", std::move(tpController));

    // TopDownControllerã‚’ç™»éŒ²
    auto tdController = std::make_unique<TopDownController>();
    topDownController_ = tdController.get();
    topDownController_->SetTarget(&player_->GetTransform());
    std::vector<const Transform*> additionalTargets = { &boss_->GetTransform() };
    topDownController_->SetAdditionalTargets(additionalTargets);
    cameraManager_->RegisterController("TopDown", std::move(tdController));

    // CameraAnimationControllerã‚’ç™»éŒ²
    auto animController = std::make_unique<CameraAnimationController>();
    animationController_ = animController.get();
    cameraManager_->RegisterController("Animation", std::move(animController));

    /// ----------------------è¡çªåˆ¤å®šã®åˆæœŸåŒ–--------------------------------------------------- ///
    // è¡çªãƒžã‚¹ã‚¯ã®è¨­å®šï¼ˆã©ã®ã‚¿ã‚¤ãƒ—åŒå£«ãŒè¡çªåˆ¤å®šã‚’è¡Œã†ã‹ï¼‰
    collisionManager->SetCollisionMask(
        static_cast<uint32_t>(CollisionTypeId::PLAYER_ATTACK),
        static_cast<uint32_t>(CollisionTypeId::BOSS),
        true
    );

    collisionManager->SetCollisionMask(
        static_cast<uint32_t>(CollisionTypeId::PLAYER),
        static_cast<uint32_t>(CollisionTypeId::BOSS_ATTACK),
        true
    );

    /// ----------------------ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–--------------------------------------------- ///
    // ã‚·ãƒ¼ãƒ³ã®ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚’ã¾ã¨ã‚ã¦èª­ã¿è¾¼ã‚€
    emitterManager_->LoadScenePreset("gamescene_preset");

    // ãƒœã‚¹ãƒ•ã‚§ãƒ¼ã‚º2ç”¨ã®å¢ƒç•Œç·šåˆæœŸçŠ¶æ…‹ã¯ç„¡åŠ¹åŒ–ï¼ˆãƒœã‚¹ãƒ•ã‚§ãƒ¼ã‚º2ã¾ã§éžè¡¨ç¤ºï¼‰
    emitterManager_->SetEmitterActive("boss_border_left", false);
    emitterManager_->SetEmitterActive("boss_border_right", false);
    emitterManager_->SetEmitterActive("boss_border_front", false);
    emitterManager_->SetEmitterActive("boss_border_back", false);

    // ãƒœã‚¹è¿‘æŽ¥æ”»æ’ƒäºˆå…†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®èª­ã¿è¾¼ã¿ã¨åˆæœŸåŒ–
    emitterManager_->LoadPreset("boss_attack_sign", "boss_melee_attack_sign");
    emitterManager_->SetEmitterActive("boss_melee_attack_sign", false);

    // ãƒœã‚¹ã«EmitterManagerã‚’è¨­å®š
    boss_->SetEmitterManager(emitterManager_.get());

    // ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ä½ç½®ã‚’åˆæœŸåŒ–
    dashEmitterPosition_ = player_->GetTranslate();


    // ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
    animationController_->LoadAnimationFromFile("game_start");
    cameraManager_->ActivateController("Animation");
    animationController_->SwitchAnimation("game_start");
    animationController_->Play();

    // ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®èª­ã¿è¾¼ã¿ã¨è¨­å®š
    animationController_->LoadAnimationFromFile("over_anim");
    animationController_->SetAnimationTargetByName("over_anim", player_->GetTransformPtr());

    // ã‚¯ãƒªã‚¢æ¼”å‡ºã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®èª­ã¿è¾¼ã¿ã¨è¨­å®š
    animationController_->LoadAnimationFromFile("clear_anim");
    animationController_->SetAnimationTargetByName("clear_anim", boss_->GetTransformPtr());
}

void GameScene::Finalize()
{
#ifdef _DEBUG
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®ç™»éŒ²è§£é™¤
    DebugUIManager::GetInstance()->ClearDebugInfo();
    // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç™»éŒ²è§£é™¤
    DebugUIManager::GetInstance()->ClearGameObjects();
    // AnimationEditorã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    CameraDebugUI::CleanupAnimationEditor();
#endif

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çµ‚äº†å‡¦ç†
    if (player_) {
        player_->Finalize();
    }
    if (boss_) {
        boss_->Finalize();
    }

    // CameraManagerã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    if (cameraManager_) {
        cameraManager_->Finalize();
    }

    // CollisionManagerã®ãƒªã‚»ãƒƒãƒˆ
    CollisionManager::GetInstance()->Reset();
}

void GameScene::Update()
{
    /// ================================== ///
    ///              æ›´æ–°å‡¦ç†               ///
    /// ================================== ///

#ifdef _DEBUG
    // Pã‚­ãƒ¼ã§ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    if (Input::GetInstance()->TriggerKey(DIK_P)) {
        cameraMode_ = !cameraMode_;
    }

#endif

    // ã‚²ãƒ¼ãƒ é–‹å§‹æ¼”å‡ºçµ‚äº†å¾Œã€ãƒœã‚¹ã®ä¸€æ™‚åœæ­¢ã‚’è§£é™¤
    if (animationController_->GetPlayState() != CameraAnimation::PlayState::PLAYING && !isStart_) {
        isStart_ = true;
        boss_->SetIsPause(false);
    }

    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢åˆ¤å®š
    if (boss_->IsDead()) {
        StartClearAnim();
    }

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
    if (player_->IsDead()) {
        StartOverAnim();
    }

    // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã®æ›´æ–°
    UpdateCameraMode();

    // å…¥åŠ›ã®æ›´æ–°
    UpdateInput();

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°å‡¦ç†
    skyBox_->Update();
    ground_->Update();
    player_->Update();
    boss_->Update(FrameTimer::GetInstance()->GetDeltaTime());
    toTitleSprite_->Update();
    cameraManager_->Update(FrameTimer::GetInstance()->GetDeltaTime());

    // ãƒœã‚¹ã‹ã‚‰ã®å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†
    CreateBossBullet();

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®å¼¾ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†
    CreatePlayerBullet();

    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚¿ã‚¤ãƒ«ã®æ›´æ–°
    float deltaTime = FrameTimer::GetInstance()->GetDeltaTime();
    UpdateProjectiles(deltaTime);

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã«ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
    emitterManager_->SetEmitterPosition("over1", player_->GetTranslate());
    emitterManager_->SetEmitterPosition("over2", player_->GetTranslate());

    // ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®Lerpè£œé–“å‡¦ç†
    UpdateDashEmitter(deltaTime);

    // ãƒœã‚¹ã®ä½ç½®ã«ã‚¯ãƒªã‚¢æ¼”å‡ºã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
    emitterManager_->SetEmitterPosition("clear_slash", boss_->GetTranslate());

    UpdateBossBorder();

    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®æ›´æ–°
    emitterManager_->Update();

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ›´æ–°
    UpdateOverAnim();

    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ›´æ–°
    UpdateClearAnim();

    // è¡çªåˆ¤å®šã®å®Ÿè¡Œ
    CollisionManager::GetInstance()->CheckAllCollisions();
}

void GameScene::Draw()
{
    /// ================================== ///
    ///              æç”»å‡¦ç†               ///
    /// ================================== ///

    //-------------------SkyBoxã®æç”»-------------------//
    skyBox_->Draw();

    //------------------ã‚·ãƒ£ãƒ‰ã‚¦ãƒžãƒƒãƒ—ã®æç”»------------------//
    if (ShadowRenderer::GetInstance()->IsEnabled()) {
        ShadowRenderer::GetInstance()->BeginShadowPass();
        ground_->Draw();
        player_->Draw();
        boss_->Draw();
        ShadowRenderer::GetInstance()->EndShadowPass();
    }

    //------------------èƒŒæ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();



    //-------------------Modelã®æç”»-------------------//
    // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
    Object3dBasic::GetInstance()->SetCommonRenderSetting();

    ground_->Draw();
    player_->Draw();
    boss_->Draw();

    //------------------å‰æ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();


#ifdef _DEBUG
    // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒ‡ãƒãƒƒã‚°æç”»
    CollisionManager::GetInstance()->DrawColliders();
#endif

}

void GameScene::DrawWithoutEffect()
{
    /// ================================== ///
    ///              æç”»å‡¦ç†               ///
    /// ================================== ///

    //------------------èƒŒæ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();



    //-------------------Modelã®æç”»-------------------//
     // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
    Object3dBasic::GetInstance()->SetCommonRenderSetting();



    //------------------å‰æ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();

    player_->DrawSprite();
    boss_->DrawSprite();
}

void GameScene::DrawImGui()
{
#ifdef _DEBUG

#endif // DEBUG
}

void GameScene::StartOverAnim()
{
    if (isOver_) return;

    cameraManager_->DeactivateAllControllers();
    cameraManager_->ActivateController("Animation");
    animationController_->SwitchAnimation("over_anim");
    animationController_->Play();
    isOver_ = true;
}

void GameScene::UpdateOverAnim()
{
    // ã‚ªãƒ¼ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒžãƒ¼ã®æ›´æ–°
    if (isOver_) overAnimTimer_ += FrameTimer::GetInstance()->GetDeltaTime();

    // ã‚ªãƒ¼ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã®ã‚¨ãƒŸãƒƒã‚¿ãƒ¼åˆ¶å¾¡
    if (overAnimTimer_ > overEmit1Time_ && !isOver1Emit_) {
        emitterManager_->CreateTemporaryEmitterFrom("over1", "over1_temp", 0.5f);
        isOver1Emit_ = true;
    }

    if (overAnimTimer_ > overEmit2Time_ && !isOver2Emit_) {
        emitterManager_->CreateTemporaryEmitterFrom("over2", "over2_temp", 0.1f);
        isOver2Emit_ = true;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ã®æ¸›å°‘
    if (isOver2Emit_) {
        Vector3 newScale = player_->GetScale() - Vector3(scaleDecreaseRate_, scaleDecreaseRate_, scaleDecreaseRate_) * FrameTimer::GetInstance()->GetDeltaTime();
        newScale.x = std::max<float>(newScale.x, 0.0f);
        newScale.y = std::max<float>(newScale.y, 0.0f);
        newScale.z = std::max<float>(newScale.z, 0.0f);
        player_->SetScale(newScale);
    }

    // ã‚·ãƒ¼ãƒ³é·ç§»
    if (overAnimTimer_ > overTotalTime_) {
        SceneManager::GetInstance()->ChangeScene("over", "Fade", 0.3f);
    }
}

void GameScene::StartClearAnim()
{
    if (isClear_) return;

    cameraManager_->DeactivateAllControllers();
    cameraManager_->ActivateController("Animation");
    animationController_->SwitchAnimation("clear_anim");
    animationController_->Play();
    boss_->SetIsPause(true);
    player_->SetScale(Vector3(0.f, 0.f, 0.f)); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’éžè¡¨ç¤ºã«ã™ã‚‹ãŸã‚ã‚¹ã‚±ãƒ¼ãƒ«ã‚’0ã«è¨­å®š
    isClear_ = true;
}

void GameScene::UpdateClearAnim()
{
    // ã‚ªãƒ¼ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒžãƒ¼ã®æ›´æ–°
    if (isClear_) clearAnimTimer_ += FrameTimer::GetInstance()->GetDeltaTime();

    // ã‚ªãƒ¼ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã®ã‚¨ãƒŸãƒƒã‚¿ãƒ¼åˆ¶å¾¡
    if (clearAnimTimer_ > 0.5f && !isClear1Emit_) {
        emitterManager_->SetEmitterActive("clear_slash", true);
        emitterManager_->SetEmitterCount("clear_slash", currentSlashCount_);
        emitterManager_->SetEmitterRadius("clear_slash", currentSlashRadius_);

        boss_->StartShake(0.4f);

        if (currentSlashCount_ < kSlashEmitterMaxCount_ || currentSlashRadius_ < kSlashEmitterMaxRadius_) {
            currentSlashCount_ += 1;
            currentSlashRadius_ += 0.05f;
        }
        else {
            emitterManager_->SetEmitterActive("clear_slash", false);
            isClear1Emit_ = true;
        }
    }

    if (isClear1Emit_ && !isClear2Emit_) {

        boss_->StartShake(0.4f);

        emitterManager_->SetEmitterPosition("over2", boss_->GetTranslate());
        emitterManager_->CreateTemporaryEmitterFrom("over2", "over2_temp", 0.1f);
        isClear2Emit_ = true;
    }

    // ãƒœã‚¹ã‚¹ã‚±ãƒ¼ãƒ«ã®æ¸›å°‘
    if (isClear2Emit_) {
        Vector3 newScale = boss_->GetScale() - Vector3(scaleDecreaseRate_, scaleDecreaseRate_, scaleDecreaseRate_) * FrameTimer::GetInstance()->GetDeltaTime();
        newScale.x = std::max<float>(newScale.x, 0.0f);
        newScale.y = std::max<float>(newScale.y, 0.0f);
        newScale.z = std::max<float>(newScale.z, 0.0f);
        boss_->SetScale(newScale);
    }

    // ã‚·ãƒ¼ãƒ³é·ç§»
    if (boss_->GetScale().x <= 0.f) {
        SceneManager::GetInstance()->ChangeScene("clear", "Fade", 0.3f);
    }
}

void GameScene::UpdateCameraMode()
{
    if (player_->IsDead() || boss_->IsDead() || !isStart_) {
        return;
    }

    if (boss_->GetPhase() == 1) {
        cameraMode_ = false;
        // ãƒ•ã‚§ãƒ¼ã‚º1: å‹•çš„åˆ¶é™ã‚’è§£é™¤ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸å…¨ä½“ã‚’ç§»å‹•å¯èƒ½ï¼‰
        player_->ClearDynamicBounds();
    }
    else if (boss_->GetPhase() == 2) {
        cameraMode_ = true;
        // ãƒ•ã‚§ãƒ¼ã‚º2: ãƒœã‚¹ä¸­å¿ƒã®æˆ¦é—˜ã‚¨ãƒªã‚¢ã«ç§»å‹•åˆ¶é™
        Vector3 bossPos = boss_->GetTransform().translate;
        player_->SetDynamicBoundsFromCenter(bossPos, battleAreaSize_, battleAreaSize_);
    }

    if (cameraMode_) {
        cameraManager_->ActivateController("ThirdPerson");
    }
    else {
        cameraManager_->ActivateController("TopDown");
    }

    // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã‚’Playerã«è¨­å®š
    player_->SetMode(cameraMode_);

}

void GameScene::UpdateInput()
{
    // å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®æ›´æ–°ã€‚ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿä¸­ã€ãƒ‡ãƒãƒƒã‚°ã‚«ãƒ¡ãƒ©æ“ä½œä¸­ã¯å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆã—ã€æ“ä½œã‚’å—ã‘ä»˜ã‘ãªã„
    if (animationController_->GetPlayState() != CameraAnimation::PlayState::PLAYING
#ifdef  _DEBUG
        && !Object3dBasic::GetInstance()->GetDebug()
#endif
        ) {
        inputHandler_->Update();

    }
    else {
        inputHandler_->ResetInputs();
    }
}

void GameScene::UpdateProjectiles(float deltaTime)
{
    // ãƒœã‚¹ã®å¼¾ã®æ›´æ–°
    for (auto& bullet : bossBullets_) {
        if (bullet && bullet->IsActive()) {
            bullet->Update(deltaTime);
        }
    }

    // éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒœã‚¹ã®å¼¾ã‚’å‰Šé™¤
    std::erase_if(bossBullets_,
        [](const std::unique_ptr<BossBullet>& bullet) {
            if (bullet && !bullet->IsActive()) {
                // Finalize()ã§è‡ªå‹•çš„ã«ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ãŒå‰Šé™¤ã•ã‚Œã‚‹
                bullet->Finalize();
                return true;
            }
            return false;
        });

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã®æ›´æ–°
    for (auto& bullet : playerBullets_) {
        if (bullet && bullet->IsActive()) {
            bullet->Update(deltaTime);
        }
    }

    // éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã‚’å‰Šé™¤
    std::erase_if(playerBullets_,
        [](const std::unique_ptr<PlayerBullet>& bullet) {
            if (bullet && !bullet->IsActive()) {
                // Finalize()ã§è‡ªå‹•çš„ã«ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ãŒå‰Šé™¤ã•ã‚Œã‚‹
                bullet->Finalize();
                return true;
            }
            return false;
        });
}

void GameScene::UpdateBossBorder()
{
    // ãƒœã‚¹ãƒ•ã‚§ãƒ¼ã‚º2ã®å¢ƒç•Œç·šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åˆ¶å¾¡
    if (boss_) {
        bool shouldShowBorder = (boss_->GetPhase() == 2);

        if (shouldShowBorder && !borderEmittersActive_) {
            Vector3 bossPos = boss_->GetTransform().translate;

            // ãƒ•ã‚§ãƒ¼ã‚º2çªå…¥æ™‚ï¼šå¢ƒç•Œç·šã‚’æœ‰åŠ¹åŒ–
            emitterManager_->SetEmitterActive("boss_border_left", true);
            emitterManager_->SetEmitterActive("boss_border_right", true);
            emitterManager_->SetEmitterActive("boss_border_front", true);
            emitterManager_->SetEmitterActive("boss_border_back", true);

            borderEmittersActive_ = true;
        }
        else if (!shouldShowBorder && borderEmittersActive_) {
            // ãƒ•ã‚§ãƒ¼ã‚º1ã«æˆ»ã£ãŸæ™‚ï¼šå¢ƒç•Œç·šã‚’ç„¡åŠ¹åŒ–
            emitterManager_->SetEmitterActive("boss_border_left", false);
            emitterManager_->SetEmitterActive("boss_border_right", false);
            emitterManager_->SetEmitterActive("boss_border_front", false);
            emitterManager_->SetEmitterActive("boss_border_back", false);

            borderEmittersActive_ = false;
        }

        if (borderEmittersActive_) {
            // ãƒ•ã‚§ãƒ¼ã‚º2ç¶™ç¶šä¸­ï¼šãƒœã‚¹ã®ç§»å‹•ã«è¿½å¾“
            Vector3 bossPos = Vector3(boss_->GetTransform().translate.x, 0.f, boss_->GetTransform().translate.z);

            emitterManager_->SetEmitterPosition("boss_border_left",
                bossPos + Vector3(0.0f, 0.0f, -battleAreaSize_));
            emitterManager_->SetEmitterPosition("boss_border_right",
                bossPos + Vector3(0.0f, 0.0f, battleAreaSize_));
            emitterManager_->SetEmitterPosition("boss_border_front",
                bossPos + Vector3(-battleAreaSize_, 0.0f, 0.0f));
            emitterManager_->SetEmitterPosition("boss_border_back",
                bossPos + Vector3(battleAreaSize_, 0.0f, 0.0f));
        }
    }
}

void GameScene::CreateBossBullet()
{
    for (const auto& request : boss_->ConsumePendingBullets()) {
        auto bullet = std::make_unique<BossBullet>(emitterManager_.get());
        bullet->Initialize(request.position, request.velocity);
        bossBullets_.push_back(std::move(bullet));
    }
}

void GameScene::CreatePlayerBullet()
{
    for (const auto& request : player_->ConsumePendingBullets()) {
        auto bullet = std::make_unique<PlayerBullet>(emitterManager_.get());
        bullet->Initialize(request.position, request.velocity);
        playerBullets_.push_back(std::move(bullet));
    }
}

void GameScene::UpdateDashEmitter(float deltaTime)
{
    // ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã®åˆ¤å®š
    bool isDashing = false;
    if (player_ && player_->GetStateMachine() && player_->GetStateMachine()->GetCurrentState()) {
        isDashing = (player_->GetStateMachine()->GetCurrentState()->GetName() == "Dash");
    }

    // ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹æ™‚: ã‚¨ãƒŸãƒƒã‚¿ãƒ¼æœ‰åŠ¹åŒ– & ä½ç½®ãƒªã‚»ãƒƒãƒˆ
    if (isDashing && !previousIsDashing_) {
        emitterManager_->SetEmitterActive("player_dash", true);
        dashEmitterActive_ = true;
        dashEmitterPosition_ = player_->GetTranslate();
    }

    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªé–“ã¯è£œé–“ã‚’ç¶™ç¶šï¼ˆãƒ€ãƒƒã‚·ãƒ¥çµ‚äº†å¾Œã‚‚è¿½ã„ã¤ãã¾ã§ç¶šã‘ã‚‹ï¼‰
    if (dashEmitterActive_) {
        // GlobalVariablesã‹ã‚‰è£œé–“é€Ÿåº¦ã‚’å–å¾—
        float lerpSpeed = GlobalVariables::GetInstance()->GetValueFloat("DashEffect", "LerpSpeed");

        // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆéžä¾å­˜ã®æŒ‡æ•°æ¸›è¡°è£œé–“
        // t = 1 - e^(-speed * dt) ã§ã€ã©ã®FPSã§ã‚‚åŒã˜è¦–è¦šçš„çµæžœ
        float t = 1.0f - std::exp(-lerpSpeed * deltaTime);

        // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ä½ç½®ã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã«å‘ã‹ã£ã¦è£œé–“
        dashEmitterPosition_ = Vec3::Lerp(dashEmitterPosition_, player_->GetTranslate(), t);

        // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ä½ç½®ã‚’æ›´æ–°
        emitterManager_->SetEmitterPosition("player_dash", dashEmitterPosition_);

        // ãƒ€ãƒƒã‚·ãƒ¥çµ‚äº†å¾Œã€ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã«ååˆ†è¿‘ã¥ã„ãŸã‚‰ç„¡åŠ¹åŒ–
        if (!isDashing) {
            Vector3 diff = player_->GetTranslate() - dashEmitterPosition_;
            float distanceSquared = diff.x * diff.x + diff.y * diff.y + diff.z * diff.z;

            if (distanceSquared < dashEmitterThreshold_ * dashEmitterThreshold_) {
                emitterManager_->SetEmitterActive("player_dash", false);
                dashEmitterActive_ = false;
            }
        }
    }

    // çŠ¶æ…‹ã‚’ä¿å­˜
    previousIsDashing_ = isDashing;
}

============================================================
File Path: GameProject/scene/GameScene.h
============================================================
#pragma once
#include "BaseScene.h"
#include "Transform.h"
#include  "SkyBox.h"
#include "Object/Boss/Boss.h"
#include "Object/Player/Player.h"
#include "Input/InputHandler.h"
#include "../Object/Projectile/BossBullet.h"
#include "../Object/Projectile/PlayerBullet.h"

#include <memory>
#include <vector>

// ã‚¯ãƒ©ã‚¹å‰æ–¹å®£è¨€
class Object3d;
class EmitterManager;
class Sprite;
class BoneTracker;
class CameraManager;
class ThirdPersonController;
class TopDownController;
class CameraAnimationController;
class BossBullet;
class PlayerBullet;

/// <summary>
/// ã‚²ãƒ¼ãƒ ãƒ¡ã‚¤ãƒ³ã‚·ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ãƒœã‚¹ã®æˆ¦é—˜ã€ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®ä¸­æ ¸ã‚’ç®¡ç†
/// </summary>
class GameScene : public BaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    void Initialize() override;

    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize() override;

    /// <summary>
    /// æ›´æ–°
    /// </summary>
    void Update() override;

    /// <summary>
    /// æç”»
    /// </summary>
    void Draw() override;
    void DrawWithoutEffect() override;

    /// <summary>
    /// ImGuiã®æç”»
    /// </summary>
    void DrawImGui() override;

    /// <summary>
    /// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºé–‹å§‹
    /// </summary>
    void StartOverAnim();

    /// <summary>
    /// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºæ›´æ–°
    /// </summary>
    void UpdateOverAnim();

    /// <summary>
    /// ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ¼”å‡ºé–‹å§‹
    /// </summary>
    void StartClearAnim();

    /// <summary>
    /// ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ¼”å‡ºæ›´æ–°
    /// </summary>
    void UpdateClearAnim();

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void UpdateCameraMode();

    /// <summary>
    /// å…¥åŠ›å‡¦ç†ã®æ›´æ–°
    /// </summary>
    void UpdateInput();

    /// <summary>
    /// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚¿ã‚¤ãƒ«ï¼ˆå¼¾ï¼‰ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void UpdateProjectiles(float deltaTime);

    /// <summary>
    /// ãƒœã‚¹ãƒ•ã‚§ãƒ¼ã‚º2ã®å¢ƒç•Œç·šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åˆ¶å¾¡
    /// </summary>
    void UpdateBossBorder();

    /// <summary>
    /// ãƒœã‚¹ã®å¼¾ã®ç”Ÿæˆå‡¦ç†
    /// </summary>
    void CreateBossBullet();

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã®ç”Ÿæˆå‡¦ç†
    /// </summary>
    void CreatePlayerBullet();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

    std::unique_ptr<SkyBox> skyBox_;                            // ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ï¼ˆç’°å¢ƒãƒžãƒƒãƒ—ï¼‰

    std::unique_ptr<Object3d> ground_;                          // åœ°é¢ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

    std::unique_ptr<Player> player_;                            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼

    std::unique_ptr<Boss> boss_;                                // ãƒœã‚¹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼

    std::vector<std::unique_ptr<BossBullet>> bossBullets_;      // ãƒœã‚¹ã®å¼¾ã®ã‚³ãƒ³ãƒ†ãƒŠ

    std::vector<std::unique_ptr<PlayerBullet>> playerBullets_;  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã®ã‚³ãƒ³ãƒ†ãƒŠ

    std::unique_ptr<InputHandler> inputHandler_;                // å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ãƒ¼

    // Camera system components
    CameraManager* cameraManager_ = nullptr;                    // ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†
    ThirdPersonController* firstPersonController_ = nullptr;    // ä¸€äººç§°è¦–ç‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
    TopDownController* topDownController_ = nullptr;            // ãƒˆãƒƒãƒ—ãƒ€ã‚¦ãƒ³è¦–ç‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
    CameraAnimationController* animationController_ = nullptr;  // ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
    bool cameraMode_ = false;                                   // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ (true: FirstPerson, false: TopDown)

    Transform groundUvTransform_{};                             // åœ°é¢ã®UVãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç­‰ã«ä½¿ç”¨ï¼‰

    std::unique_ptr<EmitterManager> emitterManager_;            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç®¡ç†

    std::unique_ptr<Sprite> toTitleSprite_;                     // ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

    bool isStart_ = false;                                      // ã‚²ãƒ¼ãƒ é–‹å§‹ãƒ•ãƒ©ã‚°
    
    // ãƒœã‚¹ãƒ•ã‚§ãƒ¼ã‚º2å¢ƒç•Œç·šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç®¡ç†
    bool borderEmittersActive_ = false;                         // å¢ƒç•Œç·šã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹

    float battleAreaSize_ = 20.0f;                              // æˆ¦é—˜ã‚¨ãƒªã‚¢ã®ã‚µã‚¤ã‚º

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºé–¢é€£
    float overAnimTimer_ = 0.0f;                                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºã‚¿ã‚¤ãƒžãƒ¼
    bool isOver_ = false;                                       // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ©ã‚°
    bool isOver1Emit_ = false;                                  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºç”¨ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç™ºç”Ÿãƒ•ãƒ©ã‚°
    bool isOver2Emit_ = false;                                  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºç”¨ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç™ºç”Ÿãƒ•ãƒ©ã‚°

    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ¼”å‡ºé–¢é€£
    float clearAnimTimer_ = 0.0f;                               // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ¼”å‡ºã‚¿ã‚¤ãƒžãƒ¼
    bool isClear_ = false;                                      // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ãƒ•ãƒ©ã‚°
    bool isClear1Emit_ = false;                                 // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ¼”å‡ºç”¨ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç™ºç”Ÿãƒ•ãƒ©ã‚°
    bool isClear2Emit_ = false;                                 // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ¼”å‡ºç”¨ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç™ºç”Ÿãƒ•ãƒ©ã‚°
    const uint32_t kSlashEmitterMaxCount_ = 100;                // æ–¬æ’ƒã‚¨ãƒŸãƒƒã‚¿ãƒ¼æœ€å¤§æ•°
    const float kSlashEmitterMaxRadius_ = 10.0f;                // æ–¬æ’ƒã‚¨ãƒŸãƒƒã‚¿ãƒ¼æœ€å¤§ç™ºç”ŸåŠå¾„
    uint32_t currentSlashCount_ = 1;                            // ç¾åœ¨ã®æ–¬æ’ƒç™ºç”Ÿæ•°
    float currentSlashRadius_ = 2.f;                            // ç¾åœ¨ã®æ–¬æ’ƒç™ºç”ŸåŠå¾„

    bool isDebug_ = false;                                      // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°

    // ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè£œé–“ç”¨
    Vector3 dashEmitterPosition_{};                              // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®è£œé–“ä½ç½®
    bool previousIsDashing_ = false;                             // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹
    bool dashEmitterActive_ = false;                             // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹

    /// <summary>
    /// ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®æ›´æ–°ï¼ˆLerpè£œé–“ï¼‰
    /// </summary>
    /// <param name="deltaTime">ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®çµŒéŽæ™‚é–“</param>
    void UpdateDashEmitter(float deltaTime);

    // èª¿æ•´å¯èƒ½ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆæ¼”å‡ºèª¿æ•´ç”¨ï¼‰
    float overEmit1Time_ = 2.0f;             ///< ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºã‚¨ãƒŸãƒƒã‚¿ãƒ¼1ç™ºç”Ÿæ™‚é–“
    float overEmit2Time_ = 2.8f;             ///< ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºã‚¨ãƒŸãƒƒã‚¿ãƒ¼2ç™ºç”Ÿæ™‚é–“
    float overTotalTime_ = 3.8f;             ///< ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºç·æ™‚é–“
    float scaleDecreaseRate_ = 5.0f;         ///< ã‚¹ã‚±ãƒ¼ãƒ«æ¸›å°‘é€Ÿåº¦
    float dashEmitterThreshold_ = 0.65f;     ///< ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒŸãƒƒã‚¿ãƒ¼è¿½å¾“é–¾å€¤
};

============================================================
File Path: GameProject/scene/OverScene.cpp
============================================================
#include "OverScene.h"
#include "ClearScene.h"

#include "Draw2D.h"
#include "GPUParticle.h"
#include "Input.h"
#include "Object3dBasic.h"
#include "SceneManager.h"
#include "Sprite.h"
#include "SpriteBasic.h"

#ifdef _DEBUG
#include"ImGui.h"
#include "DebugCamera.h"
#endif

void OverScene::Initialize()
{
#ifdef _DEBUG
    DebugCamera::GetInstance()->Initialize();
    Object3dBasic::GetInstance()->SetDebug(false);
    Draw2D::GetInstance()->SetDebug(false);
    GPUParticle::GetInstance()->SetIsDebug(false);
#endif

    /// ================================== ///
    ///              åˆæœŸåŒ–å‡¦ç†              ///
    /// ================================== ///

    // ã‚«ãƒ¡ãƒ©ã®å›žè»¢ã¨ä½ç½®ã‚’è¨­å®š
    (*Object3dBasic::GetInstance()->GetCamera())->SetRotate(Vector3(0.2f, 0.0f, 0.0f));
    (*Object3dBasic::GetInstance()->GetCamera())->SetTranslate(Vector3(0.0f, cameraHiddenY_, -34.0f));

    // spriteã®åˆæœŸåŒ–
    backGround_ = std::make_unique<Sprite>();
    backGround_->Initialize("black.png");
    backGround_->SetPos(Vector2(0.f, 0.f));
    backGround_->SetSize(Vector2(static_cast<float>(WinApp::clientWidth), static_cast<float>(WinApp::clientHeight)));

    titleText_ = std::make_unique<Sprite>();
    titleText_->Initialize("gameOver_Text.png");
    titleText_->SetPos(Vector2(WinApp::clientWidth / 2.f - titleTextHalfWidth_, titleTextY_));

    pressButtonText_ = std::make_unique<Sprite>();
    pressButtonText_->Initialize("title_button.png");
    pressButtonText_->SetPos(Vector2(
        WinApp::clientWidth / 2.f - pressButtonText_->GetSize().x / 2.f,
        WinApp::clientHeight - buttonBottomOffset_));

}


void OverScene::Finalize()
{

}

void OverScene::Update()
{
    /// ================================== ///
    ///              æ›´æ–°å‡¦ç†               ///
    /// ================================== ///

    backGround_->Update();
    titleText_->Update();
    pressButtonText_->Update();

    if (Input::GetInstance()->TriggerKey(DIK_SPACE))
    {
        SceneManager::GetInstance()->ChangeScene("title");
    }

    if (Input::GetInstance()->TriggerButton(XButtons.A)) {
        SceneManager::GetInstance()->ChangeScene("title");
    }
}

void OverScene::Draw()
{
    /// ================================== ///
    ///              æç”»å‡¦ç†               ///
    /// ================================== ///
    //------------------èƒŒæ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();

    // èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    backGround_->Draw();


    //-------------------Modelã®æç”»-------------------//
    // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
    Object3dBasic::GetInstance()->SetCommonRenderSetting();




    //------------------å‰æ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();

    // ã‚¿ã‚¤ãƒˆãƒ«ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    titleText_->Draw();

    // ãƒ—ãƒ¬ã‚¹ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    pressButtonText_->Draw();

}

void OverScene::DrawWithoutEffect()
{
    /// ================================== ///
    ///              æç”»å‡¦ç†               ///
    /// ================================== ///

    //------------------èƒŒæ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();




    //-------------------Modelã®æç”»-------------------//
    // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
    Object3dBasic::GetInstance()->SetCommonRenderSetting();





    //------------------å‰æ™¯Spriteã®æç”»------------------//
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
    SpriteBasic::GetInstance()->SetCommonRenderSetting();




}

void OverScene::DrawImGui()
{
#ifdef _DEBUG

    /// ================================== ///
    ///             ImGuiã®æç”»              ///
    /// ================================== ///


#endif // _DEBUG
}

============================================================
File Path: GameProject/scene/OverScene.h
============================================================
#pragma once
#include <memory>

#include "BaseScene.h"
#include "vector2.h"
#include "CameraSystem/CameraConfig.h"

class Sprite;

/// <summary>
/// ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹
/// ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ™‚ã®æ¼”å‡ºã¨çµæžœè¡¨ç¤ºã‚’ç®¡ç†
/// </summary>
class OverScene : public BaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    void Initialize() override;

    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize() override;

    /// <summary>
    /// æ›´æ–°
    /// </summary>
    void Update() override;

    /// <summary>
    /// æç”»
    /// </summary>
    void Draw() override;
    void DrawWithoutEffect() override;

    /// <summary>
    /// ImGuiã®æç”»
    /// </summary>
    void DrawImGui() override;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

    // sprite
    std::unique_ptr<Sprite> backGround_ = nullptr;
    std::unique_ptr<Sprite> titleText_ = nullptr;
    std::unique_ptr<Sprite> pressButtonText_ = nullptr;

    // ã‚«ãƒ¡ãƒ©éžè¡¨ç¤ºYåº§æ¨™
    float cameraHiddenY_ = CameraConfig::HIDDEN_Y;

    // UIä½ç½®ãƒ»ã‚µã‚¤ã‚ºç”¨å¤‰æ•°
    float titleTextHalfWidth_ = 250.0f;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆåŠå¹…ï¼ˆã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°ç”¨ï¼‰
    float titleTextY_ = 300.0f;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆYåº§æ¨™
    float buttonBottomOffset_ = 300.0f;  ///< ãƒœã‚¿ãƒ³ä¸‹ç«¯ã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
};



============================================================
File Path: GameProject/scene/SampleScene.cpp
============================================================
#include "SampleScene.h"

#include "Draw2D.h"
#include "GPUParticle.h"
#include "Input.h"
#include "Object3dBasic.h"
#include "SceneManager.h"
#include "SpriteBasic.h"

#ifdef _DEBUG
#include"ImGui.h"
#include "DebugCamera.h"
#endif

void SampleScene::Initialize()
{
#ifdef _DEBUG
  DebugCamera::GetInstance()->Initialize();
  Object3dBasic::GetInstance()->SetDebug(false);
  Draw2D::GetInstance()->SetDebug(false);
  GPUParticle::GetInstance()->SetIsDebug(false);
#endif

  /// ================================== ///
  ///              åˆæœŸåŒ–å‡¦ç†              ///
  /// ================================== ///


}


void SampleScene::Finalize()
{

}

void SampleScene::Update()
{
  /// ================================== ///
  ///              æ›´æ–°å‡¦ç†               ///
  /// ================================== ///



  if (Input::GetInstance()->TriggerKey(DIK_RETURN))
  {
    SceneManager::GetInstance()->ChangeScene("");
  }
}

void SampleScene::Draw()
{
  /// ================================== ///
  ///              æç”»å‡¦ç†               ///
  /// ================================== ///
  //------------------èƒŒæ™¯Spriteã®æç”»------------------//
  // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
  SpriteBasic::GetInstance()->SetCommonRenderSetting();




  //-------------------Modelã®æç”»-------------------//
  // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
  Object3dBasic::GetInstance()->SetCommonRenderSetting();




  //------------------å‰æ™¯Spriteã®æç”»------------------//
  // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
  SpriteBasic::GetInstance()->SetCommonRenderSetting();



}

void SampleScene::DrawWithoutEffect()
{
  /// ================================== ///
  ///              æç”»å‡¦ç†               ///
  /// ================================== ///

  //------------------èƒŒæ™¯Spriteã®æç”»------------------//
  // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
  SpriteBasic::GetInstance()->SetCommonRenderSetting();




  //-------------------Modelã®æç”»-------------------//
  // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
  Object3dBasic::GetInstance()->SetCommonRenderSetting();





  //------------------å‰æ™¯Spriteã®æç”»------------------//
  // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
  SpriteBasic::GetInstance()->SetCommonRenderSetting();




}

void SampleScene::DrawImGui()
{
#ifdef _DEBUG

  /// ================================== ///
  ///             ImGuiã®æç”»              ///
  /// ================================== ///


#endif // _DEBUG
}

============================================================
File Path: GameProject/scene/SampleScene.h
============================================================
#pragma once
#include "BaseScene.h"

/// <summary>
/// ã‚µãƒ³ãƒ—ãƒ«ã‚·ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹
/// TakoEngineã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚·ãƒ¼ãƒ³ã®æ§‹æˆã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚
/// </summary>
class SampleScene : public BaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

  /// <summary>
  /// åˆæœŸåŒ–
  /// </summary>
  void Initialize() override;

  /// <summary>
  /// çµ‚äº†å‡¦ç†
  /// </summary>
  void Finalize() override;

  /// <summary>
  /// æ›´æ–°
  /// </summary>
  void Update() override;

  /// <summary>
  /// æç”»
  /// </summary>
  void Draw() override;
  void DrawWithoutEffect() override;

  /// <summary>
  /// ImGuiã®æç”»
  /// </summary>
  void DrawImGui() override;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°


};


============================================================
File Path: GameProject/scene/SceneFactory.cpp
============================================================
#include "SceneFactory.h"

#include "ClearScene.h"
#include "TitleScene.h"
#include "GameScene.h"
#include "OverScene.h"

#ifdef _DEBUG
#include "DebugUIManager.h"
#endif

std::unique_ptr<BaseScene> SceneFactory::CreateScene(const std::string& sceneName)
{
  if (sceneName == "title") {
    return std::make_unique<TitleScene>();
  } else if (sceneName == "game") {
    return std::make_unique<GameScene>();
  } else if (sceneName == "clear") {
    return std::make_unique<ClearScene>();
  } else if (sceneName == "over") {
    return std::make_unique<OverScene>();
  }

#ifdef _DEBUG
  DebugUIManager::GetInstance()->AddLog("Unknown scene name: " + sceneName, DebugUIManager::LogType::Error);
#endif

  return nullptr;
}


============================================================
File Path: GameProject/scene/SceneFactory.h
============================================================
#pragma once
#include "AbstractSceneFactory.h"
#include <memory>

/// <summary>
/// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚¯ãƒ©ã‚¹
/// ã‚·ãƒ¼ãƒ³åã‹ã‚‰å¯¾å¿œã™ã‚‹ã‚·ãƒ¼ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
/// </summary>
class SceneFactory : public AbstractSceneFactory
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName">ç”Ÿæˆã™ã‚‹ã‚·ãƒ¼ãƒ³å</param>
	/// <returns>ç”Ÿæˆã•ã‚ŒãŸã‚·ãƒ¼ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆç”Ÿæˆå¤±æ•—æ™‚ã¯nullptrï¼‰</returns>
	std::unique_ptr<BaseScene> CreateScene(const std::string& sceneName) override;

};


============================================================
File Path: GameProject/scene/TitleScene.cpp
============================================================
#include "TitleScene.h"

#include "SceneManager.h"
#include "Object3dBasic.h"
#include "SpriteBasic.h"
#include "ModelManager.h"
#include "Input.h"
#include "Draw2D.h"
#include "GPUParticle.h"
#include <cmath>
#include <numbers>

#ifdef _DEBUG
#include"ImGui.h"
#include "DebugCamera.h"
#include "DebugUIManager.h"
#endif

void TitleScene::Initialize()
{
	/// ================================== ///
	///              åˆæœŸåŒ–å‡¦ç†              ///
	/// ================================== ///

  // ã‚¨ãƒŸãƒƒã‚¿ãƒžãƒãƒ¼ã‚¸ãƒ£ç”Ÿæˆ
  emitterManager_ = std::make_unique<EmitterManager>(GPUParticle::GetInstance());

  // å„ç¨®åˆæœŸåŒ–å‡¦ç†ã‚’é–¢æ•°åŒ–ã—ã¦å‘¼ã³å‡ºã—
  InitializeDebugUI();       // ãƒ‡ãƒãƒƒã‚°UIåˆæœŸåŒ–
  InitializeCamera();         // ã‚«ãƒ¡ãƒ©è¨­å®š
  InitializePostEffects();    // ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®š
  InitializeSprites();        // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåˆæœŸåŒ–
  InitializeParticles();      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åˆæœŸåŒ–
}

void TitleScene::Finalize()
{
#ifdef _DEBUG
  // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®ç™»éŒ²è§£é™¤
  DebugUIManager::GetInstance()->ClearDebugInfo();
  // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç™»éŒ²è§£é™¤
  DebugUIManager::GetInstance()->ClearGameObjects();
#endif

  PostEffectManager::GetInstance()->ClearEffectChain();
}

void TitleScene::Update()
{
	/// ================================== ///
	///              æ›´æ–°å‡¦ç†               ///
	/// ================================== ///

  // å„ç¨®æ›´æ–°å‡¦ç†ã‚’é–¢æ•°åŒ–ã—ã¦å‘¼ã³å‡ºã—
  UpdateWindowResize();           // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå‡¦ç†
  UpdateStartButtonBlink();       // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ç‚¹æ»…æ›´æ–°
  UpdateTitleTextAnimation();     // ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
  UpdateSlashParticleAnimation(); // slashãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
  UpdateTitleEffectAnimation();   // ã‚¿ã‚¤ãƒˆãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
  UpdateInput();                  // å…¥åŠ›å‡¦ç†

  // åŸºæœ¬çš„ãªã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°
  titleBG_->Update();
  startButtonText_->Update();

  // ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’æ›´æ–°
  if (currentFrame_ >= 0 && currentFrame_ < titleTextSprites_.size()) {
    titleTextSprites_[currentFrame_]->Update();
  }

  // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®æ›´æ–°
  emitterManager_->Update();
}

void TitleScene::Draw()
{
	/// ================================== ///
	///              æç”»å‡¦ç†               ///
	/// ================================== ///

	//------------------èƒŒæ™¯Spriteã®æç”»------------------//
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
	SpriteBasic::GetInstance()->SetCommonRenderSetting();

  titleBG_->Draw();


	//-------------------Modelã®æç”»-------------------//
	// 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
	Object3dBasic::GetInstance()->SetCommonRenderSetting();




	//------------------å‰æ™¯Spriteã®æç”»------------------//
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
	SpriteBasic::GetInstance()->SetCommonRenderSetting();

  // ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»
  if (currentFrame_ >= 0 && currentFrame_ < titleTextSprites_.size()) {
    titleTextSprites_[currentFrame_]->Draw();
  }

  // æ‹¡å¤§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æç”»ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã®ä¸Šã«æç”»ï¼‰
  if (isEffectPlaying_ && titleTextEffect_) {
    titleTextEffect_->Draw();
  }

}

void TitleScene::DrawWithoutEffect()
{
  /// ================================== ///
  ///              æç”»å‡¦ç†               ///
  /// ================================== ///

  //------------------èƒŒæ™¯Spriteã®æç”»------------------//
  // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
  SpriteBasic::GetInstance()->SetCommonRenderSetting();




  //-------------------Modelã®æç”»-------------------//
  // 3Dãƒ¢ãƒ‡ãƒ«å…±é€šæç”»è¨­å®š
  Object3dBasic::GetInstance()->SetCommonRenderSetting();





  //------------------å‰æ™¯Spriteã®æç”»------------------//
  // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šæç”»è¨­å®š
  SpriteBasic::GetInstance()->SetCommonRenderSetting();


  startButtonText_->Draw();

}

void TitleScene::DrawImGui()
{
#ifdef _DEBUG

	/// ================================== ///
	///             ImGuiã®æç”»              ///
	/// ================================== ///

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ãƒœã‚¿ãƒ³
  if (ImGui::Button("Play Animation")) {
    PlayTitleAnimation();
  }
  ImGui::SameLine();
  if (ImGui::Button("Stop Animation")) {
    StopTitleAnimation();
  }
  ImGui::SameLine();
  if (ImGui::Button("Reset Animation")) {
    ResetTitleAnimation();
  }

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
  ImGui::Separator();
  ImGui::Text("Animation Settings");
  ImGui::SliderInt("Animation Speed", &animationSpeed_, 1, 30);
  ImGui::Checkbox("Loop", &isLoop_);

  // ç¾åœ¨ã®çŠ¶æ…‹è¡¨ç¤º
  ImGui::Separator();
  ImGui::Text("Status");
  ImGui::Text("Current Frame: %d / %d", currentFrame_ + 1, static_cast<int>(titleTextSprites_.size()));
  ImGui::Text("Is Playing: %s", isPlaying_ ? "Yes" : "No");
  ImGui::Text("Animation Complete: %s", animationComplete_ ? "Yes" : "No");

  // æ‰‹å‹•ãƒ•ãƒ¬ãƒ¼ãƒ åˆ¶å¾¡
  ImGui::Separator();
  ImGui::Text("Manual Frame Control");
  if (ImGui::SliderInt("Frame", &currentFrame_, 0, static_cast<int>(titleTextSprites_.size()) - 1)) {
    // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‰‹å‹•ã§å¤‰æ›´ã—ãŸå ´åˆã¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
    isPlaying_ = false;
  }

  // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ç‚¹æ»…ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
  // ç‚¹æ»…æœ‰åŠ¹/ç„¡åŠ¹ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
  ImGui::Checkbox("Enable Blinking", &isButtonBlinking_);

  // ç‚¹æ»…ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®èª¿æ•´
  ImGui::Separator();
  ImGui::Text("Blink Parameters");
  ImGui::SliderFloat("Blink Speed", &blinkSpeed_, 0.5f, 10.0f, "%.1f");
  ImGui::SliderFloat("Min Alpha", &blinkMinAlpha_, 0.0f, 1.0f, "%.2f");
  ImGui::SliderFloat("Max Alpha", &blinkMaxAlpha_, 0.0f, 1.0f, "%.2f");

  // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
  if (ImGui::Button("Reset Timer")) {
    blinkTimer_ = 0.0f;
  }

  // ç¾åœ¨ã®çŠ¶æ…‹è¡¨ç¤º
  ImGui::Separator();
  ImGui::Text("Current Status");
  ImGui::Text("Timer: %.2f", blinkTimer_);
  float currentAlpha = startButtonText_->GetColor().w;
  ImGui::Text("Current Alpha: %.2f", currentAlpha);

  // ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®š
  ImGui::Separator();
  ImGui::Text("Presets");
  if (ImGui::Button("Slow Fade")) {
    blinkSpeed_ = 1.0f;
    blinkMinAlpha_ = 0.3f;
    blinkMaxAlpha_ = 1.0f;
  }
  ImGui::SameLine();
  if (ImGui::Button("Fast Blink")) {
    blinkSpeed_ = 5.0f;
    blinkMinAlpha_ = 0.0f;
    blinkMaxAlpha_ = 1.0f;
  }
  ImGui::SameLine();
  if (ImGui::Button("Gentle Pulse")) {
    blinkSpeed_ = 2.0f;
    blinkMinAlpha_ = 0.5f;
    blinkMaxAlpha_ = 1.0f;
  }

  // æ‹¡å¤§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
  ImGui::Separator();
  ImGui::Text("Title Text Expansion Effect");

  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ‰‹å‹•ãƒˆãƒªã‚¬ãƒ¼
  if (ImGui::Button("Trigger Effect")) {
    isEffectPlaying_ = true;
    effectTriggered_ = false;  // ãƒªã‚»ãƒƒãƒˆã—ã¦å†åº¦ãƒˆãƒªã‚¬ãƒ¼å¯èƒ½ã«ã™ã‚‹
    effectTimer_ = 0.0f;
    effectScale_ = 1.0f;
    effectAlpha_ = effectInitialAlpha_;
  }
  ImGui::SameLine();
  if (ImGui::Button("Stop Effect")) {
    isEffectPlaying_ = false;
    effectAlpha_ = 0.0f;
  }

  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
  ImGui::SliderFloat("Effect Duration", &effectDuration_, 0.5f, 5.0f, "%.1f sec");
  ImGui::SliderFloat("Max Scale", &effectMaxScale_, 1.0f, 3.0f, "%.1f");
  ImGui::SliderFloat("Initial Alpha", &effectInitialAlpha_, 0.0f, 1.0f, "%.2f");

  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçŠ¶æ…‹è¡¨ç¤º
  ImGui::Text("Effect Status");
  ImGui::Text("Is Playing: %s", isEffectPlaying_ ? "Yes" : "No");
  ImGui::Text("Timer: %.2f / %.2f", effectTimer_, effectDuration_);
  ImGui::Text("Current Scale: %.2f", effectScale_);
  ImGui::Text("Current Alpha: %.2f", effectAlpha_);

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒªã‚»ãƒƒãƒˆ
  if (ImGui::Button("Reset All")) {
    ResetTitleAnimation();
    isEffectPlaying_ = false;
    effectTriggered_ = false;
    effectTimer_ = 0.0f;
    effectScale_ = 1.0f;
    effectAlpha_ = 0.0f;
    titleTextEffect_->SetAlpha(0.0f);
  }

  // Slashãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
  ImGui::Separator();
  ImGui::Text("Slash Particle Animation");

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡
  if (ImGui::Button("Start Particle Animation")) {
    isSlashEmitterAnimating_ = true;
    slashEmitterAnimTimer_ = 0.0f;
  }
  ImGui::SameLine();
  if (ImGui::Button("Stop Particle Animation")) {
    isSlashEmitterAnimating_ = false;
  }

  // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
  ImGui::Text("Start Values:");
  int startCount = static_cast<int>(slashEmitterStartCount_);
  if (ImGui::SliderInt("Start Count", &startCount, 1, 200)) {
    slashEmitterStartCount_ = static_cast<uint32_t>(startCount);
  }
  ImGui::SliderFloat("Start Frequency", &slashEmitterStartFreq_, 0.001f, 1.0f, "%.3f");

  ImGui::Text("End Values:");
  int endCount = static_cast<int>(slashEmitterEndCount_);
  if (ImGui::SliderInt("End Count", &endCount, 1, 300)) {
    slashEmitterEndCount_ = static_cast<uint32_t>(endCount);
  }
  ImGui::SliderFloat("End Frequency", &slashEmitterEndFreq_, 0.001f, 1.0f, "%.3f");

  // ç¾åœ¨ã®çŠ¶æ…‹è¡¨ç¤º
  ImGui::Text("Current Status:");
  ImGui::Text("Is Animating: %s", isSlashEmitterAnimating_ ? "Yes" : "No");
  ImGui::Text("Timer: %.2f / %.2f", slashEmitterAnimTimer_, slashEmitterAnimDuration_);

  auto slashEmitter = emitterManager_->GetEmitterByName("slash");
  if (slashEmitter) {
    ImGui::Text("Current Count: %u", slashEmitter->GetParticleCount());
    ImGui::Text("Current Frequency: %.3f", slashEmitter->GetFrequency());
  }

#endif // _DEBUG
}

void TitleScene::PlayTitleAnimation()
{
  isPlaying_ = true;
  animationComplete_ = false;

  // slashãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚‚é–‹å§‹
  isSlashEmitterAnimating_ = true;
  slashEmitterAnimTimer_ = 0.0f;

}

void TitleScene::StopTitleAnimation()
{
  isPlaying_ = false;
}

void TitleScene::ResetTitleAnimation()
{
  currentFrame_ = 0;
  frameCounter_ = 0;
  isPlaying_ = false;
  animationComplete_ = false;

  // slashãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚‚ãƒªã‚»ãƒƒãƒˆ
  isSlashEmitterAnimating_ = false;
  slashEmitterAnimTimer_ = 0.0f;

  // slashã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚’åˆæœŸå€¤ã«æˆ»ã™
  auto slashEmitter = emitterManager_->GetEmitterByName("slash");
  if (slashEmitter) {
    slashEmitter->SetParticleCount(slashEmitterStartCount_);
    slashEmitter->SetFrequency(slashEmitterStartFreq_);
  }
}

void TitleScene::InitializeDebugUI()
{
#ifdef _DEBUG
  DebugCamera::GetInstance()->Initialize();
  Object3dBasic::GetInstance()->SetDebug(false);
  Draw2D::GetInstance()->SetDebug(false);
  GPUParticle::GetInstance()->SetIsDebug(false);

  // TitleSceneè‡ªä½“ã®ãƒ‡ãƒãƒƒã‚°UIç™»éŒ²
  DebugUIManager::GetInstance()->RegisterGameObject("TitleScene",
    [this]() { this->DrawImGui(); });

  // èƒŒæ™¯ã®ãƒ‡ãƒãƒƒã‚°UIç™»éŒ²
  DebugUIManager::GetInstance()->RegisterGameObject("BackGround",
    [this]() { if (titleBG_) titleBG_->DrawImGui(); });

  // ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ãƒ‡ãƒãƒƒã‚°UIç™»éŒ²ï¼ˆ10æžšï¼‰
  for (int i = 0; i < 10; ++i) {
    DebugUIManager::GetInstance()->RegisterGameObject("TitleText" + std::to_string(i + 1),
      [this, i]() {
        titleTextSprites_[i]->DrawImGui();
      });
  }

  // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ‡ãƒãƒƒã‚°UIç™»éŒ²
  DebugUIManager::GetInstance()->RegisterGameObject("StartButtonText",
    [this]() { if (startButtonText_) startButtonText_->DrawImGui(); });

  // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®è¨­å®š
  DebugUIManager::GetInstance()->SetEmitterManager(emitterManager_.get());
#endif
}

void TitleScene::InitializeCamera()
{
  // ã‚«ãƒ¡ãƒ©ã®å›žè»¢ã¨ä½ç½®ã‚’è¨­å®š
  (*Object3dBasic::GetInstance()->GetCamera())->SetRotate(Vector3(0.2f, 0.0f, 0.0f));
  (*Object3dBasic::GetInstance()->GetCamera())->SetTranslate(Vector3(0.0f, cameraY_ + offsetY, cameraZ_));
}

void TitleScene::InitializePostEffects()
{
  // RGBSplitã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
  rgbSplitParam_.redOffset = Vector2(-0.01f, 0.f);
  rgbSplitParam_.greenOffset = Vector2(0.01f, 0.f);
  rgbSplitParam_.blueOffset = Vector2(0.0f, 0.f);
  rgbSplitParam_.intensity = 0.08f;

  // Vignetteã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
  vignetteParam_.color = Vector3(1.f, 1.f, 1.f);
  vignetteParam_.power = 0.02f;
  vignetteParam_.range = 20.0f;

  // ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒã‚§ãƒ¼ãƒ³ã«è¿½åŠ 
  PostEffectManager::GetInstance()->AddEffectToChain("RGBSplit");
  PostEffectManager::GetInstance()->AddEffectToChain("Vignette");
  PostEffectManager::GetInstance()->SetEffectParam("RGBSplit", rgbSplitParam_);
  PostEffectManager::GetInstance()->SetEffectParam("Vignette", vignetteParam_);
}

void TitleScene::InitializeSprites()
{
  // èƒŒæ™¯ç”»åƒã®åˆæœŸåŒ–
  titleBG_ = make_unique<Sprite>();
  titleBG_->Initialize("black.png");
  titleBG_->SetPos(Vector2(0.f, 0.f));
  titleBG_->SetSize(Vector2(static_cast<float>(WinApp::clientWidth), static_cast<float>(WinApp::clientHeight)));

  // ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã®åˆæœŸåŒ–ï¼ˆ10æžšã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ç”»åƒï¼‰
  titleTextSprites_.reserve(10);  // 10æžšåˆ†ã®ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿
  for (int i = 0; i < 10; ++i) {
    std::string texturePath = "title_text/title_text_" + std::to_string(i + 1) + ".png";
    auto sprite = make_unique<Sprite>();
    sprite->Initialize(texturePath);
    sprite->SetSize(Vector2(titleTextWidth_, titleTextHeight_));
    sprite->SetPos(Vector2(WinApp::clientWidth / 2.f - titleTextWidth_ / 2.f, titleTextY_));
    titleTextSprites_.push_back(std::move(sprite));
  }

  // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åˆæœŸåŒ–
  startButtonText_ = make_unique<Sprite>();
  startButtonText_->Initialize("title_button.png");
  startButtonText_->SetPos(Vector2(
    WinApp::clientWidth / 2.f - startButtonText_->GetSize().x / 2.f,
    WinApp::clientHeight - startButtonBottomOffset_));

  // ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–ï¼ˆæ‹¡å¤§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆç”¨ï¼‰
  titleTextEffect_ = make_unique<Sprite>();
  titleTextEffect_->Initialize("title_text/title_text_10.png");
  titleTextEffect_->SetSize(Vector2(titleTextWidth_, titleTextHeight_));
  titleTextEffect_->SetPos(Vector2(WinApp::clientWidth / 2.f - titleTextWidth_ / 2.f, titleTextY_));
  titleTextEffect_->SetAlpha(0.0f);  // åˆæœŸçŠ¶æ…‹ã§ã¯éžè¡¨ç¤º
}

void TitleScene::InitializeParticles()
{
  // ã‚¨ãƒŸãƒƒã‚¿ãƒžãƒãƒ¼ã‚¸ãƒ£ã‹ã‚‰ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿
  emitterManager_->LoadScenePreset("title_preset");

  // slashã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®åˆæœŸè¨­å®š
  auto slashEmitter = emitterManager_->GetEmitterByName("slash");
  if (slashEmitter) {
    // åˆæœŸå€¤ã‚’è¨­å®š
    slashEmitter->SetParticleCount(slashEmitterStartCount_);
    slashEmitter->SetFrequency(slashEmitterStartFreq_);
  }
}

void TitleScene::UpdateWindowResize()
{
  // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã«å¿œã˜ã¦ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ä½ç½®ã‚’èª¿æ•´
  titleBG_->SetSize(Vector2(static_cast<float>(WinApp::clientWidth), static_cast<float>(WinApp::clientHeight)));

  // ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã®ä½ç½®æ›´æ–°ï¼ˆã™ã¹ã¦ã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ä½ç½®ã‚’æ›´æ–°ï¼‰
  for (auto& sprite : titleTextSprites_) {
    sprite->SetPos(Vector2(WinApp::clientWidth / 2.f - sprite->GetSize().x / 2.f, titleTextY_));
  }

  // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ä½ç½®æ›´æ–°
  startButtonText_->SetPos(Vector2(
    WinApp::clientWidth / 2.f - startButtonText_->GetSize().x / 2.f,
    WinApp::clientHeight - startButtonBottomOffset_));
}

void TitleScene::UpdateStartButtonBlink()
{
  // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ç‚¹æ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
  if (!isButtonBlinking_) return;

  // ã‚¿ã‚¤ãƒžãƒ¼ã‚’æ›´æ–°ï¼ˆ60FPSã‚’æƒ³å®šã—ã¦1/60ç§’ãšã¤åŠ ç®—ï¼‰
  blinkTimer_ += 1.0f / 60.0f;
  if (blinkTimer_ > 1000.f) blinkTimer_ = 0.f; // ã‚¿ã‚¤ãƒžãƒ¼ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼é˜²æ­¢

  // ã‚µã‚¤ãƒ³æ³¢ã‚’ä½¿ç”¨ã—ã¦ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’è¨ˆç®—
  // siné–¢æ•°ã®çµæžœï¼ˆ-1ã€œ1ï¼‰ã‚’0ã€œ1ã®ç¯„å›²ã«æ­£è¦åŒ–ã—ã€æŒ‡å®šç¯„å›²ã«ãƒžãƒƒãƒ”ãƒ³ã‚°
  float sineValue = std::sin(blinkTimer_ * blinkSpeed_ * std::numbers::pi_v<float>);
  float normalizedSine = (sineValue + 1.0f) * 0.5f;  // -1ã€œ1 ã‚’ 0ã€œ1 ã«å¤‰æ›
  float alpha = blinkMinAlpha_ + (blinkMaxAlpha_ - blinkMinAlpha_) * normalizedSine;

  // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã«é©ç”¨
  startButtonText_->SetAlpha(alpha);
}

void TitleScene::UpdateTitleTextAnimation()
{
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°å‡¦ç†
  if (!isPlaying_) return;

  frameCounter_++;

  // æŒ‡å®šã•ã‚ŒãŸé€Ÿåº¦ã§ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’åˆ‡ã‚Šæ›¿ãˆ
  if (frameCounter_ >= animationSpeed_) {
    frameCounter_ = 0;
    currentFrame_++;

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®çµ‚ç«¯å‡¦ç†
    if (currentFrame_ >= titleTextSprites_.size()) {
      if (isLoop_) {
        // ãƒ«ãƒ¼ãƒ—å†ç”Ÿã®å ´åˆã¯æœ€åˆã«æˆ»ã‚‹
        currentFrame_ = 0;
      } else {
        // ãƒ«ãƒ¼ãƒ—ã—ãªã„å ´åˆã¯æœ€å¾Œã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§åœæ­¢
        currentFrame_ = static_cast<int>(titleTextSprites_.size()) - 1;
        isPlaying_ = false;
        animationComplete_ = true;
      }
    }
  }

  // ã‚¿ã‚¤ãƒˆãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’é–‹å§‹
  if (animationComplete_ && !effectTriggered_ && !isLoop_) {
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä¸€åº¦ã ã‘ãƒˆãƒªã‚¬ãƒ¼
    isEffectPlaying_ = true;
    effectTriggered_ = true;
    effectTimer_ = 0.0f;
    effectScale_ = 1.0f;
    effectAlpha_ = effectInitialAlpha_;
  }
}

void TitleScene::UpdateSlashParticleAnimation()
{
  // slashãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
  if (!isSlashEmitterAnimating_) return;

  // ã‚¿ã‚¤ãƒžãƒ¼ã‚’æ›´æ–°ï¼ˆ60FPSã‚’æƒ³å®šï¼‰
  slashEmitterAnimTimer_ += 1.0f / 60.0f;

  // é€²è¡Œåº¦ã‚’è¨ˆç®—ï¼ˆ0.0 ã€œ 1.0ï¼‰
  float progress = slashEmitterAnimTimer_ / slashEmitterAnimDuration_;

  if (progress >= sceneTransitionProgress_) {
    SceneManager::GetInstance()->ChangeScene("game","Fade",0.2f);
  }

  if (progress >= 1.0f) {
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†
    progress = 1.0f;
    isSlashEmitterAnimating_ = false;
  }

  // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚’å–å¾—ã—ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ›´æ–°
  auto slashEmitter = emitterManager_->GetEmitterByName("slash");
  if (slashEmitter) {
    // countå€¤ã‚’ç·šå½¢è£œé–“
    uint32_t currentCount = static_cast<uint32_t>(
      slashEmitterStartCount_ +
      (slashEmitterEndCount_ - slashEmitterStartCount_) * progress
    );

    // frequencyå€¤ã‚’ç·šå½¢è£œé–“
    float currentFreq = slashEmitterStartFreq_ +
      (slashEmitterEndFreq_ - slashEmitterStartFreq_) * progress;

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨
    slashEmitter->SetParticleCount(currentCount);
    slashEmitter->SetFrequency(currentFreq);
  }
}

void TitleScene::UpdateTitleEffectAnimation()
{
  // æ‹¡å¤§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
  if (!isEffectPlaying_) return;

  // ã‚¿ã‚¤ãƒžãƒ¼ã‚’æ›´æ–°ï¼ˆ60FPSã‚’æƒ³å®šï¼‰
  effectTimer_ += 1.0f / 60.0f;

  // é€²è¡Œåº¦ã‚’è¨ˆç®—ï¼ˆ0.0 ã€œ 1.0ï¼‰
  float progress = effectTimer_ / effectDuration_;

  if (progress >= 1.0f) {
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçµ‚äº†
    progress = 1.0f;
    isEffectPlaying_ = false;
    effectAlpha_ = 0.0f;
  } else {
    // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ç·šå½¢è£œé–“ã§æ‹¡å¤§
    effectScale_ = 1.0f + (effectMaxScale_ - 1.0f) * progress;

    // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’ç·šå½¢è£œé–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
    effectAlpha_ = effectInitialAlpha_ * (1.0f - progress);
  }

  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã«é©ç”¨
  titleTextEffect_->SetSize(Vector2(titleTextWidth_ * effectScale_, titleTextHeight_ * effectScale_));
  // æ‹¡å¤§ã—ã¦ã‚‚ã‚»ãƒ³ã‚¿ãƒ¼ã«ä¿ã¤ãŸã‚ã«ä½ç½®ã‚’èª¿æ•´
  float centerX = WinApp::clientWidth / 2.f;
  float centerY = titleTextY_ + titleTextHeight_ / 2.f; // å…ƒã®ä½ç½® + é«˜ã•ã®åŠåˆ†
  titleTextEffect_->SetPos(Vector2(
    centerX - (titleTextWidth_ / 2.f * effectScale_),
    centerY - (titleTextHeight_ / 2.f * effectScale_)
  ));
  titleTextEffect_->SetAlpha(effectAlpha_);
  titleTextEffect_->Update();
}

void TitleScene::UpdateInput()
{
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã¾ãŸã¯ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã®å…¥åŠ›å‡¦ç†
  if (Input::GetInstance()->TriggerKey(DIK_SPACE) ||
    Input::GetInstance()->TriggerButton(XButtons.A))
  {
    // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼æŠ¼ä¸‹æ™‚ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
    if (!isPlaying_) {
      PlayTitleAnimation();
    }
  }
}

============================================================
File Path: GameProject/scene/TitleScene.h
============================================================
#pragma once
#include "BaseScene.h"
#include"Sprite.h"
#include"Object3d.h"
#include "AABB.h"
#include "EmitterManager.h"
#include "PostEffectManager.h"
#include "CameraSystem/CameraConfig.h"
#include <vector>
#include <memory>

/// <summary>
/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹
/// ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®æ¼”å‡ºã€UIè¡¨ç¤ºã€ã‚²ãƒ¼ãƒ é–‹å§‹å‡¦ç†ã‚’ç®¡ç†
/// </summary>
class TitleScene : public BaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw() override;
	void DrawWithoutEffect() override;

	/// <summary>
	/// ImGuiã®æç”»
	/// </summary>
	void DrawImGui() override;

	/// <summary>
	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
	/// </summary>
	void PlayTitleAnimation();

	/// <summary>
	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
	/// </summary>
	void StopTitleAnimation();

	/// <summary>
	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ
	/// </summary>
	void ResetTitleAnimation();

private: // ãƒ¡ãƒ³ãƒé–¢æ•°

	// === åˆæœŸåŒ–ç³»é–¢æ•° === //

	/// <summary>
	/// ãƒ‡ãƒãƒƒã‚°UIã®åˆæœŸåŒ–
	/// GlobalVariablesã«ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç™»éŒ²
	/// </summary>
	void InitializeDebugUI();

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®åˆæœŸåŒ–
	/// ã‚«ãƒ¡ãƒ©ä½ç½®ã¨æ³¨è¦–ç‚¹ã‚’è¨­å®š
	/// </summary>
	void InitializeCamera();

	/// <summary>
	/// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–
	/// RGBSplitã¨Vignetteã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¨­å®š
	/// </summary>
	void InitializePostEffects();

	/// <summary>
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	/// èƒŒæ™¯ã€ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã€ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ãªã©ã®UIè¦ç´ ã‚’ä½œæˆ
	/// </summary>
	void InitializeSprites();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åˆæœŸåŒ–
	/// ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®è¨­å®šã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æº–å‚™
	/// </summary>
	void InitializeParticles();

	// === æ›´æ–°ç³»é–¢æ•° === //

	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå‡¦ç†
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ä½ç½®ã‚„ã‚µã‚¤ã‚ºã‚’æ–°ã—ã„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦èª¿æ•´
	/// </summary>
	void UpdateWindowResize();

	/// <summary>
	/// ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ç‚¹æ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	/// sinã‚«ãƒ¼ãƒ–ã‚’ä½¿ç”¨ã—ã¦ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’æ»‘ã‚‰ã‹ã«å¤‰åŒ–ã•ã›ã‚‹
	/// </summary>
	void UpdateStartButtonBlink();

	/// <summary>
	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	/// ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ0ã€œ9ã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’é †æ¬¡è¡¨ç¤ºï¼‰ã‚’åˆ¶å¾¡
	/// </summary>
	void UpdateTitleTextAnimation();

	/// <summary>
	/// slashãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨åŒæœŸã—ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿé‡ã‚’å¢—åŠ 
	/// </summary>
	void UpdateSlashParticleAnimation();

	/// <summary>
	/// ã‚¿ã‚¤ãƒˆãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã®æ‹¡å¤§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’åˆ¶å¾¡
	/// </summary>
	void UpdateTitleEffectAnimation();

	/// <summary>
	/// å…¥åŠ›å‡¦ç†
	/// ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã¾ãŸã¯Aãƒœã‚¿ãƒ³ã§ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã¸é·ç§»
	/// </summary>
	void UpdateInput();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

	std::unique_ptr<EmitterManager> emitterManager_;  ///< ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç®¡ç†

	std::unique_ptr<Sprite> titleBG_;  ///< èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ

	std::vector<std::unique_ptr<Sprite>> titleTextSprites_;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼ˆ10ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†ï¼‰

	std::unique_ptr<Sprite> startButtonText_;  ///< ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼ˆç‚¹æ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¯¾è±¡ï¼‰

	std::unique_ptr<Sprite> titleTextEffect_;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼ˆæ‹¡å¤§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆç”¨ï¼‰

	RGBSplitParam rgbSplitParam_{};  ///< RGBSplitãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	VignetteParam vignetteParam_{};  ///< Vignetteãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

	float offsetY = CameraConfig::HIDDEN_Y;  ///< ã‚«ãƒ¡ãƒ©éžè¡¨ç¤ºç”¨Yæ–¹å‘ã‚ªãƒ•ã‚»ãƒƒãƒˆ

	// === ã‚«ãƒ¡ãƒ©ä½ç½®ç”¨å¤‰æ•° === //
	float cameraY_ = 9.0f;  ///< ã‚«ãƒ¡ãƒ©Yåº§æ¨™
	float cameraZ_ = -34.0f;  ///< ã‚«ãƒ¡ãƒ©Zåº§æ¨™

	// === UIä½ç½®ãƒ»ã‚µã‚¤ã‚ºç”¨å¤‰æ•° === //
	float titleTextWidth_ = 500.0f;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆå¹…
	float titleTextHeight_ = 200.0f;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆé«˜ã•
	float titleTextY_ = 100.0f;  ///< ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆYåº§æ¨™
	float startButtonBottomOffset_ = 250.0f;  ///< ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ä¸‹ç«¯ã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	float sceneTransitionProgress_ = 0.9f;  ///< ã‚·ãƒ¼ãƒ³é·ç§»ãƒˆãƒªã‚¬ãƒ¼é€²è¡Œåº¦

	// === ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ç”¨å¤‰æ•° === //
	int currentFrame_ = 0;  ///< ç¾åœ¨è¡¨ç¤ºä¸­ã®ãƒ•ãƒ¬ãƒ¼ãƒ ç•ªå·ï¼ˆ0ã€œ9ï¼‰

	int frameCounter_ = 0;  ///< ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é€Ÿåº¦åˆ¶å¾¡ç”¨ï¼‰

	int animationSpeed_ = 1;  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é€Ÿåº¦ï¼ˆä½•ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã‹ï¼‰

	bool isPlaying_ = false;  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿä¸­ãƒ•ãƒ©ã‚°

	bool isLoop_ = false;  ///< ãƒ«ãƒ¼ãƒ—å†ç”Ÿãƒ•ãƒ©ã‚°

	bool animationComplete_ = false;  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ãƒ•ãƒ©ã‚°

	// === ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ç‚¹æ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨å¤‰æ•° === //
	float blinkTimer_ = 0.0f;  ///< ç‚¹æ»…ç”¨ã‚¿ã‚¤ãƒžãƒ¼ï¼ˆçµŒéŽæ™‚é–“ï¼‰

	float blinkSpeed_ = 1.2f;  ///< ç‚¹æ»…é€Ÿåº¦ï¼ˆå‘¨æœŸã®é€Ÿã•ï¼‰

	float blinkMinAlpha_ = 0.0f;  ///< ç‚¹æ»…ã®æœ€å°ã‚¢ãƒ«ãƒ•ã‚¡å€¤ï¼ˆå®Œå…¨é€æ˜Žï¼‰

	float blinkMaxAlpha_ = 1.0f;  ///< ç‚¹æ»…ã®æœ€å¤§ã‚¢ãƒ«ãƒ•ã‚¡å€¤ï¼ˆå®Œå…¨ä¸é€æ˜Žï¼‰

	bool isButtonBlinking_ = true;  ///< ç‚¹æ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æœ‰åŠ¹ãƒ•ãƒ©ã‚°

	// === ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆæ‹¡å¤§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨å¤‰æ•° === //
	bool isEffectPlaying_ = false;  ///< ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå†ç”Ÿä¸­ãƒ•ãƒ©ã‚°

	float effectTimer_ = 0.0f;  ///< ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçµŒéŽæ™‚é–“ã‚¿ã‚¤ãƒžãƒ¼

	float effectDuration_ = 1.5f;  ///< ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æŒç¶šæ™‚é–“ï¼ˆç§’ï¼‰

	float effectScale_ = 1.0f;  ///< ç¾åœ¨ã®ã‚¹ã‚±ãƒ¼ãƒ«å€¤

	float effectMaxScale_ = 1.5f;  ///< æœ€çµ‚ã‚¹ã‚±ãƒ¼ãƒ«å€¤ï¼ˆæ‹¡å¤§ã®ä¸Šé™ï¼‰

	float effectAlpha_ = 0.5f;  ///< ç¾åœ¨ã®ã‚¢ãƒ«ãƒ•ã‚¡å€¤

	float effectInitialAlpha_ = 0.5f;  ///< åˆæœŸã‚¢ãƒ«ãƒ•ã‚¡å€¤

	bool effectTriggered_ = false;  ///< ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹ãƒˆãƒªã‚¬ãƒ¼ï¼ˆä¸€åº¦ã ã‘å®Ÿè¡Œï¼‰

	// === slashãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨å¤‰æ•° === //
	bool isSlashEmitterAnimating_ = false;  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ãƒ•ãƒ©ã‚°

	float slashEmitterAnimTimer_ = 0.0f;  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµŒéŽæ™‚é–“ã‚¿ã‚¤ãƒžãƒ¼

	float slashEmitterAnimDuration_ = 2.5f;  ///< ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æŒç¶šæ™‚é–“ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆã¨åŒæœŸï¼š10ãƒ•ãƒ¬ãƒ¼ãƒ  * animationSpeed / 60fpsï¼‰

	uint32_t slashEmitterStartCount_ = 1;  ///< Countå€¤ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹å€¤ï¼ˆåˆæœŸç™ºç”Ÿæ•°ï¼‰
	uint32_t slashEmitterEndCount_ = 300;  ///< Countå€¤ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å€¤ï¼ˆæœ€å¤§ç™ºç”Ÿæ•°ï¼‰

	float slashEmitterStartFreq_ = 1.0f;  ///< Frequencyå€¤ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹å€¤ï¼ˆåˆæœŸç™ºç”Ÿé »åº¦ï¼‰
	float slashEmitterEndFreq_ = 0.001f;  ///< Frequencyå€¤ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å€¤ï¼ˆæœ€çµ‚ç™ºç”Ÿé »åº¦ï¼‰
};

